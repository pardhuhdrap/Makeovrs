<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Makeovrs</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#3b82f6">


<!-- Tailwind & icons -->
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/lucide@latest"></script>

<!-- === Google Identity (for Sign-in) Hari === -->
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script>
  // REPLACE the placeholder value with your OAuth Web Client ID from Google Cloud Console:
  const CLIENT_ID = "698000626769-8mmgsqi4mumntijfcr7jcs1hnv5ksbmj.apps.googleusercontent.com";
  // Note: do NOT paste any client *secret* here. Only the client ID.
</script>
<!-- === end Google Identity block Hari === -->


<!-- PDF libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
#app { position: relative; }
header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 40;

  /* NEW: fix the bar height & center contents */
  height: 60px;          /* adjust 56 / 64 if you want */
  display: flex;
  align-items: center;
  padding: 0 16px;       /* no top/bottom padding, only left/right */
}
:root{--app-color:#3b82f6}
.app-color-bg{background:var(--app-color)}
.app-color-text{color:var(--app-color)}
.app-color-border{border-color:var(--app-color)}
.app-icon {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  margin: 0.5rem;
  background: #fff;
  border-radius: 0.75rem;
  box-shadow: 0 10px 15px rgba(0, 0, 0, 0.08);
  transition: all 0.18s;
  cursor: pointer;

  /* ðŸ‘‰ force 3 icons per row */
  flex: 0 0 calc(33.333% - 1rem);
  max-width: calc(33.333% - 1rem);
  height: 120px;
}

.app-icon:hover{box-shadow:0 20px 25px rgba(0,0,0,.08)}
#screen-wrapper { position: absolute; left: 0; right: 0; top: var(--app-header-height, 30px); bottom: 0; overflow-y: auto; }
.screen-container{
  position:absolute;
  inset:0;
  top: 16px;               /* ðŸ‘ˆ changed from 54px to 0 */
  background:#f8fafc;
  padding:1rem;
  transition:transform .3s;
  z-index:10;
  overflow-y:auto;
}
.message-modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50;padding:1rem}
.message-modal-content{background:#fff;padding:1.25rem;border-radius:1rem;box-shadow:0 25px 50px rgba(0,0,0,.18);max-width:28rem;width:100%; max-height:80vh; overflow-y:auto;}
.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.event-panel{border:1px solid #e6e6e6;border-radius:.5rem;background:#fff;overflow:hidden}
.event-panel .header{background:#fafafa;padding:.75rem 1rem;display:flex;justify-content:space-between;align-items:center;cursor:pointer}
.event-panel .body{padding:1rem;border-top:1px solid #eee}
.hidden{display:none!important}
.update-toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 24px; background: #111827; color: #fff; padding: 8px 14px; border-radius: 8px; z-index: 1200; box-shadow: 0 6px 18px rgba(0,0,0,0.25); opacity: 0; transition: opacity .18s, transform .18s; pointer-events: none; }
.update-toast.show { opacity: 1; transform: translateX(-50%) translateY(-6px); pointer-events: auto; }

/* Files page */
.files-toolbar { display:flex; gap:0.5rem; align-items:center; margin-bottom:0.75rem; }
.files-list { max-height: 48vh; overflow-y:auto; border:1px solid #e6e6e6; border-radius:0.5rem; background:white; padding:0.5rem; }
.file-item { display:flex; gap:0.75rem; align-items:center; justify-content:space-between; padding:0.5rem; border-bottom:1px solid #f1f1f1; }
.file-item .meta { display:flex; gap:0.5rem; align-items:center; }

/* calendar */
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 8px;
}
.calendar-cell {
  min-height:64px;
  display:flex;
  flex-direction:column;      /* NEW: stack children vertically */
  align-items:center;         /* NEW: center the circle + amount */
  justify-content:flex-start; /* content from top */
  padding-top:6px;
  position:relative;
  border-radius:8px;
}
.calendar-weekdays { display:grid; grid-template-columns: repeat(7, 1fr); gap:8px; margin-bottom:8px; text-align:center; color:#6b7280; font-weight:600; font-size:13px; }

.calendar-date-circle {
  width:36px; height:36px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-weight:700; color: #111827;
  background: transparent; transition: all .12s;
  box-shadow: 0 4px 10px rgba(0,0,0,0.04);
}
.calendar-date-circle.colored { color: #fff; }

/* popup */
.calendar-popup { position:fixed; z-index:150; left:50%; top:50%; transform:translate(-50%,-50%); background:white; border-radius:8px; padding:12px; width:92%; max-width:640px; max-height:76vh; overflow:auto; box-shadow:0 20px 50px rgba(0,0,0,0.25); }
.calendar-popup h3 { margin-top:0; }
.calendar-popup .event-row { border-bottom:1px dashed #eee; padding:8px 0; display:flex; justify-content:space-between; gap:8px; align-items:center; }
.calendar-popup .event-row .meta { display:flex; gap:8px; align-items:center; flex:1; }
.calendar-popup .event-row .meta .details { font-size:13px; color:#374151; }
.calendar-popup .event-row .meta .small { font-size:12px; color:#6b7280; }

/* booked pill */
.booked-pill { padding:4px 8px; border-radius:999px; font-size:12px; color:white; font-weight:600; }

/* colors */
.color-enquiry { background: #3b82f6; } /* Blue (changed) */
.color-booked-1 { background: #10b981; } /* green */
.color-booked-2 { background: #f59e0b; } /* orange */
.color-booked-3 { background: #ef4444; } /* red */
.color-booked-4 { background: #000000; } /* black */

.tab { padding:0.5rem 0.75rem; border-radius:0.5rem; cursor:pointer; }
.tab.active { background:var(--app-color); color:#fff; }

/* ================================
   GOOGLE MAPS AUTOCOMPLETE FIXES
   ================================ */

/* Ensure Google's dropdown appears above everything Hari */
.pac-container {
  z-index: 2147483647 !important;
}

/* Hide your old custom dropdown boxes so they don't conflict */
#originDropdown,
#destinationDropdown {
  display: none !important;
}

.screen-container {
  overflow-x: hidden;          /* no horizontal scrollbar */
  touch-action: pan-y;         /* gestures treated as vertical inside */
   padding-top: 16px;
}

.field-error-red {
  border: 2px solid red !important;
  background: #ffe6e6 !important;
}

/* Make all footer buttons share the row evenly */
#modalButtonRow button {
  flex: 1 1 0;
  min-width: 0;
}

/* Remove big gaps between buttons, they will fill from left to right */
#modalButtonRow {
  gap: 4px;
}

/* Mobile optimisation: slightly smaller buttons so they don't overflow */
@media (max-width: 480px) {
  #modalButtonRow button {
    padding: 6px 6px !important;
    font-size: 12px !important;
    white-space: nowrap !important;  /* text stays on one line */
  }

  #modalButtonRow {
     gap: 4px !important;
    flex-wrap: wrap;                 /* if still too tight, buttons wrap to next line */
  }
}

  /* === Client Requests floating button + panel === */
  .client-req-fab {
    position: absolute;
    top: 60px;
    bottom: auto;
    right: 10px;
    width: 52px;
    height: 52px;
    border-radius: 9999px;
    background: var(--app-color);
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.35);
    cursor: pointer;
    z-index: 60;
    touch-action: none; /* helps drag on mobile */
  }
  .client-req-fab.dragging {
    opacity: 0.85;
  }

  .client-req-panel {
    position: absolute;
    top: 100px;
    right: 16px;
    bottom: auto;
    width: 380px;
    max-width: calc(100% - 24px);
    max-height: 180vh;
    background: #ffffff;
    border-radius: 1rem;
    box-shadow: 0 10px 30px rgba(15, 23, 42, 0.35);
    z-index: 55;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .client-req-panel.hidden {
    display: none;
  }

  #clientRequestsFab {
  position: absolute;
}
#clientReqBadge {
  min-width: 18px;
  text-align: center;
  pointer-events: none;
}

/* === Dashboard Upcoming pad: remove gap to header & sides === */
#dashboard.screen-container {
  /* keep normal padding-bottom, but top/left/right are handled by the notepad */
  padding-top: 1rem;
  padding-left: 1rem;
  padding-right: 1rem;
}

#dashboardUpcoming {
  /* cancel the top + side padding of .screen-container */
  margin-top: -0.75rem;   /* pull yellow pad up towards header */
  margin-left: -1rem;     /* fill left padding */
  margin-right: -1rem;    /* fill right padding */
}

/* Extra top gap for detail screens so their H2 is not under the app header */
#invoice.screen-container,
#files.screen-container,
#revenue.screen-container,
#recycle.screen-container {
  padding-top: 3.5rem;   /* try 3rem / 4rem if you want less/more gap */
}

</style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center font-sans">

  <div id="app" class="w-full max-w-sm h-[92vh] bg-white rounded-3xl shadow-2xl overflow-hidden relative">

  <!-- header -->
  <header class="p-4 flex items-center justify-between text-white app-color-bg shadow-md">
    <button id="backButton" type="button" class="text-white p-1 rounded-full hover:bg-white/10 transition-all opacity-0 pointer-events-none" style="width:40px;height:40px" onclick="goBack()">
      <i data-lucide="chevron-left" class="w-6 h-6"></i>
    </button>

    <h1 id="app-title" class="text-xl font-bold truncate flex-grow text-center">App Name</h1>

    <div class="flex items-center gap-2">
       <!-- HOME button -->
      <button type="button" onclick="navigate('dashboard')" class="text-white p-1 rounded-full hover:bg-white/10 transition-all" title="Home">
        <i data-lucide="home" class="w-5 h-5"></i>
      </button>

      <!-- PROFILE / DRIVE MENU -->
      <div class="relative">
        <!-- always-visible user icon -->
        <button id="profileMenuButton"
        type="button"
        class="text-white p-1 rounded-full hover:bg-white/10 transition-all"
        title="Sign in / Drive">
 <img id="profileAvatar"
     class="h-14 w-14 rounded-full object-cover hidden" />

<i id="profileIconDefault"
   data-lucide="user"
   class="w-7 h-7"></i>
</button>


        <!-- dropdown menu -->
        <div id="profileMenu"
     class="hidden absolute right-0 mt-2 w-60 bg-white text-gray-800 rounded-lg shadow-lg border text-sm z-50">
  <div class="px-3 py-2 border-b">
    <div id="gdrive-user" class="font-medium">Not signed in</div>
    <div id="gdrive-status" class="text-xs text-gray-500 mt-1"></div>
  </div>

  <div class="flex flex-col px-2 py-2 gap-1">
    <!-- NEW: open your existing Settings screen from here -->
    <button
  id="btnUserProfileSettings"
  type="button"
  onclick="navigate('settings'); document.getElementById('profileMenu')?.classList.add('hidden');"
  class="w-full text-left px-2 py-1 rounded hover:bg-gray-100"
  style="display:none;"
>
  User Profile &amp; Settings
</button>

    <hr class="my-1">

    <button id="btnSignIn"
            type="button"
            class="w-full text-left px-2 py-1 rounded hover:bg-gray-100">
      Sign in with Google
    </button>

    <button id="btnSignOut"
            type="button"
            style="display:none;"
            class="w-full text-left px-2 py-1 rounded hover:bg-gray-100">
      Sign out
    </button>

    <button id="btnSaveDrive"
            type="button"
            style="display:none;"
            class="w-full text-left px-2 py-1 rounded hover:bg-gray-100">
      Save to Drive
    </button>

    <button id="btnLoadDrive"
            type="button"
            style="display:none;"
            class="w-full text-left px-2 py-1 rounded hover:bg-gray-100">
      Load from Drive
    </button>
  </div>
</div>


      </div>
    </div>
  </header>

  <div id="screen-wrapper" class="relative h-full overflow-y-auto">


    <!-- DASHBOARD -->
    <div id="dashboard" class="screen-container translate-x-0">
  <!-- Shown when SIGNED IN -->
  <div
    id="dashboardSignedIn"
    class="flex flex-wrap justify-center"
  >
      <!-- === UPCOMING EVENTS NOTEPAD === -->
<div id="dashboardUpcoming" class="w-full px-0 py-0">
  <div class="border border-yellow-400 bg-yellow-50 rounded-lg p-4 shadow-sm w-full">
    <div class="text-md font-semibold text-yellow-800 mb-2">Upcoming Events in next 15 days</div>

    <div id="dashboardUpcomingList" class="space-y-2 text-sm text-gray-700">
      <!-- Auto-filled by JS -->
      <div class="text-gray-400 text-xs italic">Loading upcoming events...</div>
    </div>
  </div>
</div>
  
  <div class="app-icon text-center" onclick="navigate('calendar')">
      <i data-lucide="calendar" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Event Calendar</span>
    </div>
    <div class="app-icon" onclick="navigate('quotation')">
      <i data-lucide="clipboard-list" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Quotation</span>
    </div>
    <div class="app-icon" onclick="navigate('invoice')">
      <i data-lucide="indian-rupee" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Invoice</span>
    </div>
    <div class="app-icon text-center" onclick="navigate('maps')">
      <i data-lucide="map-pin" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Distance Calculator</span>
    </div>
    <div class="app-icon text-center" onclick="navigate('master')">
      <i data-lucide="database" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Master Data</span>
    </div>
    <div class="app-icon" onclick="navigate('files')">
      <i data-lucide="folder" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Files</span>
    </div>
    <div class="app-icon" onclick="navigate('revenue')">
      <i data-lucide="banknote" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Revenue</span>
    </div>
    <div class="app-icon text-center" onclick="navigate('recycle')">
      <i data-lucide="trash-2" class="w-8 h-8 app-color-text"></i>
      <span class="mt-2 text-sm font-medium text-gray-700">Recycle Bin</span>
    </div>
  </div>

  <!-- Shown when NOT SIGNED IN -->
  <div
    id="dashboardSignedOut"
    class="hidden h-full flex items-center justify-center"
  >
    <div class="text-center px-4">
      <div class="text-lg font-semibold text-gray-800 mb-2">
        Sign in to view the dashboard
      </div>
      <p class="text-xs text-gray-500">
        Please sign in with Google to view the app dashboard and continue operations.
      </p>
    </div>
  </div>
</div>


    <!-- SETTINGS (kept compact but functional) -->
    <div id="settings" class="screen-container translate-x-full">
      <h2 class="text-2xl font-semibold mb-6 app-color-text border-b pb-2">App Settings</h2>
      <div class="bg-white p-6 rounded-xl shadow-lg mb-6" id="advancedSettingsBlock">
        <h3 class="text-xl font-medium mb-4 text-gray-800">App Settings & Layout</h3>
        <div class="mb-3">
          <label class="block text-sm font-medium text-gray-700 mb-1">App Name</label>
          <input id="appNameInput" class="mt-1 block w-full border-gray-300 rounded p-3" placeholder="My Business Tracker">
        </div>
        <div class="mb-3">
          <label class="block text-sm font-medium text-gray-700 mb-1">App Primary Color</label>
          <input id="appColorInput" type="color" class="mt-1 block w-full h-12 rounded border-2 app-color-border" value="#3b82f6">
        </div>
        <!-- APP LOGO + CATALOGUE SIDE BY SIDE -->
<div class="mb-3">
  <div class="flex items-start gap-6">

    <!-- LEFT: APP LOGO (UNCHANGED) -->
    <div class="flex-1">
      <!-- APP LOGO -->
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700 mb-1">App Logo</label>

        <div class="flex items-center gap-3">
          <!-- Choose File -->
          <input id="appLogoInput" type="file" accept="image/*" class="hidden">

          <!-- Custom Upload Icon Button -->
          <button type="button"
                  onclick="document.getElementById('appLogoInput').click()"
                  class="bg-gray-200 p-2 rounded border shadow">
            <i data-lucide="upload" class="w-5 h-5"></i>
          </button>

          <!-- Preview Image (UNTOUCHED) -->
          <img id="appLogoPreview"
               src=""
               alt="logo preview"
               class="h-12 w-12 object-contain rounded hidden border" />
        </div>

        <!-- Trash Icon Button BELOW -->
        <button id="removeLogoBtn"
                type="button"
                class="hidden bg-red-600 text-white p-2 rounded mt-2 w-fit">
          <i data-lucide="trash-2" class="w-4 h-4"></i>
        </button>

        <p class="text-xs text-gray-400 mt-1">
          Only JPG images.
        </p>
      </div>
    </div>

    <!-- RIGHT: CATALOGUE (PDF) â€“ UI REPLICA -->
    <div class="flex-1">
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700 mb-1">
          Catalogue (PDF)
        </label>

        <div class="flex items-center gap-3">
          <!-- Choose File -->
          <input id="cataloguePdfInput" type="file" accept="application/pdf" class="hidden">

          <!-- Custom Upload Icon Button -->
          <button type="button"
                  onclick="document.getElementById('cataloguePdfInput').click()"
                  class="bg-gray-200 p-2 rounded border shadow">
            <i data-lucide="upload" class="w-5 h-5"></i>
          </button>

          <!-- "Preview" box: behaves like the image spot -->
          <div id="cataloguePdfPreview"
               class="h-12 flex items-center px-2 rounded border bg-gray-50 text-xs text-gray-700 hidden">
            <!-- file name will be shown here -->
          </div>
        </div>

        <!-- Trash Icon Button BELOW -->
        <button id="removeCataloguePdfBtn"
                type="button"
                class="hidden bg-red-600 text-white p-2 rounded mt-2 w-fit">
          <i data-lucide="trash-2" class="w-4 h-4"></i>
        </button>

        <p class="text-xs text-gray-400 mt-1">
          Only PDF files.
        </p>
      </div>
    </div>

  </div>
</div>


<!-- QUOTATION LETTERHEAD -->
<div class="mb-3">
  <label class="block text-sm font-medium text-gray-700 mb-1">Quotation Background</label>

  <div class="flex items-center gap-3">
    <!-- Choose File -->
    <input id="quotationLetterheadInput" type="file" accept="image/*" class="hidden">

    <button type="button"
            onclick="document.getElementById('quotationLetterheadInput').click()"
            class="bg-gray-200 p-2 rounded border shadow">
      <i data-lucide="upload" class="w-5 h-5"></i>
    </button>

    <!-- Preview Image (UNTOUCHED) -->
    <img id="quotationLetterheadPreview"
         src=""
         alt="layout preview"
         class="h-12 object-contain rounded hidden border" />
  </div>

  <!-- Trash Icon Button BELOW -->
  <button id="removeQuotationLayoutBtn"
          type="button"
          class="hidden bg-red-600 text-white p-2 rounded mt-2 w-fit">
    <i data-lucide="trash-2" class="w-4 h-4"></i>
  </button>

  <p class="text-xs text-gray-400 mt-1">
    Only JPG images.
  </p>
</div>



<!-- INVOICE LETTERHEAD -->
<div class="mb-3">
  <label class="block text-sm font-medium text-gray-700 mb-1">Invoice Background</label>

  <div class="flex items-center gap-3">
    <!-- Choose File -->
    <input id="invoiceLetterheadInput" type="file" accept="image/*" class="hidden">

     <!-- Custom Upload Icon Button -->
    <button type="button"
            onclick="document.getElementById('invoiceLetterheadInput').click()"
            class="bg-gray-200 p-2 rounded border shadow">
      <i data-lucide="upload" class="w-5 h-5"></i>
    </button>

    <!-- Preview Image (UNTOUCHED) -->
    <img id="invoiceLetterheadPreview"
         src=""
         alt="layout preview"
         class="h-12 object-contain rounded hidden border" />
  </div>

  <!-- Trash Icon Button BELOW -->
  <button id="removeInvoiceLayoutBtn"
          type="button"
          class="hidden bg-red-600 text-white p-2 rounded mt-2 w-fit">
    <i data-lucide="trash-2" class="w-4 h-4"></i>
  </button>

  <p class="text-xs text-gray-400 mt-1">
    Only JPG images.
  </p>
</div>

        <div class="flex gap-2">
          <button id="saveSettingsBtn" type="button" class="w-full py-2 px-4 rounded text-white app-color-bg">Save Settings</button>
          <button id="resetSettingsBtn" type="button" class="w-full py-2 px-4 rounded border">Reset Defaults</button>
        </div>
        <p id="settings-message" class="text-center mt-3 text-sm text-green-600" style="visibility:hidden">Settings saved!</p>
      </div>
      <p class="text-xs text-gray-500 p-2 border-t mt-4">Note: final Android apps require manifest alias for logo changes.</p>
    </div>

    <!-- MAPS (unchanged core behavior) -->
    <div id="maps" class="screen-container translate-x-full">
      <h2 class="text-2xl font-semibold mb-0 app-color-text border-b pb-2">Distance & Price Estimator</h2>
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-4">
        <div id="map-display" class="w-full h-36 bg-gray-200 rounded-lg overflow-hidden border border-gray-300 relative flex items-center justify-center text-gray-500 text-sm font-medium">
          <i data-lucide="map-pin" class="w-8 h-8 app-color-text absolute top-3 left-3"></i>
          <i data-lucide="flag" class="w-8 h-8 text-red-500 absolute bottom-3 right-3"></i>
          <div class="absolute inset-0 flex items-center justify-center opacity-90" style="background-image:linear-gradient(135deg,#a7f3d0 25%,#d1d5db 25%,#d1d5db 50%,#a7f3d0 50%,#a7f3d0 75%,#d1d5db 75%,#d1d5db 100%);background-size:20px 20px;">
            <span id="route-text" class="px-3 py-1 bg-white/80 rounded-full shadow-lg font-bold text-sm app-color-text text-center"></span>
          </div>
        </div>
            <div id="map-time-distance"
     class="text-sm font-semibold app-color-text mt-2 text-center">
</div>
        <div class="grid grid-cols-2 gap-4">
          <div class="relative autocomplete-container col-span-2">
            <label class="block text-xs font-medium text-gray-700">Origin (A)</label>
            <input id="origin" class="mt-1 block w-full border-gray-300 rounded p-2 text-sm" placeholder="Start Location" autocomplete="off">
            <div id="originDropdown" class="absolute w-full bg-white border rounded-b-md shadow z-20 mt-1 max-h-40 overflow-y-auto hidden"></div>
          </div>
          <div class="relative autocomplete-container col-span-2">
            <label class="block text-xs font-medium text-gray-700">Destination (B)</label>
            <input id="destination" class="mt-1 block w-full border-gray-300 rounded p-2 text-sm" placeholder="End Location" autocomplete="off">
            <div id="destinationDropdown" class="fixed left-0 right-0 bg-white border rounded-b-md shadow z-50 mt-1 max-h-40 overflow-y-auto hidden"></div>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-xs font-medium text-gray-700">Rate per KM (â‚¹)</label>
            <input id="pricePerKm" type="number" step="1" value="0" class="mt-1 block w-full border-gray-300 rounded p-2 text-sm">
          </div>
          <div>
            <label class="block text-xs font-medium text-gray-700">Driver Charge (â‚¹)</label>
            <input id="baseCharges" type="number" step="500" value="0" class="mt-1 block w-full border-gray-300 rounded p-2 text-sm">
          </div>
          <div>
            <label class="block text-xs font-medium text-gray-700">Waiting Charge (â‚¹)</label>
            <input id="waitingCharges" type="number" step="200" value="0" class="mt-1 block w-full border-gray-300 rounded p-2 text-sm">
          </div>
          <div>
            <label class="block text-xs font-medium text-gray-700">Toll Charge (â‚¹)</label>
            <input id="tollCharges" type="number" step="50" value="0" class="mt-1 block w-full border-gray-300 rounded p-2 text-sm">
          </div>
        </div>
        <div class="flex items-center">
          <input id="isRoundTrip" type="checkbox" class="h-4 w-4 app-color-text border-gray-300 rounded">
          <label for="isRoundTrip" class="ml-2 text-sm text-gray-700">Round Trip (Double's Rate/KM & Toll)</label>
        </div>
        <div class="grid grid-cols-2 gap-4 mt-2">
          <button type="button" onclick="resetMapCalculator()" class="py-3 rounded-lg bg-gray-200">Reset</button>
          <button id="mapCalculateBtn" type="button" onclick="calculateDistancePrice()" class="py-3 rounded-lg text-white app-color-bg">Calculate Price</button>
        </div>
        <div id="map-confirm-row" class="mt-2 hidden flex gap-2">
  
          <button
            id="mapConfirmBtn"
            type="button"
            class="px-4 py-3 rounded-lg bg-green-600 text-white whitespace-nowrap"
            onclick="confirmMapPrice()"
          >
            OK â€” Use this price
          </button>

          <button
            type="button"
            class="px-4 py-3 rounded-lg bg-red-600 text-white whitespace-nowrap"
            onclick="cancelMapPrice()"
          >
            Cancel
          </button>

        </div>

        <div id="calculationResult" class="p-4 border-2 app-color-border rounded-lg bg-gray-50 text-sm">
          <div class="flex justify-between font-bold text-gray-700 border-b pb-1 mb-1"><span>Cost Breakdown</span><span>Amount</span></div>
          <div id="cost-breakdown"><p class="text-center text-gray-500 pt-2">Enter route details and click calculate.</p></div>
          <div id="total-result" class="flex justify-between font-extrabold text-lg pt-2 border-t mt-2"><span>TOTAL COST</span><span class="app-color-text">â‚¹0.00</span></div>
        </div>
      </div>
    </div>

    <!-- MASTER -->
        <div id="master" class="screen-container translate-x-full">
      <h2 class="text-2xl font-semibold mb-1 app-color-text border-b pb-2">Master Data Management</h2>

      <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
        <p class="text-gray-700 font-medium mb-3">Manage Event Names</p>
        <form id="masterEventForm" onsubmit="addMasterEvent(event)" class="flex gap-2">
          <input id="masterEventName" required class="flex-grow border-gray-300 rounded p-2" placeholder="e.g., Wedding">
          <button type="submit" class="py-2 px-4 rounded text-white app-color-bg">Add</button>
        </form>

        <div id="masterEventList" class="mt-4 p-3 bg-gray-50 rounded border max-h-32 overflow-y-auto"><p class="text-sm text-gray-500 text-center">No event names added yet.</p></div>
      </div>
      <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
        <p class="text-gray-700 font-medium mb-3">Manage Packages</p>
        <form id="masterPackageForm" onsubmit="addMasterPackage(event)">
          <div class="mb-2"><input id="masterPackageName" required class="w-full border-gray-300 rounded p-2" placeholder="Package name"></div>
          <div class="mb-2"><input id="masterPackagePrice" required type="number" step="100" class="w-full border-gray-300 rounded p-2" placeholder="Price"></div>
          <button type="submit" class="w-full py-2 rounded text-white app-color-bg">Add Package</button>
        </form>
        <div id="masterPackageList" class="mt-4 p-3 bg-gray-50 rounded border max-h-40 overflow-y-auto"><p class="text-sm text-gray-500 text-center">No packages added yet.</p></div>
      </div>
      <div class="bg-white p-6 rounded-xl shadow-lg">
        <p class="text-gray-700 font-medium mb-3">Manage AddOns</p>
        <form id="masterAddOnForm" onsubmit="addMasterAddOn(event)">
          <div class="mb-2"><input id="masterAddOnName" required class="w-full border-gray-300 rounded p-2" placeholder="AddOn name"></div>
          <div class="mb-2"><input id="masterAddOnPrice" required type="number" step="100" class="w-full border-gray-300 rounded p-2" placeholder="Price"></div>
          <button type="submit" class="w-full py-2 rounded text-white app-color-bg">Add AddOn</button>
        </form>

        <div id="masterAddOnList" class="mt-4 p-3 bg-gray-50 rounded border max-h-32 overflow-y-auto"><p class="text-sm text-gray-500 text-center">No addons added yet.</p></div>

<div class="master-map-defaults p-4 bg-white rounded-md shadow-sm mb-4">
  <h3 class="text-lg font-semibold mb-2">Default Map Settings</h3>
  <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
    <label class="flex flex-col">
      <span class="text-sm text-gray-600">Default Origin</span>
      <input id="masterDefaultOrigin" type="text" class="border rounded p-2 text-sm" placeholder="e.g. Mumbai, India" />
    </label>

    <label class="flex flex-col">
      <span class="text-sm text-gray-600">Rate per KM (â‚¹)</span>
      <input id="masterDefaultRatePerKm" type="number" step="1" class="border rounded p-2 text-sm" placeholder="0.50" />
    </label>
  </div>

  <div class="mt-3">
    <button class="px-3 py-2 rounded app-color-bg text-white" onclick="saveMasterMapDefaults()">Save Default Map Settings</button>
    <button class="px-3 py-2 rounded border ml-2" onclick="document.getElementById('masterDefaultOrigin').value = ''; document.getElementById('masterDefaultRatePerKm').value = 0;">Reset</button>
  </div>
</div>

      </div>
    </div>

    <!-- QUOTATION -->
    <div id="quotation" class="screen-container translate-x-full">
      <h2 class="text-2xl font-semibold mb-1 app-color-text border-b pb-2">New Quotation</h2>
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-5">
        <div class="p-3 border rounded">
          <h3 class="font-bold">Client Details</h3>
          <div class="grid grid-cols-2 gap-3 mt-2">
            <div>
              <label class="text-xs text-gray-700">Client Name</label>
              <input id="clientNameInput" class="mt-1 w-full border-gray-300 rounded p-2 text-sm" placeholder="Client name">
            </div>
            <div>
              <label class="text-xs text-gray-700">Client Contact</label>
              <input id="clientContactInput" class="mt-1 w-full border-gray-300 rounded p-2 text-sm" placeholder="Contact/email or phone">
            </div>
          </div>
        </div>

        <div class="p-3 border rounded">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-bold">Event(s) for this client</h3>
          </div>
          <div id="eventsContainer" class="space-y-3"></div>
        </div>

        <div class="flex justify-end">
          <button id="addEventBtn" type="button" class="text-blue-600 hover:underline text-sm">Add Event +</button>
        </div>

        <div class="summary-box" id="quotationSummaryBox">
          <div class="summary-row"><span>Actual Price</span><strong id="summaryActual">â‚¹0.00</strong></div>
          <div class="summary-row" style="align-items:center">
            <div>
              <div class="text-xs text-gray-600">Discount (â‚¹)</div>
              <input id="quotationDiscount" type="number" min="0" step="500" value="0" class="mt-1 block border-gray-300 rounded p-2 text-sm" style="width:140px">
            </div>
          </div>
          <div class="summary-row"><span>Final Price</span><strong id="summaryFinal">â‚¹0.00</strong></div>
        </div>

        <div>
          <button id="generateQuotationButton" type="button" class="w-full py-3 rounded-lg text-white app-color-bg">Generate/Save Quotation</button>
        </div>
      </div>
    </div>

    <!-- CALENDAR -->
    <div id="calendar" class="screen-container translate-x-full">
      <h2 class="text-2xl font-semibold mb-1 app-color-text border-b pb-2">Event Calendar</h2>
      <div class="bg-white p-0 rounded shadow w-auto">
        <div class="flex items-center justify-between mb-3 w-full">
    <!-- Left button group (horizontal) -->
    <div class="flex items-center space-x-2">
      <button onclick="changeMonth(-1)"
              class="bg-pink-200 inline-flex flex-none py-1 px-3 rounded border whitespace-nowrap">
        Prev
      </button>
    </div>

        <!-- Center title -->
    <div id="calendar-title"
         class="text-lg font-semibold text-center flex-1 px-3 whitespace-nowrap"></div>


    <!-- Right button group (horizontal) -->
    <div class="flex items-center space-x-2">
      <button onclick="changeMonth(1)"
              class="bg-pink-200 inline-flex flex-none py-1 px-3 rounded border whitespace-nowrap">
        Next
      </button>
	</div>
          </div>           
        </div>

        <div id="calendar-widget" class="min-h-[260px]"></div>

        <div class="calendar-legend mt-3 flex flex-row flex-wrap items-center gap-4">
  <div class="flex items-center gap-2">
    <div style="width:14px;height:14px;border-radius:4px;background:transparent;border:1px solid #e5e7eb"></div>
    <div>No Event</div>
  </div>

  <div class="flex items-center gap-2">
    <div style="width:14px;height:14px;border-radius:4px;background:#3b82f6"></div>
    <div>Enquiry</div>
  </div>

  <div class="flex items-center gap-2">
    <div style="width:14px;height:14px;border-radius:4px;background:#10b981"></div>
    <div>1 Booked</div>
  </div>

  <div class="flex items-center gap-2">
    <div style="width:14px;height:14px;border-radius:4px;background:#f59e0b"></div>
    <div>2 Booked</div>
  </div>

  <div class="flex items-center gap-2">
    <div style="width:14px;height:14px;border-radius:4px;background:#ef4444"></div>
    <div>3 Booked</div>
  </div>

  <div class="flex items-center gap-2">
    <div style="width:14px;height:14px;border-radius:4px;background:#000"></div>
    <div>>3 Booked</div>
  </div>
</div>

        <div id="calendar-help" class="text-xs text-gray-500 mt-3">
          Click a date to view quotations/events for that date. Book events from the popup.
        </div>
      </div>
    </div>

    <!-- INVOICE (kept functional, UI similar) -->
    <div id="invoice" class="screen-container translate-x-full">
      <h2 class="text-2xl font-semibold mb-1 app-color-text border-b pb-2">Invoice Generator</h2>
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-5">
        <div class="p-3 border rounded">
          <h3 class="font-bold">Client Details</h3>
          <div class="grid grid-cols-2 gap-3 mt-2">
            <div>
              <label class="text-xs text-gray-700">Client Name</label>
              <input id="invoiceClientNameInput" class="mt-1 w-full border-gray-300 rounded p-2 text-sm" placeholder="Client name">
            </div>
            <div>
              <label class="text-xs text-gray-700">Client Contact</label>
              <input id="invoiceClientContactInput" class="mt-1 w-full border-gray-300 rounded p-2 text-sm" placeholder="Contact/email">
            </div>
          </div>
        </div>
        <div class="p-3 border rounded">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-bold">Event(s) for this invoice</h3>
          </div>
          <div id="invoiceEventsContainer" class="space-y-3"></div>
        </div>
        <div class="flex justify-end">
          <button id="invoiceAddEventBtn" type="button" class="text-blue-600 hover:underline text-sm">Add Event +</button>
        </div>
        <div class="summary-box" id="invoiceSummaryBox">
          <div class="summary-row"><span>Actual Price</span><strong id="invoiceSummaryActual">â‚¹0.00</strong></div>
          <div class="summary-row" style="align-items:center">
            <div>
              <div class="text-xs text-gray-600">Discount (â‚¹)</div>
              <input id="invoiceDiscount" type="number" min="0" step="500" value="0" class="mt-1 block border-gray-300 rounded p-2 text-sm" style="width:140px">
            </div>
          </div>
          <div class="summary-row"><span>Final Price</span><strong id="invoiceSummaryFinal">â‚¹0.00</strong></div>
        </div>
        <div>
          <button id="generateInvoiceButton" type="button" class="w-full py-3 rounded-lg text-white app-color-bg">Save / Generate Invoice</button>
        </div>
      </div>
    </div>

<!-- FILES -->
<div id="files" class="screen-container translate-x-full">
  <h2 class="text-2xl font-semibold mb-1 app-color-text border-b pb-2">
    Files â€” Quotations & Invoices
  </h2>

  <div class="bg-white p-4 rounded-xl shadow-lg space-y-4">
    <!-- Tabs + search filters -->
    <div class="flex items-center justify-between mb-3">
  <div class="flex items-center gap-2">
    <div class="tab active" id="tab-quotations" onclick="switchFilesTab('quotations')">
      Quotations
    </div>
    <div class="tab" id="tab-invoices" onclick="switchFilesTab('invoices')">
      Invoices
    </div>
     <div class="tab" id="tab-payments" onclick="switchFilesTab('payments')" style="white-space: nowrap; font-size:0.8rem;">
      Payment Tracker
    </div>
  </div>
</div>

<!-- New line: toolbar below tabs -->
<div class="files-toolbar mb-3"
     style="display:flex; flex-direction:column; gap:0.5rem; width:100%; box-sizing:border-box;">

  <!-- ROW 1: Search + Date (NO WRAP between them) -->
  <div
    style="
      display:flex;
      flex-wrap:nowrap;
      gap:0.5rem;
      align-items:center;
      width:100%;
      box-sizing:border-box;
    "
  >
    <input
      id="filesSearch"
      placeholder="Search by client"
      class="border rounded p-2 text-sm"
      style="
        flex:1 1 auto;
        min-width:0;
        box-sizing:border-box;
      "
    />

    <input
      id="filesDate"
      type="text"
      placeholder="YYYY, MM-YYYY or DD-MM-YYYY"
      class="border rounded p-2 text-sm"
      style="
        flex:0 0 10rem;
        max-width:10rem;
        box-sizing:border-box;
      "
    />
  </div>

  <!-- ROW 2: Payment status dropdown (this can wrap / be on its own line) -->
  <div
    id="paymentStatusFilterWrapper"
    style="
      display:none;
      align-self:flex-end;
      box-sizing:border-box;
      max-width:100%;
    "
  >
    <label class="text-sm font-medium" style="margin-right:0.5rem;">
      Payment Status:
    </label>
    <select
      id="paymentStatusFilter"
      class="border rounded p-2 text-sm"
      style="width:9rem; box-sizing:border-box;"
    >
      <option value="all">All</option>
      <option value="pending">Pending</option>
      <option value="partial">Partial paid</option>
      <option value="completed">Completed</option>
    </select>
  </div>

</div>



<div id="filesContent">

      <!-- QUOTATIONS TAB -->
      <div id="quotationsTab">
        <!-- Bulk toolbar for quotations -->
        <div class="flex flex-wrap items-center gap-2 mb-2 text-sm">
          <label class="flex items-center gap-1">
            <input type="checkbox" id="quoteSelectAll" class="h-4 w-4">
            <span>All</span>
          </label>

          <select id="quoteBulkAction"
                  class="border rounded p-1 text-sm min-w-[100px]">
            <option value="">Choose action</option>
            <option value="download">Download</option>
            <option value="share">Share</option>
            <option value="edit">Edit</option> 
            <option value="generate_invoice">Bill-It</option>
          </select>

          <button id="quoteBulkOk"
                  class="py-1 px-3 rounded bg-gray-800 text-white text-sm">
            OK
          </button>

          <button id="quoteBulkDelete"
                  class="py-1 px-3 rounded bg-red-100 text-red-700 text-sm">
            Delete
          </button>
        </div>

        <div class="files-list" id="filesList"></div>
        <div id="filesEmpty"
             class="text-sm text-gray-500 text-center p-4 hidden">
          No files found.
        </div>
      </div>

      <!-- INVOICES TAB -->
      <div id="invoicesTab" class="hidden">
        <!-- Bulk toolbar for invoices -->
        <div class="flex flex-wrap items-center gap-2 mb-2 text-sm">
          <label class="flex items-center gap-1">
            <input type="checkbox" id="invoiceSelectAll" class="h-4 w-4">
            <span>All</span>
          </label>

          <select id="invoiceBulkAction"
                  class="border rounded p-1 text-sm min-w-[100px]">
            <option value="">Choose action</option>
            <option value="download">Download</option>
            <option value="edit">Edit</option> 
            <option value="share">Share</option>
          </select>

          <div class="inline-flex gap-2">
  <button id="invoiceBulkOk"
          class="py-1 px-3 rounded bg-gray-800 text-white text-sm">
    OK
  </button>
  <button id="invoiceBulkDelete"
          class="py-1 px-3 rounded bg-red-100 text-red-700 text-sm">
    Delete
  </button>
</div>
        </div>

        <div class="files-list" id="invoicesList"></div>
        <div id="invoicesEmpty"
             class="text-sm text-gray-500 text-center p-4 hidden">
          No invoices found.
        </div>
      </div>
       <!-- PAYMENTS TAB -->
      <div id="paymentsTab" class="hidden">
        
        <div class="files-list" id="paymentsList"></div>
        <div id="paymentsEmpty"
             class="text-sm text-gray-500 text-center p-4 hidden">
          No payment info found.
        </div>
      </div>
    </div>
  </div>
</div>
    
<!-- ================= REVENUE SCREEN ================= -->
<!-- ================= REVENUE SCREEN ================= -->
<div id="revenue" class="screen-container translate-x-full">
  <h2 class="text-xl font-bold mb-4">Revenue</h2>

  <div id="revenueContent" class="space-y-4">

    <!-- ðŸ” Filter bar -->
    <div class="flex flex-wrap items-center gap-3 mb-2">
      <label for="revenueFilterPreset" class="text-sm font-medium text-gray-700">
        Filter by:
      </label>

      <select
        id="revenueFilterPreset"
        class="border border-gray-300 rounded px-2 py-1 text-sm"
      >
        <option value="this_week">This week</option>
        <option value="last_week">Last week</option>
        <option value="this_month">This month</option>
        <option value="last_month">Last month</option>
        <option value="this_year">This year</option>
        <option value="last_year">Last year</option>
        <option value="range">Date range</option>
      </select>

      <!-- Date range inputs (enabled only when "Date range" is selected) -->
      <div class="flex items-center gap-2">
        <label for="revenueFromDate" class="text-xs text-gray-600">From</label>
        <input
          type="date"
          id="revenueFromDate"
          class="border border-gray-300 rounded px-2 py-1 text-xs"
          disabled
        />
        <label for="revenueToDate" class="text-xs text-gray-600">To</label>
        <input
          type="date"
          id="revenueToDate"
          class="border border-gray-300 rounded px-2 py-1 text-xs"
          disabled
        />
      </div>
    </div>

    <!-- ðŸ“Š Chart + Legend + Table -->
    <div class="flex flex-col lg:flex-row gap-4">

      <!-- Left: Pie chart + legend -->
      <div class="bg-white rounded-xl shadow p-4 flex-1 flex flex-col items-center">
        <div class="w-52 h-52 sm:w-64 sm:h-64">
          <canvas id="revenuePieCanvas" width="260" height="260"></canvas>
        </div>

        <!-- Legend with checkboxes -->
        <div id="revenueLegend" class="mt-4 w-full space-y-2 text-sm">
          <div class="font-semibold text-gray-700 mb-1">Legend</div>

<label class="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    class="revenueLegendChk h-4 w-4"
    data-key="enquiry"
    checked
  />
  <span class="inline-block w-3 h-3 rounded" style="background:#000000;"></span>
  <span>Enquiry - which are not booked</span>
</label>

<label class="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    class="revenueLegendChk h-4 w-4"
    data-key="booked"
    checked
  />
  <span class="inline-block w-3 h-3 rounded" style="background:#2563eb;"></span>
  <span>Booked - which are booked</span>
</label>

<hr class="my-2">

<label class="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    class="revenueLegendChk h-4 w-4"
    data-key="misc"
    
  />
  <span class="inline-block w-3 h-3 rounded" style="background:#a855f7;"></span>
  <span>Miscellaneous (Expenses)</span>
</label>

<label class="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    class="revenueLegendChk h-4 w-4"
    data-key="partial"
    
  />
  <span class="inline-block w-3 h-3 rounded" style="background:#ff9549;"></span>
  <span>Partial paid (Include Pending)</span>
</label>

<label class="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    class="revenueLegendChk h-4 w-4"
    data-key="actualPending"
  />
  <span class="inline-block w-3 h-3 rounded" style="background:#7b0000;"></span>
  <span>Actual Pending (All Pending Bills)</span>
</label>


<label class="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    class="revenueLegendChk h-4 w-4"
    data-key="paid"
    
  />
  <span class="inline-block w-3 h-3 rounded" style="background:#22c55e;"></span>
  <span>Paid - (Fully Paid)</span>
</label>

        </div>
      </div>

      <!-- Right: Dynamic table -->
      <div class="bg-white rounded-xl shadow p-4 flex-1">
        <div class="flex items-center justify-between mb-2 text-sm">
          <div class="font-semibold text-gray-700">Revenue breakdown</div>
          <div id="revenuePeriodLabel" class="text-xs text-gray-500"></div>
        </div>

        <div class="overflow-x-auto">
          <table class="min-w-full text-xs border border-gray-200">
            <thead class="bg-gray-50">
              <tr>
                <th class="border border-gray-200 px-2 py-1 text-left">Status</th>
                <th class="border border-gray-200 px-2 py-1 text-right"># Events</th>
                <th class="border border-gray-200 px-2 py-1 text-right">Amount (â‚¹)</th>
              </tr>
            </thead>
            <tbody id="revenueTableBody">
              <!-- Rows injected by JS -->
            </tbody>
            <tfoot class="bg-gray-50">
              <tr>
                <td class="border border-gray-200 px-2 py-1 font-semibold">Total</td>
                <td class="border border-gray-200 px-2 py-1 text-right font-semibold">â€“</td>
                <td
                  class="border border-gray-200 px-2 py-1 text-right font-semibold"
                  id="revenueTableTotal"
                >
                  â€“
                </td>
              </tr>
            </tfoot>
          </table>
        </div>

        <p
          id="revenueEmptyMessage"
          class="mt-2 text-[11px] text-gray-500"
        >
          Table reflects the same data shown in the pie chart for the selected date period.
        </p>
      </div>

    </div>
  </div>
</div>
<!-- END REVENUE SCREEN -->

<!-- RECYCLE BIN -->
<div id="recycle" class="screen-container translate-x-full">
  <h2 class="text-2xl font-semibold mb-1 app-color-text border-b pb-2">
    Recycle Bin
  </h2>

  <div class="bg-white p-4 rounded-xl shadow-lg space-y-4">
    <!-- Tabs -->
    <div class="flex items-center gap-2 mb-2">
      <div id="recycleTabUser"
           class="tab active"
           onclick="switchRecycleTab('user')">
        User Removed
      </div>
      <div id="recycleTabSystem"
           class="tab"
           onclick="switchRecycleTab('system')">
        System Removed
      </div>
    </div>

    <!-- User Removed tab content -->
    <div id="recycleUserTab">
      <!-- Filters row -->
      <div class="flex flex-wrap items-center gap-2 mb-3 text-sm">
        <select id="recycleUserType"
                class="border border-gray-300 rounded px-2 py-1">
          <option value="all">All</option>
          <option value="quotation">Quotation</option>
          <option value="invoice">Invoice</option>
          <option value="others">Others</option>
        </select>

        <input id="recycleUserName"
               type="text"
               class="border border-gray-300 rounded px-2 py-1 flex-1 min-w-[140px]"
               placeholder="Search by name" />

        <input id="recycleUserDate"
               type="text"
               class="border border-gray-300 rounded px-2 py-1 w-44"
               placeholder="Date (YYYY / MM-YYYY / DD-MM-YYYY)" />
      </div>

      <!-- Bulk actions row -->
      <div class="flex items-center justify-between mb-2 text-xs">
        <label class="flex items-center gap-2">
          <input id="recycleUserSelectAll"
                 type="checkbox"
                 class="w-4 h-4">
          <span>Select all</span>
        </label>

        <button id="recycleUserBulkDelete"
                type="button"
                class="px-3 py-1 rounded border bg-red-50 text-red-700 hover:bg-red-100">
          Delete selected
        </button>
      </div>

      <div id="recycleUserEmpty"
           class="text-sm text-gray-500 text-center p-4 hidden">
        No user-removed items yet.
      </div>

      <div id="recycleUserList" class="space-y-2 text-sm"></div>
    </div>

    <!-- System Removed tab content -->
    <div id="recycleSystemTab" class="hidden">
      <!-- Filters row -->
      <div class="flex flex-wrap items-center gap-2 mb-3 text-sm">
        <select id="recycleSystemType"
                class="border border-gray-300 rounded px-2 py-1">
          <option value="all">All</option>
          <option value="quotation">Quotation</option>
          <option value="invoice">Invoice</option>
          <option value="others">Others</option>
        </select>

        <input id="recycleSystemName"
               type="text"
               class="border border-gray-300 rounded px-2 py-1 flex-1 min-w-[140px]"
               placeholder="Search by name" />

        <input id="recycleSystemDate"
               type="text"
               class="border border-gray-300 rounded px-2 py-1 w-44"
               placeholder="Date (YYYY / MM-YYYY / DD-MM-YYYY)" />
      </div>

      <!-- Bulk actions row -->
      <div class="flex items-center justify-between mb-2 text-xs">
        <label class="flex items-center gap-2">
          <input id="recycleSystemSelectAll"
                 type="checkbox"
                 class="w-4 h-4">
          <span>Select all</span>
        </label>

        <button id="recycleSystemBulkDelete"
                type="button"
                class="px-3 py-1 rounded border bg-red-50 text-red-700 hover:bg-red-100">
          Delete selected
        </button>
      </div>

      <div id="recycleSystemEmpty"
           class="text-sm text-gray-500 text-center p-4 hidden">
        No system-removed items yet.
      </div>

      <div id="recycleSystemList" class="space-y-2 text-sm"></div>
    </div>
  </div>
</div>

    <!-- message modal (used by showMessage) -->
  <div id="messageModal" class="message-modal" style="z-index:999">
    <div class="message-modal-content">
      <h3 id="messageTitle" class="text-xl font-bold text-red-600 mb-3">Input Error</h3>
      <div
      id="messageBody"
      class="text-gray-700 mb-4 text-sm"
      style="white-space:normal; max-height:60vh; overflow-y:auto;"
    ></div>

            <div class="flex flex-wrap w-full" id="modalButtonRow">
        <!-- These are hidden by default and shown per-screen in JS -->

        <button
          id="messageDownloadBtn"
          type="button"
          class="hidden px-4 py-2 rounded bg-blue-600 text-white text-sm"
        >
          Download
        </button>

        <button
          id="messageShareBtn"
          type="button"
          class="hidden px-4 py-2 rounded bg-indigo-600 text-white text-sm"
        >
          Share
        </button>

        <button
          id="messageGenerateInvoiceBtn"
          type="button"
          class="hidden px-4 py-2 rounded bg-green-600 text-white text-sm"
        >
          Bill-It
        </button>

        <button
          id="messageEditBtn"
          type="button"
          class="hidden px-4 py-2 rounded bg-orange-500 text-white text-sm"
        >
          Edit
        </button>

        <button
          id="messagePaidBtn"
          type="button"
          class="hidden px-4 py-2 rounded bg-green-700 text-white text-sm"
        >
          Payment
        </button>

        <button
          id="messageCloseBtn"
          type="button"
          onclick="closeMessage()"
          class="px-4 py-2 rounded bg-red-600 text-white text-sm"
        >
          Close
        </button>
      </div>
    </div>
  </div>

   <!-- appConfirm modal (nice Yes/No instead of window.confirm) -->
  <div
    id="appConfirmModal"
    class="message-modal"
    style="z-index: 1000; display: none;"
  >
    <div class="message-modal-content">
      <h3 class="text-lg font-semibold mb-2">Please Confirm</h3>
      <p id="appConfirmMessage" class="text-sm text-gray-700 mb-4"></p>

      <div class="flex justify-end gap-2">
        <button
          type="button"
          id="appConfirmYes"
          class="px-3 py-1 rounded bg-green-700 text-white text-sm"
        >
          Yes
        </button>
        <button
          type="button"
          id="appConfirmNo"
          class="px-3 py-1 rounded bg-red-700 text-white text-sm"
        >
          No
        </button>
      </div>
    </div>
  </div>

    <!-- Payment Info modal -->
<div id="paymentInfoModal" class="message-modal" style="z-index:1000; display:none;">
  <div class="message-modal-content">
   <h3 id="paymentInfoHeadingMain" class="text-xl font-bold text-blue-600 mb-1 flex items-center gap-2">
  Payment Info
</h3>

<div id="paymentInfoHeadingSub" class="text-sm text-gray-600 mb-4"></div>

    <div class="space-y-3 text-sm">
      <!-- 0. Auto-capture text (read-only log) -->
      <div>
        <label class="block text-xs text-gray-700 mb-1">
          Partial Payment History (auto-capture)
        </label>
        <div class="text-xs text-gray-500 mb-2">
          If you want to correct this use a negative value in Partial Amount below.
        </div>
        <textarea
          id="paymentPartialLog"
          class="w-full border rounded p-2 bg-gray-100 text-xs"
          rows="4"
          readonly
          style="resize:vertical; max-height:120px; overflow-y:auto;"
        ></textarea>
      </div>

      <!-- Row 1: Billed Amount + Advance Paid -->
      <div class="grid grid-cols-2 gap-3">
        <!-- Billed Amount -->
        <div>
          <label class="block text-xs text-gray-700 mb-1">Billed Amount</label>
          <input
            id="paymentBilledAmount"
            type="number"
            class="w-full border rounded p-2 bg-gray-100"
            readonly
          />
        </div>

        <!-- Advance Paid -->
        <div>
          <label class="block text-xs text-gray-700 mb-1">Advance Paid</label>
          <input
            id="paymentAdvancePaid"
            type="number"
            step="1000"
            class="w-full border rounded p-2 bg-white"
            oninput="recalcPaymentPending()"
          />
        </div>
      </div>

      <!-- Row 2: Revised Amount + Partial Amount (button + input) -->
      <div class="grid grid-cols-2 gap-3">
        <!-- Revised Amount + checkbox -->
        <div>
          <div class="flex items-center justify-between mb-1">
            <label class="block text-xs text-gray-700">Revised Amount</label>
            <label class="flex items-center gap-1 text-xs text-gray-600">
              <input
                id="paymentRevisedEnable"
                type="checkbox"
                onchange="toggleRevisedAmount()"
              />
              Enable
            </label>
          </div>
          <input
            id="paymentRevisedAmount"
            type="number"
            step="1000"
            class="w-full border rounded p-2 bg-white"
            disabled
            oninput="recalcPaymentPending()"
          />
        </div>

        <!-- Partial Amount (Button + input) -->
        <div>
          <div class="flex items-center justify-between mb-1">
            <label class="block text-xs text-gray-700">Partial Amount</label>
            <button
              id="paymentPartialApplyBtn"
              type="button"
              onclick="handlePartialAmountApply()"
              class="px-2 py-1 rounded bg-blue-600 text-white text-[11px]"
            >
              Add
            </button>
          </div>
          <input
            id="paymentPartialValue"
            type="number"
            step="1000"
            class="w-full border rounded p-2 bg-white"
          />
        </div>
      </div>

      <!-- Row 3: Pending + Final Paid (both auto-calc) -->
      <div class="grid grid-cols-2 gap-3">
        <!-- Pending -->
        <div>
          <label class="block text-xs text-gray-700 mb-1">Pending</label>
          <input
            id="paymentPending"
            type="number"
            class="w-full border rounded p-2 bg-gray-100"
            readonly
          />
        </div>

        <!-- Final Paid (auto-calculated, read-only) -->
        <div>
          <label class="block text-xs text-gray-700 mb-1">Final Paid</label>
          <input
            id="paymentFinalPaid"
            type="number"
            class="w-full border rounded p-2 bg-gray-100"
            readonly
          />
        </div>
      </div>
    </div>
    <!-- Row: Misc + Profit -->
<div class="mt-3 grid grid-cols-2 gap-3">

  <!-- Miscellaneous -->
  <div>
    <label class="block text-sm font-medium text-gray-700 mb-1">
      Miscellaneous
    </label>
    <input
      id="paymentMiscAmount"
      type="number"
      step="100"
      class="w-full border rounded p-2 bg-white"
      placeholder="0"
      oninput="recalcProfit()"
    />
    <p class="text-[11px] text-gray-500 mt-1">
      Extra costs like fuel, tolls, misc payments. This wonâ€™t change Pending;
      it is only used in revenue calculations.
    </p>
  </div>

  <!-- Profit -->
  <div>
    <label class="block text-sm font-medium text-gray-700 mb-1">
      Profit
    </label>
    <input
      id="paymentProfit"
      type="number"
      class="w-full border rounded p-2 bg-gray-100"
       readonly
    />
  </div>

</div>

    <!-- BOTTOM BUTTONS (assuming you already changed Partial to Save) -->
    <div class="flex gap-2 justify-end mt-4">
      <button
        id="paymentSaveBtn"
        type="button"
        onclick="handlePaymentSave()"
        class="px-4 py-2 rounded bg-black text-white text-sm"
      >
        Save
      </button>

      <button
        id="paymentPaidFinalBtn"
        type="button"
        onclick="handlePaymentPaidFinal()"
        class="px-4 py-2 rounded bg-green-600 text-white text-sm disabled:opacity-50"
        disabled
      >
        Paid
      </button>

      <button
        type="button"
        onclick="closePaymentInfoModal()"
        class="px-4 py-2 rounded border bg-red-600 text-white text-sm"
      >
        Close
      </button>
    </div>
  </div>
</div>


  <!-- calendar popup container -->
  <div id="calendarPopupContainer" class="hidden"></div>

      <!-- === Floating Client Requests button === -->
    <div
      id="clientRequestsFab"
      class="client-req-fab"
      title="Client Requests"
    >
      <i data-lucide="mail" class="w-5 h-5"></i>
       <span id="clientReqBadge"
        class="absolute -top-1 -right-1 bg-red-600 text-white text-[12px] font-bold px-1.5 py-0.5 rounded-full hidden">
  </span>
    </div>

    <!-- === Client Requests popup panel === -->
    <div
      id="clientRequestsPanel"
      class="client-req-panel hidden"
    >
      <!-- Header -->
      <div class="flex items-center justify-between px-3 py-2 border-b border-gray-200 bg-slate-50">
        <div class="text-[12px] font-semibold text-gray-700">
          Client Requests
        </div>
        <div class="flex items-center gap-2">
          <button
            id="clientFormBtn"
            class="text-[11px] px-2 py-1 rounded-full border border-gray-200 bg-white hover:bg-blue-50"
          >
            Share Form
          </button>
          <button
            id="clientReqRefreshBtn"
            class="text-[11px] px-2 py-1 rounded-full border border-gray-200 bg-white hover:bg-gray-50"
          >
            Refresh
          </button>
          <button
            id="clientReqCloseBtn"
            class="text-gray-400 hover:text-gray-600"
          >
            <i data-lucide="x" class="w-4 h-4"></i>
          </button>
        </div>
      </div>

      <!-- List -->
      <div
        id="clientReqListContainer"
        class="p-2 overflow-y-auto text-xs bg-white"
        style="max-height: calc(70vh - 40px);"
      >
        <div
          id="clientReqEmpty"
          class="text-[11px] text-gray-400 text-center py-4"
        >
          No requests yet. Ask your client to submit the form.
        </div>
        <div id="clientReqList" class="space-y-2"></div>
      </div>
    </div>


</div>


<!-- Inserted settings-related script blocks from New.html -->
<script>

// ARCHIVE WebApp config - replace with your real values
const ARCHIVE_WEBAPP_URL = 'https://script.google.com/macros/s/AKfycbx4eMxlcbszBznqHvUuWa-slfdQjMiXxbYN4ip7GXh_rtvMmBVAspZ1VLB0l9uTijRwmw/exec';
const ARCHIVE_SECRET_TOKEN = 'd93KsL0pqA72nMx1FbZ82PpR91';


/* -------------------------
   Helpers & storage keys
   ------------------------- */

// === Client Requests central API ===
const CLIENT_REQ_API_URL =
  'https://script.google.com/macros/s/AKfycbzZNV1x5wkNn--28-xg0SbJgfAB-uTsNHausiUVhTkE6eibPJ-NN4rSj6IPoQrLPWeF6w/exec';
let CURRENT_CLIENT_REQ_CTX = null;
// Who owns these requests? (the signed-in user)
// âœ… Use Google email as the stable ownerId
function getClientReqOwnerId() {
  try {
    if (window.userProfile && userProfile.email) {
      const email = String(userProfile.email).trim().toLowerCase();
      // remember it so Share Form still works after reload
      try {
        localStorage.setItem('client_req_owner_email', email);
      } catch (e) {}
      return email;
    }

    // fallback: last stored email
    const stored = localStorage.getItem('client_req_owner_email');
    if (stored) {
      return stored.trim().toLowerCase();
    }
  } catch (e) {
    console.warn('getClientReqOwnerId failed', e);
  }

  return null; // will show "Please sign in first."
}


   

function createLucide(){ if(window.lucide && lucide.createIcons) try{ lucide.createIcons(); }catch(e){} }

function showMessage(msg, title = 'Notice') {
  const t = document.getElementById('messageTitle');
  const b = document.getElementById('messageBody');
  const m = document.getElementById('messageModal');

  // ---------------------------
  // ðŸ” RESET FOOTER BUTTONS
  // ---------------------------
  const downloadBtn  = document.getElementById('messageDownloadBtn');
  const shareBtn     = document.getElementById('messageShareBtn');
  const genInvBtn    = document.getElementById('messageGenerateInvoiceBtn');
  const editBtn      = document.getElementById('messageEditBtn');
  const paidBtn      = document.getElementById('messagePaidBtn');

  // Hide everything except Close
  [downloadBtn, shareBtn, genInvBtn, editBtn, paidBtn].forEach(btn => {
    if (btn) {
      btn.classList.add('hidden');
      btn.onclick = null; // clear previous action
    }
  });

  // ---------------------------
  // ðŸ” SET MESSAGE CONTENT
  // ---------------------------
  if (t) t.textContent = title;

  if (b) {
    if (typeof msg === 'string') {
      // HTML layouts (quotation / invoice / client request)
      b.style.whiteSpace = 'normal';
      b.style.fontFamily = '';
      b.innerHTML = msg;
    } else {
      // JSON / plain objects â€“ keep pretty formatting
      b.style.whiteSpace = 'pre-wrap';
      b.style.fontFamily = 'monospace';
      b.textContent = JSON.stringify(msg, null, 2);
    }
  }

  if (m) m.style.display = 'flex';
  createLucide();
}


function closeMessage(){
  const m = document.getElementById('messageModal');
  if (m) m.style.display = 'none';
}

let navHistory = [];
let currentScreen = 'dashboard';

function appConfirm(message) {
  return new Promise((resolve) => {
    const modal   = document.getElementById('appConfirmModal');
    const msgEl   = document.getElementById('appConfirmMessage');
    const yesBtn  = document.getElementById('appConfirmYes');
    const noBtn   = document.getElementById('appConfirmNo');

    // Fallback â€“ if modal not found, use normal confirm
    if (!modal || !msgEl || !yesBtn || !noBtn) {
      const fallback = window.confirm(message);
      resolve(fallback);
      return;
    }

    msgEl.innerHTML = message;
    modal.style.display = 'flex';

    const cleanup = (result) => {
      modal.style.display = 'none';
      yesBtn.onclick = null;
      noBtn.onclick  = null;
      resolve(result);
    };

    yesBtn.onclick = () => cleanup(true);
    noBtn.onclick  = () => cleanup(false);
  });
}


window.confirm = function (msg) {
  // Call appConfirm and block logic via async/await
  console.warn("window.confirm intercepted. Use appConfirm instead.");
  return false; // fallback if someone uses confirm synchronously
};

function navigate(id, opts = {}) {
  const screens = ['dashboard','settings','maps','master','quotation','calendar','invoice','files','recycle','revenue'];

  const pushHistory = (opts.pushHistory !== false);
  const skipInit    = (opts.skipInit === true);

 // NEW: adjust dashboard content based on sign-in state
  if (id === 'dashboard') {
    try { updateDashboardForSignIn(); } catch (e) {
      console.warn('updateDashboardForSignIn failed', e);
    }
  }

   // âœ… Show only the requested screen (this was missing)
  screens.forEach(s => {
    const el = document.getElementById(s);
    if (!el) return;
    el.style.transform = (s === id) ? 'translateX(0)' : 'translateX(100%)';
  });

  // History handling for back button
  if (pushHistory && currentScreen !== id) {
    navHistory.push(currentScreen);
  }
  currentScreen = id;

  // Back button visibility
  const backBtn = document.getElementById('backButton');
  if (backBtn) {
    const noHistory = navHistory.length === 0;
    backBtn.classList.toggle('opacity-0', noHistory);
    backBtn.classList.toggle('pointer-events-none', noHistory);
  }
  
  
  // Screen-specific initialisation (only if NOT skipping init)
  
  if (!skipInit) {
    if (id === 'master')    loadMasterData();
    if (id === 'maps') {
      applyDefaultMapValues();
      // initialize maps & autocomplete once when maps screen is first shown
      try { ensureMapsInitOnFirstShow(); } catch(e) { console.warn('Maps init failed', e); }
    }
    if (id === 'quotation') populateQuotationFields();
    if (id === 'invoice')   populateInvoiceFields();
    if (id === 'calendar')  renderCalendar();
    if (id === 'revenue')   initRevenueScreenFromPayments(); 
    if (id === 'files')     loadFilesUI();
    if (id === 'recycle')   loadRecycleUI();
    
  }

  createLucide();
}

function updateDashboardForSignIn() {
  let signedIn = false;
  try {
    signedIn = localStorage.getItem('gdrive_signed_in') === '1';
  } catch (e) {
    console.warn('Sign-in read failed:', e);
  }

  const signedInEl  = document.getElementById('dashboardSignedIn');
  const signedOutEl = document.getElementById('dashboardSignedOut');

  if (!signedInEl || !signedOutEl) return;

  if (signedIn) {
    signedInEl.classList.remove('hidden');
    signedOutEl.classList.add('hidden');
  } else {
    signedInEl.classList.add('hidden');
    signedOutEl.classList.remove('hidden');
  }
}


function formatINR(num) {
  if (num === null || num === undefined || num === '') return '';
  const n = parseFloat(num);
  if (isNaN(n)) return num;
  return 'â‚¹' + n.toLocaleString('en-IN', {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
}

// Helper to safely read numbers even if they have â‚¹ or commas
function parseINR(value) {
  if (value === null || value === undefined) return 0;
  const raw = String(value);
  const cleaned = raw.replace(/[^\d.-]/g, ''); // remove â‚¹, commas, spaces, etc
  const n = parseFloat(cleaned);
  return isNaN(n) ? 0 : n;
}

// Convert a data: URL (base64) into a File for Web Share
function dataURLToFile(dataUrl, filename) {
  const parts = dataUrl.split(',');
  if (parts.length < 2) throw new Error('Invalid data URL');

  const meta = parts[0];
  const base64 = parts[1];

  const mimeMatch = meta.match(/data:(.*?);base64/);
  const mime = mimeMatch ? mimeMatch[1] : 'application/pdf';

  const binary = atob(base64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }

  return new File([bytes], filename, { type: mime });
}

document.getElementById("clientFormBtn")?.addEventListener("click", async () => {
  const ownerId = getClientReqOwnerId();

  if (!ownerId) {
    showMessage(
      "Please sign in with Google first.\n\n" +
      "We use your Google email as the owner id so that client requests come only to you.",
      "Sign in required"
    );
    return;
  }

  const base = `${location.origin}/Makeovrs/client-form.html`;
  const link = `${base}?ownerId=${encodeURIComponent(ownerId)}`;

  // Ask: what do you want to share?
  const choiceHtml = `
    <div class="text-sm space-y-2">
      <p>What do you want to share?</p>
      <ul class="list-disc pl-5">
        <li><strong>Yes =</strong> Client Form link</li>
        <li><strong>No =</strong> Catalogue PDF</li>
      </ul>
    </div>
  `;

  const wantFormLink = await appConfirm(choiceHtml);

  // âœ… OPTION 1: only share the client form URL (no PDF)
  if (wantFormLink) {
    const shareText = `Please fill this form:\n${link}`;

    if (navigator.share) {
      try {
        // IMPORTANT: no `url:` here, only text â†’ avoids duplicate URLs on some mobiles
        await navigator.share({
          title: "Client Form",
          text: shareText
        });
      } catch (e) {
        console.warn("Share link failed", e);
      }
    } else {
      try {
        await navigator.clipboard.writeText(shareText);
        showMessage("Client form link copied!");
      } catch (e) {
        showMessage(shareText, "Client Form link");
      }
    }
    return;
  }

  // âœ… OPTION 2: share catalogue PDF + text containing the form link
  let catalogueFile = null;
  try {
    const catDataUrl = localStorage.getItem("catalogue_pdf_dataurl");
    const catName    = localStorage.getItem("catalogue_pdf_name") || "Catalogue.pdf";

    if (catDataUrl) {
      catalogueFile = dataURLToFile(catDataUrl, catName);
    }
  } catch (e) {
    console.warn("Failed to read catalogue from storage", e);
  }

  if (!catalogueFile) {
    showMessage(
      "No catalogue is saved yet. Please upload your catalogue PDF in Settings first.",
      "Catalogue not found"
    );
    return;
  }

  const catText =
    `Please check my catalogue.\n\n` +
    `If you wish to proceed, fill this form:\n${link}`;

  // Try Web Share with file + text
  if (
    navigator.canShare &&
    typeof navigator.canShare === "function" &&
    navigator.canShare({ files: [catalogueFile] })
  ) {
    try {
      // IMPORTANT: again, no `url:` to avoid duplicated link on mobile
      await navigator.share({
        title: "Catalogue",
        text: catText,
        files: [catalogueFile]
      });

      // Optional: also copy form link so you can paste manually if needed
      try {
        await navigator.clipboard.writeText(link);
        // you can comment this toast out if itâ€™s noisy
        // showMessage("Form link copied â€“ paste in WhatsApp if needed.", "Link copied");
      } catch (e) {
        console.warn("Clipboard copy failed", e);
      }

      return;
    } catch (e) {
      console.warn("Share with catalogue failed, falling back", e);
    }
  }

  // Fallback: cannot attach file â†’ give manual instructions
  const blobUrl = URL.createObjectURL(catalogueFile);
  showMessage(
    `
      <div class="space-y-2 text-sm">
        <p>Your browser cannot attach the PDF directly.</p>
        <p>
          1) Open this and share/download the catalogue:<br/>
          <a href="${blobUrl}" target="_blank" style="color:#2563eb;">Open catalogue PDF</a>
        </p>
        <p>
          2) Share this form link separately:<br/>
          ${link}
        </p>
      </div>
    `,
    "Share catalogue manually"
  );
});

function goBack() {
  if (navHistory.length === 0) {
    // If no history, go home
    return navigate('dashboard', { pushHistory: false });
  }
  const prev = navHistory.pop();
  navigate(prev, { pushHistory: false });
}

const APP_NAME_KEY='app_name', APP_COLOR_KEY='app_color', MASTER_EVENT_NAMES_KEY='master_event_names', MASTER_PACKAGES_KEY='master_packages', MASTER_ADDONS_KEY='master_addons', SAVED_QUOTATIONS_KEY='saved_quotations', SAVED_INVOICES_KEY='saved_invoices'; 

const RECYCLE_USER_KEY   = 'recycle_user_removed';
const RECYCLE_SYSTEM_KEY = 'recycle_system_removed';
const CLIENT_REQUEST_RETENTION_DAYS = 30;

let CURRENT_EDIT_QUOTATION_ID = null; 
let CURRENT_EDIT_INVOICE_ID   = null;

// Calendar booking â†’ payment flow context
window.CALENDAR_BOOKING_FLOW = null;

const APP_LOGO_KEY='app_logo_dataurl';
const QUOTATION_LAYOUT_KEY='quotation_layout_dataurl';
const INVOICE_LAYOUT_KEY='invoice_layout_dataurl';
const APP_FONT_KEY='app_font_size', BOOKED_EVENTS_KEY='booked_event_ids'; const MASTER_DEFAULT_ORIGIN_KEY = 'master_default_origin';
const MASTER_DEFAULT_RATE_KEY = 'master_default_rate';


function uid(prefix='id'){ return prefix + '_' + Date.now() + '_' + Math.floor(Math.random()*9000); }
function loadFromLS(k, fallback){ try{ const v = localStorage.getItem(k); if(!v) return fallback; return JSON.parse(v); }catch(e){ return fallback; } }
function saveToLS(k, v){ localStorage.setItem(k, JSON.stringify(v)); }

// Archive helper: archive a sheet row with ownerId check
// Archive helper: archive a sheet row with ownerId check
async function archiveSheetRow({ webappUrl, secretToken, rowIndex, ownerId }) {
  if (!webappUrl || !secretToken) {
    console.warn('archiveSheetRow: missing webappUrl or secretToken');
    return { ok:false, message:'missing config' };
  }
  if (!rowIndex || !ownerId) {
    console.warn('archiveSheetRow: missing rowIndex or ownerId', { rowIndex, ownerId });
    return { ok:false, message:'missing rowIndex or ownerId' };
  }

  let userConfirmed = false;
  try {
    if (typeof appConfirm === 'function') {
      userConfirmed = await appConfirm(
        'This will archive this request in Google Sheets (archive copy kept). Proceed?'
      );
    } else {
      userConfirmed = confirm(
        'This will archive this request in Google Sheets (archive copy kept). Proceed?'
      );
    }
  } catch (e) {
    console.warn('appConfirm failed, falling back to native confirm', e);
    userConfirmed = confirm(
      'This will archive this request in Google Sheets (archive copy kept). Proceed?'
    );
  }

  if (!userConfirmed) {
    return { ok:false, message:'cancelled' };
  }

  // Simple POST â†’ avoids preflight, but we use no-cors so response is opaque
  const form = new URLSearchParams();
  form.append('token',   String(secretToken));
  form.append('rowIndex', String(rowIndex));
  form.append('ownerId', String(ownerId));

  try {
    await fetch(webappUrl, {
      method: 'POST',
      mode: 'no-cors',
      body: form
    });

    console.log(
      'Archive request sent (no-cors). Response is opaque but server should have processed it.'
    );

    // Best-effort UI refresh
    try {
      if (typeof refreshClientRequestsUI === 'function') {
        refreshClientRequestsUI();
      } else if (typeof fetchAndRenderClientRequests === 'function') {
        fetchAndRenderClientRequests();
      } else if (typeof renderFilesList === 'function') {
        renderFilesList();
      }
    } catch (e) {
      console.warn('archive: UI refresh failed', e);
    }

    return { ok:true };
  } catch (err) {
    console.warn('Archive request network error', err);
    return { ok:false, message:String(err) };
  }
}
// === Auto-save to Google Drive (simple debounce) ===
let autoSaveDriveTimer = null;

function scheduleAutoSave(reason = '') {
  // Only try if Drive is signed in and saveToDrive exists
  if (!window.accessToken || typeof saveToDrive !== 'function') return;

  // Debounce: if many changes happen quickly, we save once after 1s
  clearTimeout(autoSaveDriveTimer);
  autoSaveDriveTimer = setTimeout(() => {
    console.log('Auto-saving to Drive because:', reason);
    // Uses your existing saveToDrive (shows same status + alerts)
    saveToDrive();
  }, 1000);
}

// Simple wrapper so the rest of the code can call autoSaveDrive()
function autoSaveDrive(reason = '') {
  scheduleAutoSave(reason || 'change');
}


/* -------------------------
   Ensure existing saved quotations have eventId for each event
   (migrator run once on load)
   ------------------------- */
function migrateEventIds(){
  const all = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  let changed = false;
  all.forEach(q=>{
    if(Array.isArray(q.events)){
      q.events.forEach(ev=>{
        if(!ev.eventId){ ev.eventId = uid('ev'); changed = true; }
      });
    } else {
      q.events = [];
      changed = true;
    }
  });
  if(changed) saveToLS(SAVED_QUOTATIONS_KEY, all);
}


/* -------------------------
   apply settings
   ------------------------- */
function applySettings(){
  let rawName = localStorage.getItem(APP_NAME_KEY);
  let rawColor = localStorage.getItem(APP_COLOR_KEY);
  const rawFont = localStorage.getItem(APP_FONT_KEY);

// --- FIXED NAME LOADING ---
  let name = 'My Business App';
  if (typeof rawName === 'string' && rawName.length) {
    try {
      const parsed = JSON.parse(rawName);
      if (typeof parsed === 'string') name = parsed;
      else name = rawName;
    } catch {
      name = rawName;
    }
  }

  // normalise color (leave this as it is)
  let color = '#3b82f6';
  if (typeof rawColor === 'string' && rawColor.length) {
    try {
      const parsed = JSON.parse(rawColor);
      if (typeof parsed === 'string') rawColor = parsed;
    } catch {}
    if (/^#([0-9a-fA-F]{6})$/.test(rawColor)) color = rawColor;
    else if (/^#([0-9a-fA-F]{3})$/.test(rawColor))
      color = '#' + rawColor.slice(1).split('').map(c=>c+c).join('');
  }

  const fontSize = (rawFont && /^\d+$/.test(rawFont)) ? rawFont : '16';

  // apply header title and settings input
  const titleEl = document.getElementById('app-title');
  if (titleEl) titleEl.textContent = name;

  const nameInput = document.getElementById('appNameInput');
  if (nameInput) nameInput.value = name;

  // apply CSS vars & font-size
  document.documentElement.style.setProperty('--app-color', color);
  document.documentElement.style.setProperty('font-size', fontSize + 'px');

  // set color input (type=color expects #rrggbb)
  const colorInput = document.getElementById('appColorInput');
  if (colorInput) {
    try { colorInput.value = color; } catch(e) { /* if browser rejects invalid value */ }
  }

  // auto-contrast: keep icons/text readable (white on dark, black on light)
  (function setContrast(){
    try {
      function hexToLuminance(hex) {
        const r = parseInt(hex.slice(1,3),16) / 255;
        const g = parseInt(hex.slice(3,5),16) / 255;
        const b = parseInt(hex.slice(5,7),16) / 255;
        const srgb = [r,g,b].map(c => c <= 0.03928 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4));
        return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
      }
      const lum = hexToLuminance(color);
      const contrast = lum > 0.5 ? '#111111' : '#ffffff';
      const header = document.querySelector('header');
      if (header) header.style.color = contrast;

      // ensure buttons/text remain readable
      document.querySelectorAll('.app-color-bg').forEach(el => el.style.color = contrast);
      document.documentElement.style.setProperty('--app-contrast-color', contrast);
    } catch(e) { console.warn('setContrast failed', e); }
  })();

  // logo + letterhead previews (unchanged behavior)
  const logoData = localStorage.getItem(APP_LOGO_KEY) || '';

if (logoData) {
  // Only update the preview + remove button in Settings
  const logoPreview = document.getElementById('appLogoPreview');
  const removeLogoBtn = document.getElementById('removeLogoBtn');

  if (logoPreview) {
    logoPreview.src = logoData;
    logoPreview.classList.remove('hidden');
  }
  if (removeLogoBtn) {
    removeLogoBtn.classList.remove('hidden');
  }
} else {
  // No logo saved â†’ hide preview + remove button
  document.getElementById('appLogoPreview')?.classList.add('hidden');
  document.getElementById('removeLogoBtn')?.classList.add('hidden');
}


  // quotation/invoice previews (keep existing logic)
  const qLayout = localStorage.getItem(QUOTATION_LAYOUT_KEY) || '';
  const invLayout = localStorage.getItem(INVOICE_LAYOUT_KEY) || '';

  const qPreview = document.getElementById('quotationLetterheadPreview');
  const removeQBtn = document.getElementById('removeQuotationLayoutBtn');
  if (qPreview) { if (qLayout) { qPreview.src = qLayout; qPreview.classList.remove('hidden'); if (removeQBtn) removeQBtn.classList.remove('hidden'); } else { qPreview.classList.add('hidden'); if (removeQBtn) removeQBtn.classList.add('hidden'); } }

  const iPreview = document.getElementById('invoiceLetterheadPreview');
  const removeIBtn = document.getElementById('removeInvoiceLayoutBtn');
  if (iPreview) { if (invLayout) { iPreview.src = invLayout; iPreview.classList.remove('hidden'); if (removeIBtn) removeIBtn.classList.remove('hidden'); } else { iPreview.classList.add('hidden'); if (removeIBtn) removeIBtn.classList.add('hidden'); } }
  
  const storedCatName = localStorage.getItem("catalogue_pdf_name");
if (storedCatName) {
  const preview = document.getElementById("cataloguePdfPreview");
  const removeBtn = document.getElementById("removeCataloguePdfBtn");
  if (preview) {
    preview.textContent = storedCatName;
    preview.classList.remove("hidden");
  }
  if (removeBtn) {
    removeBtn.classList.remove("hidden");
  }
}
  createLucide();
}

/* -------------------------
   Master data (same functionality)
   ------------------------- */
let masterEventNames = [], masterPackages = [], masterAddOns = [];
function loadMasterData(){
  masterEventNames = loadFromLS(MASTER_EVENT_NAMES_KEY, []) || [];
  masterPackages   = loadFromLS(MASTER_PACKAGES_KEY, []) || [];
  masterAddOns     = loadFromLS(MASTER_ADDONS_KEY, []) || [];

  // Render lists and refresh dependent UI
  renderMasterEventList();
  renderMasterPackageList();
  renderMasterAddOnList();
  refreshPanelsMasterData();

  // Load saved defaults for map (robust against old/new storage formats)
  const originInput = document.getElementById('masterDefaultOrigin');
  const rateInput   = document.getElementById('masterDefaultRatePerKm');

  if (originInput) {
    let origin = '';
    try {
      const raw = localStorage.getItem(MASTER_DEFAULT_ORIGIN_KEY);
      if (raw != null && raw !== '') {
        try {
          // values saved with saveToLS -> JSON string
          origin = JSON.parse(raw);
        } catch {
          // values saved as plain string
          origin = raw;
        }
      }
    } catch (e) {
      origin = '';
    }
    originInput.value = origin || '';
  }
  if (rateInput) {
    let rateVal = 0;
    try {
      const raw = localStorage.getItem(MASTER_DEFAULT_RATE_KEY);
      if (raw != null && raw !== '') {
        let parsed;
        try {
          parsed = JSON.parse(raw);
        } catch {
          parsed = raw;
        }
        const num = parseFloat(parsed);
        rateVal = isNaN(num) ? 0 : num;
      }
    } catch (e) {
      rateVal = 0;
    }
    rateInput.value = rateVal;
  }
}


function applyDefaultMapValues() {
  // Read defaults in a safe way (handles JSON or plain string)
  let origin = '';
  try {
    const raw = localStorage.getItem(MASTER_DEFAULT_ORIGIN_KEY);
    if (raw != null && raw !== '') {
      try {
        origin = JSON.parse(raw);
      } catch {
        origin = raw;
      }
    }
  } catch (e) {
    origin = '';
  }

  let rate = 0;
  try {
    const rawRate = localStorage.getItem(MASTER_DEFAULT_RATE_KEY);
    if (rawRate != null && rawRate !== '') {
      let parsed;
      try {
        parsed = JSON.parse(rawRate);
      } catch {
        parsed = rawRate;
      }
      const num = parseFloat(parsed);
      rate = isNaN(num) ? 0 : num;
    }
  } catch (e) {
    rate = 0;
  }

  // Set default Origin (editable by user)
  const originEl = document.getElementById('origin');
  if (originEl) originEl.value = origin || '';

  // Set default Rate (editable too)
  const rateEl = document.getElementById('pricePerKm');
  if (rateEl) rateEl.value = rate || 0;
}


function saveMasterEvents(){ saveToLS(MASTER_EVENT_NAMES_KEY, masterEventNames); }
function saveMasterPackages(){ saveToLS(MASTER_PACKAGES_KEY, masterPackages); }
function saveMasterAddOns(){ saveToLS(MASTER_ADDONS_KEY, masterAddOns); }

function saveMasterMapDefaults() {
  const origin = document.getElementById('masterDefaultOrigin')?.value?.trim() || '';
  const rate = parseFloat(document.getElementById('masterDefaultRatePerKm')?.value || 0);

  saveToLS(MASTER_DEFAULT_ORIGIN_KEY, origin);
  saveToLS(MASTER_DEFAULT_RATE_KEY, isNaN(rate) ? 0 : rate);

  showMessage("Default map settings saved!", "Saved");
}


function addMasterEvent(e){ e.preventDefault(); const v=document.getElementById('masterEventName')?.value?.trim(); if(!v) return showMessage('Enter a valid event name.'); if(masterEventNames.includes(v)) return showMessage('Event already exists.'); masterEventNames.push(v); saveMasterEvents(); document.getElementById('masterEventName').value=''; renderMasterEventList(); refreshPanelsMasterData(); }
function addMasterPackage(e){ e.preventDefault(); const n=document.getElementById('masterPackageName')?.value?.trim(); const p=parseFloat(document.getElementById('masterPackagePrice')?.value); if(!n||isNaN(p)||p<0) return showMessage('Fill valid name & price.'); masterPackages.push({id:Date.now(), name:n, price:p}); saveMasterPackages(); document.getElementById('masterPackageForm').reset(); renderMasterPackageList(); refreshPanelsMasterData(); }
function addMasterAddOn(e){ e.preventDefault(); const n=document.getElementById('masterAddOnName')?.value?.trim(); const p=parseFloat(document.getElementById('masterAddOnPrice')?.value); if(!n||isNaN(p)||p<0) return showMessage('Fill valid name & price.'); masterAddOns.push({id:Date.now(), name:n, price:p}); saveMasterAddOns(); document.getElementById('masterAddOnForm').reset(); renderMasterAddOnList(); refreshPanelsMasterData(); }

function renderMasterEventList(){ const el=document.getElementById('masterEventList'); if(!el) return; el.innerHTML = masterEventNames.length===0?'<p class="text-sm text-gray-500 text-center p-2">No event names added yet.</p>': masterEventNames.map(n=>`<div class="flex justify-between items-center p-2 border-b bg-white rounded-md"><p class="font-semibold app-color-text">${n}</p><button onclick="deleteMasterEvent(${JSON.stringify(n)})" class="text-red-500 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button></div>`).join(''); createLucide(); }
function renderMasterPackageList(){ const el=document.getElementById('masterPackageList'); if(!el) return; el.innerHTML = masterPackages.length===0?'<p class="text-sm text-gray-500 text-center p-2">No packages added yet.</p>': masterPackages.map(p=>`<div class="flex justify-between items-center p-3 border-b bg-white"><div><p class="font-semibold app-color-text">${p.name}</p></div><div class="flex items-center"><p class="font-bold text-green-600 mr-2">â‚¹${p.price}</p><button onclick="deleteMasterPackage(${p.id})" class="text-red-500 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button></div></div>`).join(''); createLucide(); }
function renderMasterAddOnList(){ const el=document.getElementById('masterAddOnList'); if(!el) return; el.innerHTML = masterAddOns.length===0?'<p class="text-sm text-gray-500 text-center p-2">No addons added yet.</p>': masterAddOns.map(a=>`<div class="flex justify-between items-center p-3 border-b bg-white"><div><p class="font-semibold app-color-text">${a.name}</p></div><div class="flex items-center"><p class="font-bold text-green-600 mr-2">â‚¹${a.price}</p><button onclick="deleteMasterAddOn(${a.id})" class="text-red-500 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button></div></div>`).join(''); createLucide(); }
function deleteMasterEvent(name){ masterEventNames = masterEventNames.filter(x=>x!==name); saveMasterEvents(); renderMasterEventList(); refreshPanelsMasterData(); }
function deleteMasterPackage(id){ masterPackages = masterPackages.filter(x=>x.id!==id); saveMasterPackages(); renderMasterPackageList(); refreshPanelsMasterData(); }
function deleteMasterAddOn(id){ masterAddOns = masterAddOns.filter(x=>x.id!==id); saveMasterAddOns(); renderMasterAddOnList(); refreshPanelsMasterData(); }

/* refresh UI selects inside event panels */
function refreshPanelsMasterData(){
  const panels = document.querySelectorAll('#eventsContainer .event-panel, #invoiceEventsContainer .event-panel');
  panels.forEach(panel=>{
    const nameSel = panel.querySelector('.event-eventNameMaster');
    if(nameSel){
      nameSel.innerHTML = '<option value="">-- Select Master Event --</option>';
      masterEventNames.forEach(n => { const opt = document.createElement('option'); opt.value = n; opt.textContent = n; nameSel.appendChild(opt); });
    }
    const pkgSel = panel.querySelector('.event-packageMaster');
    if(pkgSel){
      pkgSel.innerHTML = '<option value="">-- Select Package --</option>';
      masterPackages.forEach(p => { const opt = document.createElement('option'); opt.value = p.id; opt.textContent = `${p.name} â€” â‚¹${p.price}`; opt.dataset.price = p.price; pkgSel.appendChild(opt); });
    }
    const masterContainer = panel.querySelector('.event-addon-master');
    if(masterContainer){
      masterContainer.innerHTML = '';
      if(masterAddOns.length===0) masterContainer.innerHTML = '<p class="text-sm text-gray-500 p-2">No add-ons in master.</p>';
      else masterAddOns.forEach(a=>{ const row = document.createElement('div'); row.className='flex items-center justify-between p-1'; row.innerHTML = `<label class="flex items-center gap-2"><input type="checkbox" data-price="${a.price}" data-name="${a.name}" class="panel-addon-checkbox"> <span class="text-sm">${a.name}</span></label><span class="text-sm font-bold text-green-600">â‚¹${a.price}</span>`; masterContainer.appendChild(row); });
    }
  });
}

/* -------------------------
   Calendar data index & dedupe
   ------------------------- */
/* Deduplicate quotations by clientName + clientContact (keep latest) */
function dedupeQuotationsByClient(){
  const all = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const map = {};
  all.forEach(q=>{
    const name = (q.clientName||'').trim();
    const contact = (q.clientContact||'').trim();
    if(!name) return;
    const key = `${name.toLowerCase()}||${contact.toLowerCase()}`;
    if(!map[key]) map[key] = q;
    else {
      const prev = new Date(map[key].createdAt || 0);
      const cur = new Date(q.createdAt || 0);
      if(cur > prev) map[key] = q;
    }
  });
  return Object.values(map);
}

/* Build date => events index for calendar display.
   Ensure all events have eventId (migrated earlier). */
function buildCalendarEventIndex(){
  const result = {};
  const deduped = dedupeQuotationsByClient();
  const bookedMap = loadFromLS(BOOKED_EVENTS_KEY, {});
  deduped.forEach(q=>{
    (q.events || []).forEach(ev=>{
      // ensure eventId exists (safety)
      if(!ev.eventId){ ev.eventId = uid('ev'); } // not persisted here (persist elsewhere when discovered)
      const dateISO = ev.date;
      if(!dateISO) return;
      if(!result[dateISO]) result[dateISO] = [];
      result[dateISO].push({
        eventId: ev.eventId,
        quotationId: q.id,
        clientName: q.clientName,
        clientContact: q.clientContact,
        date: ev.date,
        eventName: ev.name || '',
        time: ev.time || '',
        location: ev.location || '',
        packagePrice: ev.packagePrice || 0,
        addOnPrice: ev.addOnPrice || 0,
        transportPrice: ev.transportPrice || 0,
        notes: ev.notes || '',
        booked: Boolean(bookedMap[ev.eventId])
      });
    });
  });
  return result;
}

// === DASHBOARD: Upcoming Events Notepad ===
function updateDashboardUpcomingEvents() {
  const box = document.getElementById('dashboardUpcomingList');
  if (!box) return;

  const index = buildCalendarEventIndex();

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const DAY_MS = 1000 * 60 * 60 * 24;

  // Group booked events by date (YYYY-MM-DD) for today + next 15 days
  const grouped = {};

  Object.keys(index).forEach(dateISO => {
    const events = index[dateISO] || [];
    events.forEach(ev => {
      if (!ev.booked) return; // only booked events

      const d = new Date(ev.date || dateISO);
      if (isNaN(d.getTime())) return;
      d.setHours(0, 0, 0, 0);

      const diffDays = Math.floor((d - today) / DAY_MS);
      // keep only today (0) to next 15 days (15)
      if (diffDays < 0 || diffDays > 15) return;

      const yyyy = d.getFullYear();
      const mm   = String(d.getMonth() + 1).padStart(2, '0');
      const dd   = String(d.getDate()).padStart(2, '0');
      const key  = `${yyyy}-${mm}-${dd}`; // YYYY-MM-DD in *local* time

      if (!grouped[key]) grouped[key] = [];
      grouped[key].push({
        ...ev,
        dateObj: d
      });
    });
  });

  // Sort the dates that actually have events
  const sortedDates = Object.keys(grouped).sort();
  // Show up to 4 upcoming dates with events
  const datesToShow = sortedDates.slice(0, 4);

  if (!datesToShow.length) {
    box.innerHTML =
      `<div class="text-xs text-gray-400 italic">No booked events in the next 15 days.</div>`;
    return;
  }

  // Grid with up to 4 columns; if fewer dates, you'll see fewer cards
  let html = `
    <div class="grid grid-cols-4 gap-3">
  `;

  datesToShow.forEach(key => {
    const d = grouped[key][0].dateObj;
    const dateStr = d.toLocaleDateString('en-IN', {
      day: '2-digit',
      month: 'short',
      year: '2-digit'
    });

    const eventsForDay = grouped[key].slice().sort((a, b) => {
      const ta = a.time || '';
      const tb = b.time || '';
      return ta.localeCompare(tb);
    });

    let eventsHtml = '';

    eventsForDay.forEach((ev, i) => {
      const name = ev.clientName || '--';

      const rawLoc = ev.location || '';
      const trimmed = rawLoc.trim();
      const firstWord = trimmed ? trimmed.split(/\s+/)[0] : '';

      const time = ev.time || '';

      // Decide what to show on line 2
      let secondLine = '';
      if (firstWord && time) {
        secondLine = `${firstWord} (${time})`;
      } else if (firstWord) {
        secondLine = firstWord;
      } else if (time) {
        secondLine = time;
      } else {
        // both location & time empty
        secondLine = 'Empty(no loc &time)';
      }

      eventsHtml += `
        <div class="mb-1">
          <!-- S.no + name always in one line, full width, left-aligned -->
          <div class="flex items-center text-[11px] text-gray-700">
            <span class="shrink-0 mr-1">${i + 1}.</span>
            <span class="truncate">${name}</span>
          </div>
          <div class="text-[10px] text-gray-500">
            ${secondLine}
          </div>
          <!-- Separator line -->
      <div class="border-b border-black mt-1"></div>
        </div>
      `;
    });

    html += `
  <div class="bg-white border border-gray-200 rounded px-1 py-2 shadow-sm">

    <!-- Blue date badge -->
    <div class="flex justify-center mb-2">
  <div class="bg-blue-600 text-white text-[11px] font-semibold px-3 py-[3px] rounded-full whitespace-nowrap w-fit">
    ${dateStr}
  </div>
</div>

    <div class="space-y-1 leading-tight">
      ${eventsHtml}
    </div>
  </div>
    `;
  });

  html += `</div>`;
  box.innerHTML = html;
}




/* Persist eventId for any events missing one in saved quotations (migration)
   This writes back to storage so future load is consistent. */
function persistMissingEventIds(){
  const all = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  let changed = false;
  all.forEach(q=>{
    if(Array.isArray(q.events)) q.events.forEach(ev=>{
      if(!ev.eventId){ ev.eventId = uid('ev'); changed = true; }
    });
  });
  if(changed) saveToLS(SAVED_QUOTATIONS_KEY, all);
}

/* -------------------------
   Booking helpers
   ------------------------- */
function setQuotationBookings(quotationId, booked=true){
  const bookings = loadFromLS(BOOKED_EVENTS_KEY, {});
  const all = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const q = all.find(x=>x.id === quotationId);
  if(!q) return;
  (q.events || []).forEach(ev=>{ if(ev.eventId){ if(booked) bookings[ev.eventId] = true; else delete bookings[ev.eventId]; }});
  saveToLS(BOOKED_EVENTS_KEY, bookings);

  try { updateDashboardUpcomingEvents(); } catch(e) {}

  // NEW: auto-save this change to Drive
  scheduleAutoSave('calendar quotation booking change');
}
function setSingleEventBooking(eventId, booked=true){
  const bookings = loadFromLS(BOOKED_EVENTS_KEY, {});
  if(booked) bookings[eventId] = true; else delete bookings[eventId];
  saveToLS(BOOKED_EVENTS_KEY, bookings);

  // NEW: auto-save this change to Drive
  scheduleAutoSave('calendar single event booking change');
}

// Prepare invoice totals from a quotation and seed CURRENT_VIEWED_INVOICE,
// without actually saving a real invoice yet.
function prepareInvoicePreviewFromQuotation(quotationId) {
  const quotations = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const q = quotations.find(x => x.id === quotationId);
  if (!q) return null;

  const events = Array.isArray(q.events) ? q.events : [];

  // Try to reuse totals from quotation; fallback to compute
  let actual = (typeof q.actual === 'number') ? q.actual : 0;
  if (!actual) {
    actual = events.reduce((sum, ev) => {
      return sum +
        Number(ev.packagePrice   || 0) +
        Number(ev.addOnPrice     || 0) +
        Number(ev.transportPrice || 0);
    }, 0);
  }

  const discount = (typeof q.discount === 'number') ? q.discount : 0;
  const final = (typeof q.final === 'number')
    ? q.final
    : Math.max(0, actual - discount);

  // Seed CURRENT_VIEWED_INVOICE so Payment Info modal knows the billed amount
  window.CURRENT_VIEWED_INVOICE = {
    id: q.id,
    actual,
    discount,
    final,
    invoice: null,
    quotationId: q.id,
    clientName: q.clientName,
    clientContact: q.clientContact
  };

  return { quotation: q, actual, discount, final };
}

/* Generate invoice from a quotation (used by calendar booking) */
async function generateInvoiceFromQuotationForCalendar(quotationId) {
  const preview = prepareInvoicePreviewFromQuotation(quotationId);
  if (!preview) {
    alert('Quotation not found for generating invoice.');
    return null;
  }

  const { quotation: q, actual, discount, final } = preview;

  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);

  const newInvoice = {
    ...q,
    invoiceId: 'inv_' + Date.now(),
    createdAt: new Date().toISOString(),
    actual,
    discount,
    final
  };

  invoices.push(newInvoice);
  saveToLS(SAVED_INVOICES_KEY, invoices);

  // store current invoice context for Payment Info
  window.CURRENT_VIEWED_INVOICE = {
    id: newInvoice.invoiceId || newInvoice.id,
    actual,
    discount,
    final,
    invoice: newInvoice
  };

  // Auto-save to Drive if available
  if (typeof autoSaveDrive === 'function') {
    autoSaveDrive('invoice generated from calendar booking');
  }

  return newInvoice;
}


/* -------------------------
   Contact helpers
   ------------------------- */

function openContactOptions(rawContact) {
  const raw = (rawContact || "").trim();
  if (!raw) {
    showMessage("No contact number found for this client.");
    return;
  }

  // Strip everything except digits and +
  const cleaned = raw.replace(/[^\d+]/g, "");

  // For tel/sms we can use cleaned as-is (browser/OS handles it)
  const telNumber = cleaned || raw;

  // For WhatsApp we need only digits and preferably with country code
  let waDigits = cleaned.replace(/[^\d]/g, "");

  // If it looks like 10-digit Indian mobile, auto-add +91
  if (waDigits.length === 10) {
    waDigits = "91" + waDigits;
  }

  if (!waDigits) {
    showMessage("Contact number looks invalid: " + raw);
    return;
  }

  // Remove any previous chooser
  const existing = document.getElementById("contactChooser");
  if (existing) existing.remove();

  // Build a tiny chooser popup
  const box = document.createElement("div");
  box.id = "contactChooser";
  box.style.position = "fixed";
  box.style.left = "50%";
  box.style.bottom = "80px";
  box.style.transform = "translateX(-50%)";
  box.style.background = "#ffffff";
  box.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
  box.style.padding = "10px 12px";
  box.style.borderRadius = "12px";
  box.style.zIndex = "99999";
  box.style.minWidth = "230px";
  box.style.fontSize = "13px";

  box.innerHTML = `
    <div style="margin-bottom:8px;">
      Contact <b>${raw}</b>
    </div>
    <div style="display:flex; flex-direction:column; gap:6px;">
      <button type="button"
              data-action="wa"
              style="padding:6px 8px; border-radius:8px; border:1px solid #e5e7eb; text-align:left;">
        WhatsApp / WhatsApp Business
      </button>
      <button type="button"
              data-action="sms"
              style="padding:6px 8px; border-radius:8px; border:1px solid #e5e7eb; text-align:left;">
        Message / SMS
      </button>
      <button type="button"
              data-action="call"
              style="padding:6px 8px; border-radius:8px; border:1px solid #e5e7eb; text-align:left;">
        Phone Call
      </button>
      <button type="button"
              data-action="close"
              style="padding:6px 8px; border-radius:8px; border:1px solid #f3f4f6;
                     background:#f9fafb; text-align:center; margin-top:2px;">
        Cancel
      </button>
    </div>
  `;

  document.body.appendChild(box);

  box.querySelectorAll("button[data-action]").forEach(btn => {
    btn.addEventListener("click", () => {
      const action = btn.dataset.action;

      if (action === "wa") {
        // Opens WhatsApp; if both WhatsApp + Business installed,
        // Android will ask which one.
        window.location.href = "https://wa.me/" + waDigits;
      } else if (action === "sms") {
        // Opens SMS app with this number
        window.location.href = "sms:" + telNumber;
      } else if (action === "call") {
        // Opens dialer with this number
        window.location.href = "tel:" + telNumber;
      }

      // Close chooser for all actions (including cancel)
      box.remove();
    });
  });
}


/* -------------------------
   Calendar rendering
   ------------------------- */
let curYear = new Date().getFullYear(), curMonth = new Date().getMonth();

function renderCalendar(y=curYear, m=curMonth){
  curYear = y; curMonth = m;
  const now = new Date();
  const firstDay0 = new Date(y,m,1).getDay(); // 0=Sun
  const firstDay = (firstDay0 + 6) % 7; // Monday-first
  const daysInMonth = new Date(y,m+1,0).getDate();
  const title = document.getElementById('calendar-title'); if(title) title.textContent = `${['January','February','March','April','May','June','July','August','September','October','November','December'][m]} ${y}`;
  const idx = buildCalendarEventIndex();

  // Build weekday header + grid
  let html = `<div class="calendar-weekdays"><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div><div>Sun</div></div>`;
  html += `<div class="grid grid-cols-7 gap-2">`;
  // blank placeholders
  for(let i=0;i<firstDay;i++) html += `<div class="calendar-cell"></div>`;
  for(let d=1; d<=daysInMonth; d++){
    const dateISO = `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
    const eventsOnDay = idx[dateISO] || [];

    const bookedCount = eventsOnDay.filter(e=>e.booked).length;
    let bgColor = 'transparent';
  let circleClass = '';
  if (eventsOnDay.length === 0) {
    bgColor = 'transparent';
    circleClass = '';
  } else if (bookedCount === 0 && eventsOnDay.length > 0) {
    bgColor = '#3b82f6';
    circleClass = 'colored'; // Enquiry -> Blue
  } else {
    if (bookedCount === 1) { bgColor = '#10b981'; circleClass = 'colored'; }
    else if (bookedCount === 2) { bgColor = '#f59e0b'; circleClass = 'colored'; }
    else if (bookedCount === 3) { bgColor = '#ef4444'; circleClass = 'colored'; }
    else if (bookedCount > 3) { bgColor = '#000000'; circleClass = 'colored'; }
  }
      const bookedTotal = eventsOnDay.reduce((sum, e) => {
  if (!e.booked) return sum;
  return sum
    + Number(e.packagePrice   || 0)
    + Number(e.addOnPrice     || 0)
    + Number(e.transportPrice || 0);
}, 0);


    const today =
    d === now.getDate() && m === now.getMonth() && y === now.getFullYear();

  // Use circle as background of date number (full circle)
  const circleStyle = bgColor === 'transparent' ? '' : `background:${bgColor};`;
  const dateNumHtml = `<span class="calendar-date-circle ${circleClass}" style="${circleStyle} ${
    today ? 'box-shadow:0 6px 18px rgba(59,130,246,0.12);' : ''
  }">${d}</span>`;

  html += `<div class="calendar-cell" onclick="openCalendarDatePopup('${dateISO}')">
  ${dateNumHtml}
  ${bookedTotal > 0
    ? `<div style="margin-top:2px;font-size:11px;color:#16a34a;font-weight:500;">
         ${formatINR(bookedTotal)}
       </div>`
    : ''
  }
  ${eventsOnDay.length>0
    ? `<div style="
        position:absolute;
        top:4px;
        left:50%;
        transform:translateX(-50%);
        background:#166534;
        color:white;
        padding:2px 6px;
        border-radius:10px;
        font-size:10px;
        font-weight:600;
        line-height:1;
      ">
        ${eventsOnDay.length}
     </div>`
    : ''
  }
</div>`;
  }
  html += `</div>`;
  document.getElementById('calendar-widget').innerHTML = html;
  createLucide();
}

// --- add this under or after renderCalendar ---
function changeMonth(delta){
  // compute new month/year using curMonth/curYear as current state
  let newMonth = curMonth + delta;
  let newYear = curYear;
  if(newMonth > 11){ newMonth = 0; newYear += 1; }
  if(newMonth < 0){ newMonth = 11; newYear -= 1; }
  // render the calendar with the updated year/month
  renderCalendar(newYear, newMonth);
}


/* -------------------------
   Calendar popup (event list)
   - robust lookup for events (handles old entries without eventId)
   - shows time and location
   - includes button to open full quotation
   ------------------------- */
function openCalendarDatePopup(dateISO){
  // Ensure eventIds persist for older entries (persist on demand)
  persistMissingEventIds();

  const idx = buildCalendarEventIndex();
  const events = idx[dateISO] || [];
  const container = document.getElementById('calendarPopupContainer');
  container.innerHTML = ''; container.classList.remove('hidden');

  const popup = document.createElement('div'); popup.className='calendar-popup';
  const header = document.createElement('div');
  header.innerHTML = `<h3>Events on ${dateISO}</h3><div style="font-size:13px;color:#666;margin-bottom:8px">${events.length} event(s)</div>`;
  popup.appendChild(header);

  if(events.length === 0){
    const p = document.createElement('div'); p.className='p-2 text-sm text-gray-600'; p.textContent = 'No events on this date.'; popup.appendChild(p);
  } else {
    events.forEach(ev=>{
      const row = document.createElement('div'); row.className='event-row';
      const meta = document.createElement('div'); meta.className='meta';
      const detailsHtml = `
  <div class="details">
    <div><strong>${ev.clientName || ''}</strong></div>
    <div class="small" style="display:flex;align-items:center;gap:4px;">
      <span>${ev.clientContact || ''}</span>
      ${ev.clientContact ? `
        <button type="button"
                class="inline-flex items-center justify-center rounded-full border px-1.5 py-0.5 text-[11px]"
                data-contact="${(ev.clientContact || '').replace(/"/g, '&quot;')}"
                onclick="openContactOptions(this.dataset.contact)">
          <i data-lucide="phone-call" class="w-3 h-3"></i>
        </button>
      ` : ''}
    </div>
  </div>

  <div class="small"> ||
    ${ev.eventName || '(No name)'} â€¢ 	
    ${ev.time ? 'Time: ' + ev.time : ''}
    ${ev.location ? (ev.time ? ' â€¢ ' : '') + 'Location: ' + ev.location : ''}
  </div>
`;

      meta.innerHTML = detailsHtml;
      const controls = document.createElement('div'); controls.style.textAlign='right';
      const checkboxId = 'cb_' + (ev.eventId || Math.random().toString(36).slice(2,8));
      const bookChecked = ev.booked ? 'checked' : '';
      controls.innerHTML = `<div style="margin-bottom:6px">
        <label style="display:flex;align-items:center;gap:8px">
          <input id="${checkboxId}" type="checkbox" class="calendar-book-checkbox" data-eventid="${ev.eventId||''}" ${bookChecked} /> Booked</label>
          </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;"><button class="py-1 px-2 rounded border text-sm" onclick="openQuotationFromCalendar('${ev.quotationId}')">View Quotation</button></div>`;
      row.appendChild(meta); row.appendChild(controls);
      popup.appendChild(row);
    });

    const note = document.createElement('div'); note.style.fontSize='12px'; note.style.color='#444'; note.style.marginTop='8px';
    note.innerHTML = `<strong>Deduplication:</strong> If a client has multiple quotations with identical contact, only the newest quotation is shown in the calendar. If contact differs, multiple quotations are shown.`;
    popup.appendChild(note);
  }

  const actions = document.createElement('div'); actions.style.marginTop='12px'; actions.style.display='flex'; actions.style.justifyContent='space-between';
  const closeBtn = document.createElement('button'); closeBtn.className='py-2 px-3 rounded border'; closeBtn.textContent='Close';
  closeBtn.onclick = ()=>{ container.innerHTML=''; container.classList.add('hidden'); renderCalendar(); };
  actions.appendChild(closeBtn);
  popup.appendChild(actions);

  container.appendChild(popup);
  createLucide();

      // wire checkboxes robustly
  popup.querySelectorAll('.calendar-book-checkbox').forEach(cb=>{
    cb.addEventListener('change', async (e)=>{
      const checked = e.target.checked;
      const eventId = e.target.dataset.eventid;

      // Build index to find event object & quotation id
      const idx2 = buildCalendarEventIndex();

      // Search by eventId first
      let evObj = null;
      if (eventId) {
        for (const date in idx2) {
          const arr = idx2[date];
          for (const it of arr) {
            if (it.eventId === eventId) {
              evObj = it;
              break;
            }
          }
          if (evObj) break;
        }
      }

      // fallback: try to find by row text (existing logic)
      if (!evObj) {
        const row = e.target.closest('.event-row');
        if (row) {
          const nameText  = (row.querySelector('.details strong')?.textContent || '').trim();
          const smallText = (row.querySelector('.small')?.textContent || '').trim();
          if (nameText) {
            for (const date in idx2) {
              const arr = idx2[date];
              for (const it of arr) {
                if (it.eventName === nameText /* && it.date === dateISO */) {
                  evObj = it;
                  break;
                }
              }
              if (evObj) break;
            }
          }
        }
      }

            if (!evObj) {
        alert('Event metadata not found. (This should not happen â€” please check console.)');
        console.error('Calendar: event not found for checkbox', e.target);
        return;
      }

      // âœ… figure out how many events this quotation has
      let quotationEventCount = 0;
      for (const d in idx2) {
        const arr = idx2[d];
        quotationEventCount += arr.filter(it => it.quotationId === evObj.quotationId).length;
      }
      const hasMultipleEvents = quotationEventCount > 1;

      if (checked) {
        // ===========================
        //  MARK AS BOOKED (NEW FLOW)
        // ===========================

        if (hasMultipleEvents) {
          const yesWhole = await appConfirm(
          "<span style='color:green; font-weight:bold;'>Yes:</span> Mark All Events in this Quotation as Booked.<br>" +
           "<span style='color:red; font-weight:bold;'>No:</span> Mark only this Event as Booked."
  );

  let mode;

  if (yesWhole) {
    // YES â†’ mark ALL events of this quotation as booked
    setQuotationBookings(evObj.quotationId, true);
    mode = 'multi-all';
  } else {
    // NO â†’ only this event booked (but we will check if this completes all)
    setSingleEventBooking(evObj.eventId, true);
    mode = 'multi-single';
  }

  // ðŸ” Rebuild index AFTER booking change to see current booking status
  const idxAfter = buildCalendarEventIndex();
  let totalForQ = 0;
  let bookedForQ = 0;

  for (const d in idxAfter) {
    const arr = idxAfter[d];
    for (const it of arr) {
      if (it.quotationId === evObj.quotationId) {
        totalForQ++;
        if (it.booked) bookedForQ++;
      }
    }
  }

  // If ALL events for this quotation are now booked â†’ invoice should be NORMAL
  const allBookedNow = totalForQ > 0 && bookedForQ === totalForQ;

  // Invoice should only be void if it is still a partial booking
  const willBeVoid = !allBookedNow;

  const preview = prepareInvoicePreviewFromQuotation(evObj.quotationId);
  if (!preview) {
    alert('Quotation not found for generating invoice.');

    // revert booking because we cannot proceed
    if (yesWhole) {
      setQuotationBookings(evObj.quotationId, false);
    } else {
      setSingleEventBooking(evObj.eventId, false);
    }
    e.target.checked = false;
    return;
  }

  window.CALENDAR_BOOKING_FLOW = {
    fromCalendar: true,
    mode,
    quotationId: evObj.quotationId,
    eventId: evObj.eventId,
    dateISO,
    willBeVoid
  };
  updateCurrentInvoicePreviewFromCalendar(evObj.quotationId);
  openPaymentInfoModalRestrictedFromCalendar();

        } else {
          // ===========================
          //  SINGLE-EVENT QUOTATION
          // ===========================
          const generate = await appConfirm(
                "<span style='color:green; font-weight:bold;'>Yes:</span> Initiate Payment Info to generate Invoice<br>" +
                "<span style='color:red; font-weight:bold;'>No:</span> Keep this Event un-booked."
              );
            if (!generate) {
              // user does NOT want invoice â†’ keep as unbooked
              setSingleEventBooking(evObj.eventId, false);
              e.target.checked = false;
              return;
            }

            // Mark this single event as booked
            setSingleEventBooking(evObj.eventId, true);

            const preview = prepareInvoicePreviewFromQuotation(evObj.quotationId);
            if (!preview) {
              alert('Quotation not found for generating invoice.');
              setSingleEventBooking(evObj.eventId, false);
              e.target.checked = false;
              return;
            }

            window.CALENDAR_BOOKING_FLOW = {
              fromCalendar: true,
              mode: 'single',
              quotationId: evObj.quotationId,
              eventId: evObj.eventId,
              dateISO,
              willBeVoid: false
            };

            updateCurrentInvoicePreviewFromCalendar(evObj.quotationId);
            openPaymentInfoModalRestrictedFromCalendar();
        }

      } else {
        // ===========================
        //  UNMARK AS BOOKED (Option D)
        // ===========================
        const allInvoices = loadFromLS(SAVED_INVOICES_KEY, []);
        const nameKey    = (evObj.clientName    || '').trim().toLowerCase();
        const contactKey = (evObj.clientContact || '').trim().toLowerCase();

        const relatedInvoices = allInvoices.filter(inv => {
          const invName    = (inv.clientName    || '').trim().toLowerCase();
          const invContact = (inv.clientContact || '').trim().toLowerCase();
          const sameClient = invName === nameKey && invContact === contactKey;

          const sameQuotation =
            inv.id === evObj.quotationId ||
            inv.quotationId === evObj.quotationId;

          return sameClient || sameQuotation;
        });

        // ðŸ”¢ How many events are currently BOOKED for this quotation?
        const bookings = loadFromLS(BOOKED_EVENTS_KEY, {});
        let bookedCount = 0;

        for (const d in idx2) {
          const arr = idx2[d];
          for (const it of arr) {
            if (it.quotationId === evObj.quotationId && it.eventId && bookings[it.eventId]) {
              bookedCount++;
            }
          }
        }

        // This event is the last booked one if:
        //  - exactly 1 booked event exists now
        //  - and it's this event
        const isLastBookedEvent =
          bookedCount === 1 && evObj.eventId && bookings[evObj.eventId];

            // --- Scenario 1: YES = unmark whole quotation & auto delete invoice ---
        if (hasMultipleEvents) {
              const yesWhole = await appConfirm(
                "<span style='color:green; font-weight:bold;'>Yes:</span>Un-Mark All Events of this Quotation.<br>" +
                  "<span style='color:red; font-weight:bold;'>No:</span>Un-Mark only this Event as un-booked & Invoice marked as <b>Modified</b> State."
              );

              if (yesWhole) {
                // If invoice exists, confirm delete first
                if (relatedInvoices.length) {
                  const sureDelete = await appConfirm(
                    "<span style='color:green; font-weight:bold;'>Yes:</span>Delete invoice (System Removed).<br>" +
                    "<span style='color:red; font-weight:bold;'>No:</span>Keep Bookings and Invoice as-is."
                  );

                  if (!sureDelete) {
                    // user cancelled â†’ put checkbox back ON and abort
                    e.target.checked = true;
                    return;
                  }

              const recycleSystem = loadFromLS(RECYCLE_SYSTEM_KEY, []);
              const nowIso = new Date().toISOString();

              relatedInvoices.forEach(inv => {
                const idForInvoice = inv.invoiceId || inv.id;
                recycleSystem.push({
                  recycleId: uid('recycle'),
                  type: 'invoice',
                  kind: 'invoice',
                  label: (inv.clientName || 'Invoice'),
                  clientName: inv.clientName,
                  clientContact: inv.clientContact,
                  invoiceId: idForInvoice,
                  invoiceNo: inv.invoiceNo,
                  quotationId: evObj.quotationId,
                  removedAt: nowIso,
                  reason: 'Auto-deleted because all quotation events were un-booked from calendar',
                  original: inv
                });
              });

              saveToLS(RECYCLE_SYSTEM_KEY, recycleSystem);

              const remaining = allInvoices.filter(inv => !relatedInvoices.includes(inv));
              saveToLS(SAVED_INVOICES_KEY, remaining);

              if (typeof renderFilesList === 'function') {
                renderFilesList();
              }
            }

            // Finally unmark all bookings for this quotation
            setQuotationBookings(evObj.quotationId, false);

          } else {
             // ðŸ§© Scenario 2: only this event will be unmarked
            setSingleEventBooking(evObj.eventId, false);

            if (relatedInvoices.length) {
              if (isLastBookedEvent) {
                // âœ… LAST booked event â†’ offer DELETE invoice, not VOID
                const sureDelete = await appConfirm(
                   "This is the only event marked as Booked.<br><br>" +
                  "<span style='color:green; font-weight:bold;'>Yes:</span>Mark as un-book & Delete invoice (System Removed).<br>" +
                   "<span style='color:red; font-weight:bold;'>No:</span> Keep Booking & Invoice as-is."
                );

                if (sureDelete) {
                  const recycleSystem = loadFromLS(RECYCLE_SYSTEM_KEY, []);
                  const nowIso = new Date().toISOString();

                  relatedInvoices.forEach(inv => {
                    const idForInvoice = inv.invoiceId || inv.id;
                    recycleSystem.push({
                      recycleId: uid('recycle'),
                      type: 'invoice',
                      kind: 'invoice',
                      label: (inv.clientName || 'Invoice'),
                      clientName: inv.clientName,
                      clientContact: inv.clientContact,
                      invoiceId: idForInvoice,
                      invoiceNo: inv.invoiceNo,
                      quotationId: evObj.quotationId,
                      removedAt: nowIso,
                      reason: 'Auto-deleted because all events in the quotation were un-booked from calendar',
                      original: inv
                    });
                  });

                  saveToLS(RECYCLE_SYSTEM_KEY, recycleSystem);

                  const remaining = allInvoices.filter(inv => !relatedInvoices.includes(inv));
                  saveToLS(SAVED_INVOICES_KEY, remaining);

                  if (typeof renderFilesList === 'function') {
                    renderFilesList();
                  }
                } else {
                  // User cancelled â†’ revert the unbooking & checkbox
                  e.target.checked = true;
                  setSingleEventBooking(evObj.eventId, true);
                }

              } else {
                // ðŸŸ¡ Still at least one other event booked â†’ VOID invoice + trim events
                const voidIt = await appConfirm(
                  "<span style='color:green; font-weight:bold;'>Yes:</span> Mark invoice as MODIFIED.<br>" +
                  "<span style='color:red; font-weight:bold;'>No:</span> Keep Booking & Invoice as-is."
                );

                if (voidIt) {
                  const nowIso = new Date().toISOString();

                  // 1ï¸âƒ£ Mark related invoices as VOID
                  relatedInvoices.forEach(inv => {
                    inv.status   = 'void';
                    inv.voidedAt = nowIso;
                  });

                  // 2ï¸âƒ£ Trim invoice events to only currently booked ones
                  try {
                    const quotations = loadFromLS(SAVED_QUOTATIONS_KEY, []);
                    const q = quotations.find(x => x.id === evObj.quotationId);

                    if (q && Array.isArray(q.events)) {
                      const bookingsNow = loadFromLS(BOOKED_EVENTS_KEY, {});

                      const bookedEvents = q.events.filter(ev =>
                        ev.eventId && bookingsNow[ev.eventId]
                      );

                      if (bookedEvents.length) {
                        const clonedEvents = JSON.parse(JSON.stringify(bookedEvents));

                        const newActual = clonedEvents.reduce((sum, ev) => {
                          return sum +
                            Number(ev.packagePrice   || 0) +
                            Number(ev.addOnPrice     || 0) +
                            Number(ev.transportPrice || 0);
                        }, 0);

                        relatedInvoices.forEach(inv => {
                          inv.events = clonedEvents;

                          const disc = (typeof inv.discount === 'number')
                            ? inv.discount
                            : (typeof q.discount === 'number' ? q.discount : 0);

                          inv.discount = disc;
                          inv.actual   = newActual;
                          inv.final    = Math.max(0, newActual - disc);
                        });
                      }
                      // If no events remain booked, we leave events as-is; invoice stays void
                    }
                  } catch (err) {
                    console.warn('Failed to trim invoice events after calendar un-book:', err);
                  }

                  // 3ï¸âƒ£ Save + refresh
                  saveToLS(SAVED_INVOICES_KEY, allInvoices);
                  if (typeof renderFilesList === 'function') {
                    renderFilesList();
                  }
                } else {
                  // User cancelled â†’ revert the unbooking & checkbox
                  e.target.checked = true;
                  setSingleEventBooking(evObj.eventId, true);
                }
              }
            }
          }

        } else {
          // Single-event quotation: treat as whole quotation unmarked
          setSingleEventBooking(evObj.eventId, false);

          if (relatedInvoices.length) {
            const sureDelete = await appConfirm(
              "<span style='color:green; font-weight:bold;'>Yes:</span>Delete invoice (System Removed).<br>" +
               "<span style='color:red; font-weight:bold;'>No:</span> Keep Booking & Invoice as-is."
            );
            if (sureDelete) {
              const recycleSystem = loadFromLS(RECYCLE_SYSTEM_KEY, []);
              const nowIso = new Date().toISOString();

              relatedInvoices.forEach(inv => {
                const idForInvoice = inv.invoiceId || inv.id;
                recycleSystem.push({
                  type: 'invoice',
                  kind: 'invoice',
                  label: (inv.clientName || 'Invoice'),
                  clientName: inv.clientName,
                  clientContact: inv.clientContact,
                  invoiceId: idForInvoice,
                  quotationId: evObj.quotationId,
                  removedAt: nowIso,
                  reason: 'Auto-deleted because single-event quotation was un-booked from calendar'
                });
              });

              saveToLS(RECYCLE_SYSTEM_KEY, recycleSystem);

              const remaining = allInvoices.filter(inv => !relatedInvoices.includes(inv));
              saveToLS(SAVED_INVOICES_KEY, remaining);

              if (typeof renderFilesList === 'function') {
                renderFilesList();
              }
            } else {
              // user cancelled delete â†’ keep it booked
              e.target.checked = true;
              setSingleEventBooking(evObj.eventId, true);
            }
          }
        }
      }

      // Re-render popup and calendar to reflect new states
      openCalendarDatePopup(dateISO);
      renderCalendar();

      // ðŸ”„ Also refresh Dashboard "Upcoming Events"
      if (typeof updateDashboardUpcomingEvents === 'function') {
        updateDashboardUpcomingEvents();
      }

      // ðŸ” Auto-save to Drive (if signed in)
      if (typeof autoSaveDrive === 'function') {
        autoSaveDrive('calendar booking changed');
       }
    });
  });
}

function openQuotationFromCalendar(qId) {
  // Close/hide the calendar popup first
  const container = document.getElementById('calendarPopupContainer');
  if (container) {
    container.innerHTML = '';
    container.classList.add('hidden');
  }

  // Then open the quotation viewer as usual
  if (typeof openQuotationViewerById === 'function') {
    openQuotationViewerById(qId);
  } else {
    console.warn('openQuotationViewerById not found');
  }
}


/* -------------------------
   Quotation save: create eventId for each event and persist
   ------------------------- */
function collectEventsFromPanelsForSave(){
  const panels = Array.from(document.querySelectorAll('#eventsContainer > .event-panel'));

  return panels.map(panel => {
    const name =
      panel.querySelector('.event-eventNameMaster')?.value ||
      panel.querySelector('.event-eventNameManual')?.value ||
      '';

    const date = panel.querySelector('.event-eventDate')?.value || '';
    const hour = panel.querySelector('.event-eventHour')?.value || '';
    const minute = panel.querySelector('.event-eventMinute')?.value || '';
    const period = panel.querySelector('.event-eventPeriod')?.value || '';

    // --- package name + price ---
    let packagePrice = 0;
    let packageName = '';

    const pkgMasterSel = panel.querySelector('.event-packageMaster');
    if (pkgMasterSel) {
      const opt = pkgMasterSel.options[pkgMasterSel.selectedIndex];
      if (opt) {
        packageName = (opt.textContent || '').split('â€”')[0].trim();
        packagePrice = opt.dataset && opt.dataset.price
          ? parseFloat(opt.dataset.price)
          : 0;
      }
    } else {
      packageName =
        panel.querySelector('.event-packageSelectedManual')?.value || '';
      packagePrice = parseFloat(
        panel.querySelector('.event-packageManualPrice')?.value || 0
      );
    }

    // --- add-on details + price ---
    const addOnPrice = parseFloat(
      panel.querySelector('.event-addOnPrice')?.value || 0
    );

    let addonDetails = '';
    const addonDisplay = panel.querySelector('.event-addon-display');
    const addonManual = panel.querySelector('.event-addon-manual');

    if (
      addonDisplay &&
      addonDisplay.textContent &&
      addonDisplay.textContent.trim() &&
      !/Enter \(Text\)/i.test(addonDisplay.textContent) &&
      !/No items selected/i.test(addonDisplay.textContent)
    ) {
      addonDetails = addonDisplay.textContent.trim();
    } else if (addonManual && addonManual.value.trim()) {
      addonDetails = addonManual.value.trim();
    }

    // --- location + transport ---
    const locationVal =
      panel.querySelector('.event-eventLocationManual')?.value?.trim() || '';

    const transportRaw = panel.querySelector('.event-transportPrice')?.value;
    const transportPrice =
      transportRaw === undefined || transportRaw === null || transportRaw === ''
        ? NaN
        : parseFloat(transportRaw);

    const notes = panel.querySelector('.event-notes')?.value || '';

   const existingId = panel.dataset.eventId;
const eventId = existingId || uid('ev');

    return {
      eventId,
      name: name.trim(),
      date,
      time: `${hour || ''}:${minute || ''} ${period || ''}`.trim(),
      packageName,
      packagePrice,
      addonDetails,
      addOnPrice,
      transportPrice: isNaN(transportPrice) ? undefined : transportPrice,
      location: locationVal,
      notes,
    };
  });
}

function getCleanQuotationPayloadWithEventIds(){
  const clientName = (document.getElementById('clientNameInput')?.value || '').trim();
  const clientContact = (document.getElementById('clientContactInput')?.value || '').trim();
  const events = collectEventsFromPanelsForSave().filter(ev => ev.name && ev.date);
  const actual = events.reduce(
    (s,e)=> s + Number(e.packagePrice||0) + Number(e.addOnPrice||0) + Number(e.transportPrice||0),
    0
  );
  let discount = parseFloat(document.getElementById('quotationDiscount')?.value || 0);
  if(isNaN(discount) || discount <= 0) discount = 0;
  const final = Math.max(0, actual - discount);
  const payload = { clientName, clientContact, events, actual, final };
  if(discount > 0) payload.discount = Number(discount);
  return payload;
}

function saveQuotationMultiEvent() {
  const clientName = (document.getElementById('clientNameInput')?.value || '').trim();
  const clientContact = (document.getElementById('clientContactInput')?.value || '').trim();

  // âŒ basic validation â†’ stay on quotation screen
  if (!clientName || !clientContact) {
    showMessage('Client name and contact are required.');
    return;
  }

  // ðŸ”¢ Extra validation: phone must be exactly 10 digits
  if (!/^\d{10}$/.test(clientContact)) {
    showMessage('Client contact must be exactly 10 digits.');
    return;
  }

  // ðŸ”’ NEW: apply the same event restrictions used by the Update button
  const qPanels = Array.from(
    document.querySelectorAll('#eventsContainer > .event-panel')
  );

  if (qPanels.length === 0) {
    showMessage('Add at least one event with date & name.');
    return;
  }

  for (const panel of qPanels) {
    const res = validateEventPanel(panel);
    if (!res.valid) {
      // show the same message as Update button (name/date/package/location/add-on checks)
      showMessage(res.message);
      // scroll the bad panel into view so user can see what to fix
      try {
        panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (e) {}
      return;
    }
  }

  const payload = getCleanQuotationPayloadWithEventIds();
  if ((payload.events || []).length === 0) {
    showMessage('Add at least one event with date & name.');
    return;
  }

  try {
    const existing = loadFromLS(SAVED_QUOTATIONS_KEY, []);

    // ðŸ” DUPLICATE CHECK (case-insensitive: name + contact)
    const nameKey    = clientName.toLowerCase();
    const contactKey = clientContact.toLowerCase();

    const duplicate = existing.find(qItem => {
      const n = (qItem.clientName    || '').trim().toLowerCase();
      const c = (qItem.clientContact || '').trim().toLowerCase();
      const sameClient = n === nameKey && c === contactKey;

      // while editing, ignore the same record
      if (CURRENT_EDIT_QUOTATION_ID && qItem.id === CURRENT_EDIT_QUOTATION_ID) {
        return false;
      }
      return sameClient;
    });

    if (duplicate) {
      appConfirm(
        'Duplicate Quotation found for this Client name and Contact.\n\n' +
        'Do you want to open & edit that Quotation?'
      ).then(go => {
      if (go) {
        // put original quotation into edit buffer and go to quotation screen
        localStorage.setItem('CURRENT_EDIT_QUOTATION', JSON.stringify(duplicate));
        navigate('quotation', { skipInit: false });
      }
    });
      // â›” stop saving in both cases (Yes or No)
      return;
    }

    let savedQuotation;

    if (CURRENT_EDIT_QUOTATION_ID) {
      const idx = existing.findIndex(q => q.id === CURRENT_EDIT_QUOTATION_ID);
      if (idx !== -1) {
        // update existing quotation
        savedQuotation = {
          ...existing[idx],
          ...payload,
          id: CURRENT_EDIT_QUOTATION_ID,
          createdAt: new Date().toISOString()
        };
        existing[idx] = savedQuotation;
      } else {
        // fallback: treat as new if id not found
        savedQuotation = {
          ...payload,
          id: 'q_' + Date.now(),
          createdAt: new Date().toISOString()
        };
        existing.push(savedQuotation);
      }
    } else {
      // brand new quotation
      savedQuotation = {
        ...payload,
        id: 'q_' + Date.now(),
        createdAt: new Date().toISOString()
      };
      existing.push(savedQuotation);
    }
      
    /* ===== SYNC QUOTATION â†’ INVOICE if invoice exists ===== */
try {
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);
  const linkedInvoice = invoices.find(inv =>
    inv.clientName.trim().toLowerCase() === savedQuotation.clientName.trim().toLowerCase() &&
    inv.clientContact.trim() === savedQuotation.clientContact.trim()
  );

  if (linkedInvoice) {
    // Preserve payments
    const paidAdvance = Number(linkedInvoice.advancePaid || 0);
    const paidFinal   = Number(linkedInvoice.finalPaid || 0);
    const partialLog  = Array.isArray(linkedInvoice.paymentPartialLog)
                        ? [...linkedInvoice.paymentPartialLog]
                        : [];

    // Update invoice with new quotation values
    linkedInvoice.events = JSON.parse(JSON.stringify(savedQuotation.events));
    linkedInvoice.actual = Number(savedQuotation.actual);
    linkedInvoice.discount = Number(savedQuotation.discount || 0);
    linkedInvoice.final = Number(savedQuotation.final);

    linkedInvoice.billedAmount = linkedInvoice.final;

    // Recalculate pending & status
    const totalPaid = paidAdvance + paidFinal +
      partialLog.reduce((s, x) => s + Number(x.amount || 0), 0);

    linkedInvoice.paymentPendingRaw = linkedInvoice.billedAmount - totalPaid;
    linkedInvoice.paymentPendingAbs = Math.max(0, linkedInvoice.paymentPendingRaw);

    if (linkedInvoice.paymentPendingAbs === 0) {
      linkedInvoice.paymentStatus = "Completed";
    } else if (totalPaid === 0) {
      linkedInvoice.paymentStatus = "Pending";
    } else {
      linkedInvoice.paymentStatus = "Partial";
    }

    // Put payments back
    linkedInvoice.advancePaid = paidAdvance;
    linkedInvoice.finalPaid = paidFinal;
    linkedInvoice.paymentPartialLog = partialLog;

    saveToLS(SAVED_INVOICES_KEY, invoices);
    console.log("Quotation â†’ Invoice synced:", linkedInvoice);
  }
} catch (e) {
  console.warn("Invoice sync failed:", e);
}

    // persist quotations
    saveToLS(SAVED_QUOTATIONS_KEY, existing);


// (your original code continues hereâ€¦)
showMessage("Quotation saved");
renderFilesList();


    // refresh calendar & dashboard immediately
try {
  if (typeof renderCalendar === 'function') renderCalendar();
  if (typeof updateDashboardUpcomingEvents === 'function') updateDashboardUpcomingEvents();
} catch (e) {
  console.warn('Calendar refresh failed after quotation save:', e);
}

// optional: schedule Drive auto-save
try { scheduleAutoSave && scheduleAutoSave('quotation saved'); } catch(e){}

    // ensure no booking entries for events we just saved (they are enquiries)
    const bookings = loadFromLS(BOOKED_EVENTS_KEY, {});
    (savedQuotation.events || []).forEach(ev => {
      if (ev.eventId && bookings[ev.eventId]) {
        delete bookings[ev.eventId];
      }
    });
        saveToLS(BOOKED_EVENTS_KEY, bookings);

    CURRENT_EDIT_QUOTATION_ID = null;

    // âœ… success prompt
    showMessage('Quotation saved to Files â†’ Quotations', 'Saved');

    // refresh calendar dots
    renderCalendar();

    // â­ If this quotation came from a client request,
//   mark that request as imported & move it to System removed.
console.log('DEBUG: CURRENT_CLIENT_REQ_CTX at save =', window.CURRENT_CLIENT_REQ_CTX);

if (
  typeof CURRENT_CLIENT_REQ_CTX !== 'undefined' &&
  CURRENT_CLIENT_REQ_CTX &&
  CURRENT_CLIENT_REQ_CTX.rowIndex &&
  typeof markClientRequestImported === 'function'
) {
  try {
    console.log('DEBUG: calling markClientRequestImported with', CURRENT_CLIENT_REQ_CTX);
    markClientRequestImported(CURRENT_CLIENT_REQ_CTX);
  } catch (e) {
    console.warn('Failed to mark client request as imported:', e);
  }
  CURRENT_CLIENT_REQ_CTX = null;
} else {
  console.log('DEBUG: NOT calling markClientRequestImported â€“ condition failed');
}


    // ðŸ” Auto-save to Drive (if signed in)
    if (typeof autoSaveDrive === 'function') {
      autoSaveDrive('quotation saved');
    }

    // âœ… redirect to Files â†’ Quotations list
    navigate('files');
    switchFilesTab('quotations');

  } catch (err) {
    console.error(err);
    // âŒ error prompt and STAY on quotation screen
    showMessage('Failed to save quotation. Please try again.', 'Error');
  }
}


// =======================
// REVENUE HELPERS & UI
// =======================

// Small date formatter for period label
function formatRevenueDate(d) {
  if (!(d instanceof Date) || isNaN(d.getTime())) return '';
  const day   = String(d.getDate()).padStart(2, '0');
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const mon   = monthNames[d.getMonth()];
  const year  = d.getFullYear();
  return `${day} ${mon} ${year}`;
}

function formatRevenueRangeLabel(start, end) {
  if (!start || !end) return '';
  return `${formatRevenueDate(start)} - ${formatRevenueDate(end)}`;
}

// Compute date range based on filter preset / custom range
function getRevenueDateRange() {
  const presetSelect = document.getElementById('revenueFilterPreset');
  const fromInput    = document.getElementById('revenueFromDate');
  const toInput      = document.getElementById('revenueToDate');
  if (!presetSelect || !fromInput || !toInput) return null;

  const preset = presetSelect.value || 'this_month';
  const today  = new Date();
  today.setHours(0, 0, 0, 0);

  let start = null;
  let end   = null;

  if (preset === 'range') {
    const fromVal = fromInput.value;
    const toVal   = toInput.value;
    if (!fromVal || !toVal) return null;

    start = new Date(fromVal);
    end   = new Date(toVal);
    if (isNaN(start.getTime()) || isNaN(end.getTime()) || start > end) {
      return null;
    }
  } else if (preset === 'this_week' || preset === 'last_week') {
    // Mondayâ€“Sunday weeks
    const cur = new Date(today);
    const day = cur.getDay(); // 0=Sun,1=Mon,...6=Sat
    const diffToMonday = (day + 6) % 7;
    const thisWeekStart = new Date(cur);
    thisWeekStart.setDate(thisWeekStart.getDate() - diffToMonday);
    const thisWeekEnd = new Date(thisWeekStart);
    thisWeekEnd.setDate(thisWeekStart.getDate() + 6);

    if (preset === 'this_week') {
      start = thisWeekStart;
      end   = thisWeekEnd;
    } else {
      // last week
      start = new Date(thisWeekStart);
      start.setDate(start.getDate() - 7);
      end = new Date(thisWeekStart);
      end.setDate(end.getDate() - 1);
    }
  } else if (preset === 'this_month' || preset === 'last_month') {
    const year  = today.getFullYear();
    const month = today.getMonth(); // 0-based
    if (preset === 'this_month') {
      start = new Date(year, month, 1);
      end   = new Date(year, month + 1, 0);
    } else {
      const prevMonth = month - 1;
      const y = prevMonth < 0 ? year - 1 : year;
      const m = prevMonth < 0 ? 11 : prevMonth;
      start = new Date(y, m, 1);
      end   = new Date(y, m + 1, 0);
    }
  } else if (preset === 'this_year' || preset === 'last_year') {
    const year = today.getFullYear();
    if (preset === 'this_year') {
      start = new Date(year, 0, 1);
      end   = new Date(year, 11, 31);
    } else {
      start = new Date(year - 1, 0, 1);
      end   = new Date(year - 1, 11, 31);
    }
  }

  if (!start || !end) return null;
  start.setHours(0, 0, 0, 0);
  end.setHours(23, 59, 59, 999);

  return {
    start,
    end,
    label: formatRevenueRangeLabel(start, end)
  };
}

// Map invoice.paymentStatus -> revenue bucket
//  - 'pending'  => booked
//  - 'partial'  => partial
//  - 'completed'/'paid' => paid
function getInvoiceRevenueBucket(inv) {
  if (!inv) return null;
  const statusRaw = String(inv.paymentStatus || '').toLowerCase();
  const voidRaw   = String(inv.status || '').toLowerCase();
  if (voidRaw === 'void') return null; // ignore void invoices in revenue

  if (statusRaw === 'completed' || statusRaw === 'paid' || statusRaw === 'complete') {
    return 'paid';
  }
  if (statusRaw === 'partial' || statusRaw === 'partial paid') {
    return 'partial';
  }
  // default: pending / empty
  return 'booked';
}

// Find a related invoice for a quotation (by id or by client+contact)
function findInvoiceForQuotationFromList(q, invoices) {
  if (!q || !Array.isArray(invoices)) return null;

  const nameKey    = (q.clientName    || '').trim().toLowerCase();
  const contactKey = (q.clientContact || '').trim().toLowerCase();

  const matches = invoices.filter(inv => {
    if (!inv) return false;
    const invName    = (inv.clientName    || '').trim().toLowerCase();
    const invContact = (inv.clientContact || '').trim().toLowerCase();

    const sameClient =
      !!invName && !!invContact &&
      invName === nameKey &&
      invContact === contactKey;

    const sameQuotation =
      inv.id === q.id ||
      inv.quotationId === q.id;

    return sameClient || sameQuotation;
  });

  if (!matches.length) return null;

  // Pick the latest by createdAt
  matches.sort((a, b) => {
    const da = new Date(a.createdAt || 0).getTime();
    const db = new Date(b.createdAt || 0).getTime();
    return db - da;
  });

  return matches[0];
}

// Build revenue buckets:
// - Enquiry / Booked  â†’ from quotation events + bookings (same as before)
// - Misc / Partial / Paid â†’ from Payment Info on invoices
function computeRevenueBuckets() {
  const range = getRevenueDateRange();
  if (!range) return null;

  const bookingsMap = loadFromLS(BOOKED_EVENTS_KEY, {});
  const quotations  = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const invoices    = loadFromLS(SAVED_INVOICES_KEY, []);

  const buckets = {
    enquiry: { label: 'Enquiry - not booked', amount: 0, count: 0 },
    booked:  { label: 'Booked',               amount: 0, count: 0 },
    misc:    { label: 'Miscellaneous',        amount: 0, count: 0 },
    partial: { label: 'Partial paid',         amount: 0, count: 0 },
    paid:    { label: 'Paid',                 amount: 0, count: 0 },
    actualPending: { label: 'Actual Pending', amount: 0, count: 0 }
  };

  // 1ï¸âƒ£ Enquiry / Booked from quotation events (same as earlier)
  quotations.forEach(q => {
    (q.events || []).forEach(ev => {
      if (!ev || !ev.date) return;

      const evDate = new Date(ev.date);
      if (isNaN(evDate.getTime())) return;
      if (evDate < range.start || evDate > range.end) return;

      const eventId  = ev.eventId;
      const isBooked = eventId && bookingsMap[eventId];

      const amount =
        Number(ev.packagePrice   || 0) +
        Number(ev.addOnPrice     || 0) +
        Number(ev.transportPrice || 0);

      if (isBooked) {
        buckets.booked.amount += amount;
        buckets.booked.count  += 1;
      } else {
        buckets.enquiry.amount += amount;
        buckets.enquiry.count  += 1;
      }
    });
  });

  // 2ï¸âƒ£ Payment-based buckets from invoices (Partial / Paid / Misc)
  invoices.forEach(inv => {
    if (!inv) return;

    // Use paymentLastUpdated if present, otherwise createdAt/date
    const whenStr = inv.paymentLastUpdated || inv.createdAt || inv.date;
    if (!whenStr) return;

    const when = new Date(whenStr);
    if (isNaN(when.getTime())) return;
    if (when < range.start || when > range.end) return;

    // --- work out payment status key: pending / partial / paid ---
    let raw = String(inv.paymentStatus || inv.statusPayment || '').toLowerCase();
    let statusKey = '';

    if (raw === 'pending') {
      statusKey = 'pending';
    } else if (raw === 'partial' || raw === 'partial paid') {
      statusKey = 'partial';
    } else if (raw === 'completed' || raw === 'complete' || raw === 'paid') {
      statusKey = 'paid';
    } else {
      // Fallback: derive from billed vs paid
      const billed    = Number(inv.final || inv.actual || 0) || 0;
      const advance   = Number(inv.advancePaid || inv.paymentAdvance || 0) || 0;
      const finalPaid = Number(inv.finalPaid   || inv.paymentFinal   || 0) || 0;
      const totalPaid = advance + finalPaid;

      if (!billed || totalPaid <= 0) {
        statusKey = 'pending';
      } else if (totalPaid + 0.01 < billed) {
        statusKey = 'partial';
      } else {
        statusKey = 'paid';
      }
    }

    // Amounts from Payment Info
    const finalPaid =
      Number(inv.finalPaid || inv.paymentFinal || 0) || 0;

    const misc =
      Number(inv.miscAmount || 0) || 0;

      const pendingAbs =
      Number(
        inv.paymentPendingAbs != null
          ? inv.paymentPendingAbs
          : (inv.paymentPendingRaw != null
              ? Math.max(0, inv.paymentPendingRaw)
              : 0)
      ) || 0;

    // Partial paid â†’ sum of Final Paid for partial invoices
    if (statusKey === 'partial' && finalPaid > 0) {
      buckets.partial.amount += finalPaid;
      buckets.partial.count  += 1;
    }

    // Paid â†’ sum of Final Paid for fully paid invoices
    if (statusKey === 'paid' && finalPaid > 0) {
      buckets.paid.amount += finalPaid;
      buckets.paid.count  += 1;
    }

    // Miscellaneous â†’ sum of Misc for any invoice where misc > 0
    if (misc > 0) {
      buckets.misc.amount += misc;
      buckets.misc.count  += 1;
    }

    // ðŸ”´ Pending Actual â†’ pending bill amount of Partial + Pending invoices
      if ((statusKey === 'pending' || statusKey === 'partial') && pendingAbs > 0) {
        buckets.actualPending.amount += pendingAbs;
        buckets.actualPending.count  += 1;
      }
  });

  return {
    rangeLabel: range.label,
    buckets
  };
}


// Draw simple pie chart on canvas based on selected buckets
function drawRevenuePie(data, selectedKeys) {
  const canvas = document.getElementById('revenuePieCanvas');
  if (!canvas || !canvas.getContext) return;

  const ctx = canvas.getContext('2d');
  const width  = canvas.width;
  const height = canvas.height;
  ctx.clearRect(0, 0, width, height);

  const centerX = width  / 2;
  const centerY = height / 2;
  const radius  = Math.min(width, height) / 2 - 10;

  const colors = {
    enquiry: '#000000', // black
    booked:  '#2563eb', // blue-ish
     misc:    '#a855f7', // violet
    partial: '#ff9549', // orange
    paid:    '#22c55e',  // green
    actualPending: '#7b0000'  // red
  };

  const buckets = data && data.buckets ? data.buckets : {};
  const order   = ['enquiry','booked','misc','partial','paid','actualPending'];

  const slices = [];
  let totalValue = 0;
  order.forEach(key => {
    if (!selectedKeys.includes(key)) return;
    const b = buckets[key] || { amount: 0 };
    const val = Number(b.amount || 0);
    if (val <= 0) return;
    slices.push({ key, value: val });
    totalValue += val;
  });

  if (!slices.length || totalValue <= 0) {
    ctx.fillStyle = '#6b7280';
    ctx.font = '14px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('No data for this period', centerX, centerY);
    return;
  }

  let startAngle = -Math.PI / 2; // start at top
  slices.forEach(s => {
    const angle = (s.value / totalValue) * Math.PI * 2;
    const endAngle = startAngle + angle;

    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();
    ctx.fillStyle = colors[s.key] || '#9ca3af';
    ctx.fill();
  
    // Draw percentage label inside slice
    const midAngle = startAngle + angle / 2;
    const labelRadius = radius * 0.6; // 60% of radius, so text is inside
    const labelX = centerX + Math.cos(midAngle) * labelRadius;
    const labelY = centerY + Math.sin(midAngle) * labelRadius;

    const percent = (s.value / totalValue) * 100;
    const percentText = `${Math.round(percent)}%`;

    ctx.fillStyle = '#ffffff';
    ctx.font = '12px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(percentText, labelX, labelY);

    startAngle = endAngle;
  });
}

// Render table rows based on buckets + selected statuses
function renderRevenueTable(data, selectedKeys) {
  const tbody   = document.getElementById('revenueTableBody');
  const totalEl = document.getElementById('revenueTableTotal');
  const noteEl  = document.getElementById('revenueEmptyMessage');

  if (!tbody) return;

  tbody.innerHTML = '';

  if (!data) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td colspan="3" class="border px-2 py-2 text-center text-gray-500 text-xs">
        Select a valid date or range to view revenue.
      </td>
    `;
    tbody.appendChild(tr);
    if (totalEl) totalEl.textContent = 'â€“';
    if (noteEl) {
      noteEl.textContent =
        'Choose a preset or a valid Fromâ€“To date range to see revenue breakdown.';
    }
    return;
  }

  const order = [
    ['enquiry', 'Enquiry - not booked'],
    ['booked',  'Booked'],
    ['misc',    'Miscellaneous'],
    ['partial', 'Partial paid'],
    ['paid',    'Paid'],
    ['actualPending', 'Actual Pending']
  ];

  const buckets = data.buckets || {};
  let anyRow    = false;

  order.forEach(([key, label]) => {
    if (!selectedKeys.includes(key)) return;
    const b = buckets[key] || { amount: 0, count: 0 };
    if (!b.count && !b.amount) return;

    anyRow = true;

      let labelHtml = label;
      if (key === 'actualPending') {
        labelHtml = `
          <span class="inline-flex items-center gap-1">
            <span>${label}</span>
            <span
              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-red-100 text-red-700 text-[10px] cursor-default"
              title="Actual Pending = Pending bill amount of Partial paid & Pending invoices."
            >
              i
            </span>
          </span>
        `;
      }

      const tr = document.createElement('tr');

    tr.innerHTML = `
      <td class="border border-gray-200 px-2 py-1 whitespace-nowrap">${label}</td>
      <td class="border border-gray-200 px-2 py-1 text-right">${b.count}</td>
      <td class="border border-gray-200 px-2 py-1 text-right">${formatINR(b.amount)}</td>
    `;
    tbody.appendChild(tr);
  });

  if (!anyRow) {
    const tr = document.createElement('tr');
    
    tr.innerHTML = `
      <td colspan="3" class="border px-2 py-2 text-center text-gray-500 text-xs">
        No events found for this period / filter.
      </td>
    `;
    tbody.appendChild(tr);
  }

  // ðŸ”¢ Net revenue = (partial + paid) - misc, but ONLY using selected keys
  let revenueTotal = null;
  if (Array.isArray(selectedKeys) && selectedKeys.length) {
    const b = buckets;

    const usePartial = selectedKeys.includes('partial');
    const usePaid    = selectedKeys.includes('paid');
    const useMisc    = selectedKeys.includes('misc');

    const hasGroup2 = usePartial || usePaid || useMisc;

    if (hasGroup2) {
      const partialAmt = usePartial ? (b.partial?.amount || 0) : 0;
      const paidAmt    = usePaid    ? (b.paid?.amount    || 0) : 0;
      const miscAmt    = useMisc    ? (b.misc?.amount    || 0) : 0;

      revenueTotal = (partialAmt + paidAmt) - miscAmt;
    } else {
      // None of misc/partial/paid selected â†’ net = 0
      revenueTotal = 0;
    }
  }

  if (totalEl) {
    if (revenueTotal === null) {
      totalEl.textContent = 'â€“';
    } else {
      totalEl.textContent = formatINR(revenueTotal);
    }
  }

  if (noteEl) {
    noteEl.textContent =
      'Total = (Partial + Paid) âˆ’ Miscellaneous for the selected statuses.';
  }
}


// Main refresh for Revenue screen
function refreshRevenueUI() {
  const periodLabelEl = document.getElementById('revenuePeriodLabel');
  const canvas = document.getElementById('revenuePieCanvas');
  if (!canvas) return;

  // Which statuses are enabled?
  const selectedKeys = [];
  document
    .querySelectorAll('#revenueLegend input.revenueLegendChk')
    .forEach(cb => {
      if (cb.checked) {
        const key = cb.dataset.key;
        if (key) selectedKeys.push(key);
      }
    });

  const data = computeRevenueBuckets();

  if (periodLabelEl) {
    periodLabelEl.textContent = data && data.rangeLabel ? data.rangeLabel : '';
  }

  drawRevenuePie(data, selectedKeys);
  renderRevenueTable(data, selectedKeys);
}

// Initialiser called from navigate('revenue')
let _revenueLegendUpdating = false;
function initRevenueFilters() {
  const presetSelect = document.getElementById('revenueFilterPreset');
  const fromInput    = document.getElementById('revenueFromDate');
  const toInput      = document.getElementById('revenueToDate');

  if (!presetSelect || !fromInput || !toInput) return;

  const updateRangeState = () => {
    const val = presetSelect.value;
    const isRange = (val === 'range');

    fromInput.disabled = !isRange;
    toInput.disabled   = !isRange;

    if (!isRange) {
      fromInput.value = '';
      toInput.value   = '';
    }
  };

  if (!presetSelect.dataset.revenueInitDone) {
    // When preset changes, toggle range inputs + refresh
    presetSelect.addEventListener('change', () => {
      updateRangeState();
      refreshRevenueUI();
    });

    // React to manual date changes
    fromInput.addEventListener('change', refreshRevenueUI);
    toInput.addEventListener('change', refreshRevenueUI);

    // Legend checkbox changes
   // Legend checkbox changes
const legend = document.getElementById('revenueLegend');
if (legend) {
  legend.addEventListener('change', (ev) => {
    const target = ev.target;
    if (!target || !target.classList.contains('revenueLegendChk')) return;
    if (_revenueLegendUpdating) return;

    const key      = target.dataset.key;
    const isChecked = target.checked;

    const allCbs = Array.from(
      document.querySelectorAll('#revenueLegend input.revenueLegendChk')
    );

    const cbEnquiry = allCbs.find(cb => cb.dataset.key === 'enquiry');
    const cbBooked  = allCbs.find(cb => cb.dataset.key === 'booked');
    const cbMisc    = allCbs.find(cb => cb.dataset.key === 'misc');
    const cbPartial = allCbs.find(cb => cb.dataset.key === 'partial');
    const cbPaid    = allCbs.find(cb => cb.dataset.key === 'paid');

    _revenueLegendUpdating = true;
    try {
      // Group 1: Enquiry & Booked are linked
      if (key === 'enquiry' || key === 'booked') {
        if (isChecked) {
          if (cbEnquiry) cbEnquiry.checked = true;
          if (cbBooked)  cbBooked.checked  = true;

          // When user chooses Enquiry/Booked, allow them exclusively
          if (cbMisc)    cbMisc.checked    = false;
          if (cbPartial) cbPartial.checked = false;
          if (cbPaid)    cbPaid.checked    = false;
        } else {
          // If user unticks either, both get unticked
          if (cbEnquiry) cbEnquiry.checked = false;
          if (cbBooked)  cbBooked.checked  = false;
        }
      }

      // Group 2: Misc / Partial / Paid
      if (key === 'misc' || key === 'partial' || key === 'paid') {
        if (isChecked) {
          // As soon as any of these 3 is selected,
          // Enquiry & Booked get auto-unticked
          if (cbEnquiry) cbEnquiry.checked = false;
          if (cbBooked)  cbBooked.checked  = false;
        }
        // User can freely pick any combination among misc/partial/paid,
        // so we don't auto-change other group-2 checkboxes here.
      }
    } finally {
      _revenueLegendUpdating = false;
    }

    // After weâ€™ve normalized all checkboxes, redraw chart + table
    refreshRevenueUI();
  });
}


    presetSelect.dataset.revenueInitDone = '1';
  }

  // Ensure correct state + initial data
  updateRangeState();
  refreshRevenueUI();
}

// =============================
// Revenue screen â† Payment data
// =============================

// Read current date range from the Revenue filter controls
function getRevenueDateRangeForInvoices() {
  const presetSelect = document.getElementById('revenueFilterPreset');
  const fromInput    = document.getElementById('revenueFromDate');
  const toInput      = document.getElementById('revenueToDate');

  const preset = presetSelect ? presetSelect.value : 'thisMonth';

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let start = null;
  let end   = null;
  let label = '';

  const makeMonthRange = (y, m) => {
    const s = new Date(y, m, 1);
    const e = new Date(y, m + 1, 0);
    s.setHours(0, 0, 0, 0);
    e.setHours(23, 59, 59, 999);
    return { start: s, end: e };
  };

  if (preset === 'thisWeek' || preset === 'lastWeek') {
    // Monday-first week
    const day = today.getDay();            // 0..6 (Sun..Sat)
    const diffToMon = (day + 6) % 7;       // days since Monday
    const monday = new Date(today);
    monday.setDate(today.getDate() - diffToMon);

    if (preset === 'lastWeek') {
      monday.setDate(monday.getDate() - 7);
    }

    start = new Date(monday);
    start.setHours(0, 0, 0, 0);

    end = new Date(start);
    end.setDate(start.getDate() + 6);
    end.setHours(23, 59, 59, 999);

    label = preset === 'thisWeek' ? 'This week' : 'Last week';
  } else if (preset === 'thisMonth' || preset === 'lastMonth') {
    let y = today.getFullYear();
    let m = today.getMonth();

    if (preset === 'lastMonth') {
      m -= 1;
      if (m < 0) { m = 11; y -= 1; }
    }

    const range = makeMonthRange(y, m);
    start = range.start;
    end   = range.end;
    label = preset === 'thisMonth' ? 'This month' : 'Last month';
  } else if (preset === 'thisYear' || preset === 'lastYear') {
    let y = today.getFullYear();
    if (preset === 'lastYear') y -= 1;

    start = new Date(y, 0, 1);
    end   = new Date(y, 11, 31);
    start.setHours(0, 0, 0, 0);
    end.setHours(23, 59, 59, 999);
    label = preset === 'thisYear' ? 'This year' : 'Last year';
  } else if (preset === 'range') {
    const fVal = fromInput ? fromInput.value : '';
    const tVal = toInput ? toInput.value   : '';

    if (fVal) {
      start = new Date(fVal);
      start.setHours(0, 0, 0, 0);
    }
    if (tVal) {
      end = new Date(tVal);
      end.setHours(23, 59, 59, 999);
    }
    label = (fVal || tVal) ? `${fVal || 'â€¦'} to ${tVal || 'â€¦'}` : 'Custom range';
  }

  return { preset, start, end, label };
}

// Compute Pending / Partial paid / Paid buckets from invoices
function computeRevenueBucketsFromInvoices(rangeInfo) {
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []) || [];
  const range = rangeInfo || {};
  const start = range.start || null;
  const end   = range.end   || null;

  const buckets = {
    pending: { amount: 0, count: 0 }, // sum of Pending amounts
    partial: { amount: 0, count: 0 }, // sum of Final Paid for partial invoices
    paid:    { amount: 0, count: 0 }  // sum of Final Paid for fully paid invoices
  };

  invoices.forEach(inv => {
    const createdStr = inv.createdAt || inv.date;
    if (!createdStr) return;

    const created = new Date(createdStr);
    if (start && created < start) return;
    if (end && created > end)     return;

    // --- work out payment status key: pending / partial / paid ---
    let raw = String(inv.paymentStatus || inv.statusPayment || '').toLowerCase();
    let statusKey = '';

    if (raw === 'pending') statusKey = 'pending';
    else if (raw === 'partial' || raw === 'partial paid') statusKey = 'partial';
    else if (raw === 'completed' || raw === 'complete' || raw === 'paid') statusKey = 'paid';
    else {
      const billed   = Number(inv.final || inv.actual || 0) || 0;
      const advance  = Number(inv.advancePaid || inv.paymentAdvance || 0) || 0;
      const finalPd  = Number(inv.finalPaid   || inv.paymentFinal   || 0) || 0;
      const totalPaid = advance + finalPd;

      if (!billed || totalPaid <= 0) statusKey = 'pending';
      else if (totalPaid + 0.01 < billed) statusKey = 'partial';
      else statusKey = 'paid';
    }

    // --- amounts ---
    const pendingAbs =
      Number(
        inv.paymentPendingAbs != null
          ? inv.paymentPendingAbs
          : (inv.paymentPendingRaw != null
              ? Math.max(0, inv.paymentPendingRaw)
              : 0)
      ) || 0;

    const finalPaid =
      Number(inv.finalPaid || inv.paymentFinal || 0) || 0;

    if (statusKey === 'pending') {
      buckets.pending.amount += pendingAbs;
      buckets.pending.count += 1;
    } else if (statusKey === 'partial') {
      buckets.partial.amount += finalPaid;
      buckets.partial.count += 1;
    } else if (statusKey === 'paid') {
      buckets.paid.amount += finalPaid;
      buckets.paid.count += 1;
    }
  });

  return buckets;
}

// Main hook called when Revenue screen opens and filters change
function refreshRevenueFromPayments() {
  const rangeInfo = getRevenueDateRangeForInvoices();
  const buckets   = computeRevenueBucketsFromInvoices(rangeInfo);

  // ðŸ‘‰ This is the data you should feed into:
  //    - the Revenue pie chart
  //    - the dynamic table (amount + count per bucket)
  //
  // Example shape:
  // buckets = {
  //   pending: { amount: 12345, count: 3 },
  //   partial: { amount: 4567,  count: 2 },
  //   paid:    { amount: 8900,  count: 5 }
  // }

  console.log('[Revenue] range:', rangeInfo.label, 'buckets:', buckets);

  // If you already have functions to draw pie & table, call them here, e.g.:
  // updateRevenuePieAndTable(buckets, rangeInfo);
}

// Wrapper used by navigate('revenue')
function initRevenueScreenFromPayments() {
  // keep existing behaviour (enable/disable date fields)
  initRevenueFilters();

  const presetSelect = document.getElementById('revenueFilterPreset');
  const fromInput    = document.getElementById('revenueFromDate');
  const toInput      = document.getElementById('revenueToDate');

  if (presetSelect && !presetSelect.dataset.revenuePaymentsInit) {
    presetSelect.addEventListener('change', () => {
      // date range state is already updated by initRevenueFilters listener
      refreshRevenueFromPayments();
    });

    if (fromInput) fromInput.addEventListener('change', refreshRevenueFromPayments);
    if (toInput)   toInput.addEventListener('change', refreshRevenueFromPayments);

    presetSelect.dataset.revenuePaymentsInit = '1';
  }

  // First render when screen opens
  refreshRevenueFromPayments();
}



/* -------------------------
   Files UI & PDF helpers
   (reused, slightly simplified)
   ------------------------- */
function switchFilesTab(tab) {
  const isQ   = (tab === 'quotations');
  const isInv = (tab === 'invoices');
  const isPay = (tab === 'payments');

  // Top tab buttons
  const tq = document.getElementById('tab-quotations');
  const ti = document.getElementById('tab-invoices');
  const tp = document.getElementById('tab-payments');

  if (tq) tq.classList.toggle('active', isQ);
  if (ti) ti.classList.toggle('active', isInv);
  if (tp) tp.classList.toggle('active', isPay);

  // Tab content panels
  const qTab = document.getElementById('quotationsTab');
  const iTab = document.getElementById('invoicesTab');
  const pTab = document.getElementById('paymentsTab');

  if (qTab) qTab.classList.toggle('hidden', !isQ);
  if (iTab) iTab.classList.toggle('hidden', !isInv);
  if (pTab) pTab.classList.toggle('hidden', !isPay);

  // Show status dropdown ONLY on Payment Info tab
  const statusWrapper = document.getElementById('paymentStatusFilterWrapper');
  if (statusWrapper) {
    statusWrapper.style.display = isPay ? 'flex' : 'none';
  }

  renderFilesList();
}


function loadFilesUI(){
  // you can use these later if needed
  const rawQ = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const rawI = loadFromLS(SAVED_INVOICES_KEY, []);

  // for now we just render the list
  renderFilesList();
}
// Change this to match your actual date field name (e.g. file.date or file.docDate)
function getFileDate(file) {
  // Example: if your file object has `file.date` as "2025-11-15"
  return new Date(file.date);
}

// -------------------------
// Recycle Bin UI
// -------------------------
let RECYCLE_FILTERS_BOUND = false;

function switchRecycleTab(which) {
  
  const isUser = (which === 'user');

  document.getElementById('recycleTabUser')
    ?.classList.toggle('active', isUser);
  document.getElementById('recycleTabSystem')
    ?.classList.toggle('active', !isUser);

  document.getElementById('recycleUserTab')
    ?.classList.toggle('hidden', !isUser);
  document.getElementById('recycleSystemTab')
    ?.classList.toggle('hidden', isUser);
}

function getRecycleItems(kind) {
  return loadFromLS(
    kind === 'user' ? RECYCLE_USER_KEY : RECYCLE_SYSTEM_KEY,
    []
  );
}

// type filter: all / quotation / invoice / others
function recycleMatchesType(item, typeFilter) {
  if (!typeFilter || typeFilter === 'all') return true;

  const raw = String(item.type || item.kind || '').toLowerCase();

  const isQuotation =
    raw.includes('quotation') || raw === 'quote' || raw === 'q';
  const isInvoice =
    raw.includes('invoice') || raw === 'inv';

  if (typeFilter === 'quotation') return isQuotation;
  if (typeFilter === 'invoice')   return isInvoice;
  if (typeFilter === 'others')    return !isQuotation && !isInvoice;

  return true;
}

function recycleMatchesName(item, query) {
  if (!query) return true;
  const q = query.trim().toLowerCase();
  if (!q) return true;

  const text = [
    item.label,
    item.clientName,
    item.name,
    item.id,
    item.invoiceId,
    item.invoiceNo,
    item.quotationId,
    item.quotationNo,
    item.notes,
  ]
    .filter(Boolean)
    .join(' ')
    .toLowerCase();

  return text.includes(q);
}

// âœ… Reuse existing matchesDateFilter from Files page
function recycleMatchesDate(item, filterStr) {
  if (!filterStr) return true;

  // Prefer removedAt, else date / createdAt
  const dateVal = item.removedAt || item.date || item.createdAt;
  if (!dateVal) return false;

  // matchesDateFilter expects { date: ... } and uses getFileDate(file)
  return matchesDateFilter({ date: dateVal }, filterStr);
}

function filterRecycleItems(kind) {
  const items = getRecycleItems(kind);

  const typeSelId = (kind === 'user') ? 'recycleUserType'   : 'recycleSystemType';
  const nameId    = (kind === 'user') ? 'recycleUserName'   : 'recycleSystemName';
  const dateId    = (kind === 'user') ? 'recycleUserDate'   : 'recycleSystemDate';

  const typeFilter = document.getElementById(typeSelId)?.value || 'all';
  const nameFilter = document.getElementById(nameId)?.value || '';
  const dateFilter = document.getElementById(dateId)?.value || '';

  let filtered = items.filter((it) =>
    recycleMatchesType(it, typeFilter) &&
    recycleMatchesName(it, nameFilter) &&
    recycleMatchesDate(it, dateFilter)
  );

  // 2) Sort by removedAt (newest first). Fallback to date / createdAt.
  filtered.sort((a, b) => {
    const da = new Date(a.removedAt || a.date || a.createdAt || 0).getTime();
    const db = new Date(b.removedAt || b.date || b.createdAt || 0).getTime();
    return db - da; // descending â†’ latest first
  });

  return filtered;
}

function renderRecycleList(kind) {
  const listId  = (kind === 'user') ? 'recycleUserList'  : 'recycleSystemList';
  const emptyId = (kind === 'user') ? 'recycleUserEmpty' : 'recycleSystemEmpty';

  const container = document.getElementById(listId);
  const emptyEl   = document.getElementById(emptyId);
  if (!container) return;

  const items = filterRecycleItems(kind);

  if (!items.length) {
    container.innerHTML = '';
    if (emptyEl) emptyEl.classList.remove('hidden');
    return;
  }

  if (emptyEl) emptyEl.classList.add('hidden');

  container.innerHTML = items.map((it, idx) => {
    const label  = it.label || it.clientName || it.name || it.id || `Item ${idx + 1}`;
    const when   = it.removedAt ? new Date(it.removedAt).toLocaleString() : '';
    const type   = it.type || it.kind || '';
    const reason = it.reason || '';
    const rid    = it.recycleId || `${kind}_${idx}`;

    return `
  <div class="p-3 border rounded bg-gray-50">
    <div class="flex items-start gap-3">
      <input 
        type="checkbox" 
        class="recycle-select h-4 w-4 mt-1"
        data-id="${rid}"
      />

      <div class="flex-1 min-w-0">
        <div class="font-semibold truncate">${label}</div>
        <div class="text-[11px] text-gray-500">
          ${type ? type + ' â€¢ ' : ''} ${when}
        </div>
        ${
          reason
            ? `<div class="text-[11px] text-gray-400 italic mt-1">${reason}</div>`
            : ''
        }
      </div>
    </div>

    <div class="flex gap-2 mt-3">
      <button
        class="text-xs px-2 py-1 border rounded hover:bg-gray-100"
        onclick="openRecycleView('${rid}','${kind}')"
      >
        View
      </button>

      <button
        class="text-xs px-2 py-1 border rounded text-emerald-700 hover:bg-emerald-50"
        onclick="restoreRecycleItem('${rid}','${kind}')"
      >
        Restore
      </button>
    </div>
  </div>
`;

  }).join('');
}

// === Recycle Bulk Selection Helpers ===
function getCheckedRecycleIds(kind) {
  const selector =
    kind === 'user'
      ? '#recycleUserList .recycle-select:checked'
      : '#recycleSystemList .recycle-select:checked';

  return Array.from(document.querySelectorAll(selector))
    .map(cb => cb.dataset.id);
}

async function bulkDeleteRecycle(kind) {
  const ids = getCheckedRecycleIds(kind);
  if (!ids.length) {
    showMessage('Please select at least one item to delete.', 'Recycle Bin');
    return;
  }

  const confirmMsg =
    'Permanently delete selected items from Recycle Bin?<br><br>' +
    '<b>This cannot be undone.</b>';

  const yes = await appConfirm(confirmMsg);
  if (!yes) return;

  const key  = (kind === 'user') ? RECYCLE_USER_KEY : RECYCLE_SYSTEM_KEY;
  const list = loadFromLS(key, []) || [];

  const remaining = list.filter(entry =>
    !ids.includes(String(entry.recycleId))
  );

  saveToLS(key, remaining);

  renderRecycleList('user');
  renderRecycleList('system');

  

  if (typeof autoSaveDrive === 'function' && window.accessToken) {
    try { autoSaveDrive('recycle bulk delete'); } catch (e) {}
  }

  showMessage('Selected items deleted from Recycle Bin.', 'Recycle Bin');
}


function findRecycleEntry(kind, recycleId) {
  const key  = (kind === 'user') ? RECYCLE_USER_KEY : RECYCLE_SYSTEM_KEY;
  const list = loadFromLS(key, []) || [];
  const idx  = list.findIndex(it => it.recycleId === recycleId);
  return { key, list, idx };
}

function openRecycleView(recycleId, kind) {
  const { list, idx } = findRecycleEntry(kind, recycleId);
  if (idx === -1) {
    showMessage('Could not find this recycle entry. It may have been restored already.', 'Recycle Bin');
    return;
  }
  const it = list[idx];

  const typeRaw = String(it.type || it.kind || '').toLowerCase();
  let title;
  if (typeRaw.includes('invoice')) {
    title = 'Invoice (Recycle Bin)';
  } else if (typeRaw.includes('quotation')) {
    title = 'Quotation (Recycle Bin)';
  } else {
    title = 'Recycle Item';
  }

  let html = '<div class="text-sm space-y-1">';
  html += `<div><strong>Label:</strong> ${it.label || '-'}</div>`;
  if (it.clientName)    html += `<div><strong>Client:</strong> ${it.clientName}</div>`;
  if (it.clientContact) html += `<div><strong>Contact:</strong> ${it.clientContact}</div>`;
  if (it.invoiceNo)     html += `<div><strong>Invoice No:</strong> ${it.invoiceNo}</div>`;
  if (it.quotationNo)   html += `<div><strong>Quotation No:</strong> ${it.quotationNo}</div>`;
  if (it.removedAt)     html += `<div><strong>Removed at:</strong> ${new Date(it.removedAt).toLocaleString()}</div>`;
  if (it.reason)        html += `<div><strong>Reason:</strong> ${it.reason}</div>`;
  html += '</div>';

  showMessage(html, title);
}

async function restoreRecycleItem(recycleId, kind) {
  const { key, list, idx } = findRecycleEntry(kind, recycleId);
  if (idx === -1) {
    showMessage(
      'Could not find this recycle entry. It may have been restored already.',
      'Restore'
    );
    return;
  }

  const entry   = list[idx];
  const typeRaw = String(entry.type || entry.kind || '').toLowerCase();

  try {
    // âœ… handle client-request restore
    if (typeRaw.includes('client-request')) {
      const rowIndex = Number(entry.rowIndex || 0);
      const payload  = entry.payload || null;

      if (!rowIndex || !payload) {
        showMessage(
          'Cannot restore this client request â€“ missing row index or payload.',
          'Restore'
        );
        return;
      }

      // 1) Tell Google Sheet to set status back to "pending"
      try {
        fetch(CLIENT_REQ_API_URL, {
          method: 'POST',
          // keep it a "simple" POST (no preflight)
          body: JSON.stringify({
            _action: 'restorePending',
            rowIndex
          })
        });
      } catch (e) {
        console.warn('Failed to restore client request status in sheet', e);
        // still continue with local restore
      }

      // 2) Remove from recycle store
      list.splice(idx, 1);
      saveToLS(key, list);

      // 3) Refresh recycle lists & floating client-requests UI
      try { renderRecycleList('user'); }   catch (e) { console.warn(e); }
      try { renderRecycleList('system'); } catch (e) { console.warn(e); }
      try {
        if (typeof refreshClientRequestsUI === 'function') {
          refreshClientRequestsUI();
        }
      } catch (e) {
        console.warn('Failed to refresh client-requests UI after restore', e);
      }

      showMessage('Client request restored back to pending list.', 'Restore');
      return;
    }

    // ---------- Restore for invoices / quotations with dedupe ----------

    const original = entry.original;
    if (!original) {
      showMessage(
        'Cannot restore: original data is missing for this item.',
        'Restore'
      );
      return;
    }

    if (typeRaw.includes('invoice')) {
      const invoices = loadFromLS(SAVED_INVOICES_KEY, []) || [];

      const newId      = original.invoiceId || original.id;
      const keyName    = (original.clientName || '').trim().toLowerCase();
      const keyContact = (original.clientContact || '').trim().toLowerCase();
      const keyInvNo   = (original.invoiceNo || '').trim().toLowerCase();

      const duplicate = invoices.find(inv => {
        if (!inv) return false;

        const existId = inv.invoiceId || inv.id;
        const idMatch = newId && existId && String(existId) === String(newId);

        const invName    = (inv.clientName || '').trim().toLowerCase();
        const invContact = (inv.clientContact || '').trim().toLowerCase();
        const clientMatch =
          keyName && keyContact &&
          invName === keyName &&
          invContact === keyContact;

        const existNo = (inv.invoiceNo || '').trim().toLowerCase();
        const noMatch =
          keyInvNo && existNo && existNo === keyInvNo;

        return idMatch || clientMatch || noMatch;
      });

      if (duplicate) {
        if (typeof appConfirm === 'function') {
          const goEdit = await appConfirm(
            'An invoice already exists in Files for this client & contact.\n\n' +
            'Open the existing invoice instead of restoring this deleted copy?'
          );

          if (goEdit) {
            const existingId = duplicate.invoiceId || duplicate.id;
            CURRENT_EDIT_INVOICE_ID = existingId;
            try {
              localStorage.setItem(
                'CURRENT_EDIT_INVOICE',
                JSON.stringify(duplicate)
              );
            } catch (e) {
              console.warn('Failed to store CURRENT_EDIT_INVOICE', e);
            }
            if (typeof navigate === 'function') {
              navigate('invoice');
            }
          } else {
            showMessage(
              'Restore cancelled. Existing invoice kept in Files.',
              'Restore invoice'
            );
          }
        } else {
          showMessage(
            'Another invoice with same ID / number / client already exists. Restore cancelled.',
            'Restore invoice'
          );
        }
        return;
      }

      // âœ… No duplicate â†’ restore invoice
      invoices.push(original);
      saveToLS(SAVED_INVOICES_KEY, invoices);

    } else if (typeRaw.includes('quotation')) {
      const quotations = loadFromLS(SAVED_QUOTATIONS_KEY, []) || [];

      const newId      = original.id || original.quotationId;
      const nameKey    = (original.clientName || '').trim().toLowerCase();
      const contactKey = (original.clientContact || '').trim().toLowerCase();

      const duplicateQ = quotations.find(q => {
        if (!q) return false;

        const sameId = newId && String(q.id) === String(newId);

        const qName    = (q.clientName || '').trim().toLowerCase();
        const qContact = (q.clientContact || '').trim().toLowerCase();
        const sameClient =
          nameKey && contactKey &&
          qName === nameKey &&
          qContact === contactKey;

        return sameId || sameClient;
      });

      if (duplicateQ) {
        if (typeof appConfirm === 'function') {
          const go = await appConfirm(
            'Duplicate Quotation found for this Client name and Contact.\n\n' +
            'Do you want to open & edit that Quotation instead of restoring this deleted copy?'
          );

          if (go) {
            try {
              localStorage.setItem(
                'CURRENT_EDIT_QUOTATION',
                JSON.stringify(duplicateQ)
              );
            } catch (e) {
              console.warn('Failed to store CURRENT_EDIT_QUOTATION', e);
            }
            if (typeof navigate === 'function') {
              navigate('quotation', { skipInit: false });
            }
          } else {
            showMessage(
              'Restore cancelled. Existing quotation kept in Files.',
              'Restore quotation'
            );
          }
        } else {
          showMessage(
            'Duplicate quotation already exists for this client & contact. Restore cancelled.',
            'Restore quotation'
          );
        }
        return;
      }

      // âœ… No duplicate â†’ restore quotation
      quotations.push(original);
      saveToLS(SAVED_QUOTATIONS_KEY, quotations);

    } else {
      showMessage(
        'Restore is currently supported only for quotations, invoices and client requests.',
        'Restore'
      );
      return;
    }

    // Remove from recycle list after successful restore
    list.splice(idx, 1);
    saveToLS(key, list);

    // Refresh recycle + files UI
    renderRecycleList('user');
    renderRecycleList('system');
    if (typeof renderFilesList === 'function') {
      renderFilesList();
    }

    if (typeof autoSaveDrive === 'function' && window.accessToken) {
      try { autoSaveDrive('restore from recycle'); } catch (e) { console.warn(e); }
    }

    showMessage('Item restored back to Files.', 'Restore');
  } catch (e) {
    console.error(e);
    showMessage('Restore failed. See console for details.', 'Error');
  }
}




function loadRecycleUI() {
  
  // Bind filters only once
  if (!RECYCLE_FILTERS_BOUND) {
    ['user', 'system'].forEach((kind) => {
      const typeSelId = (kind === 'user') ? 'recycleUserType'   : 'recycleSystemType';
      const nameId    = (kind === 'user') ? 'recycleUserName'   : 'recycleSystemName';
      const dateId    = (kind === 'user') ? 'recycleUserDate'   : 'recycleSystemDate';

      const typeSel = document.getElementById(typeSelId);
      const nameInp = document.getElementById(nameId);
      const dateInp = document.getElementById(dateId);

      if (typeSel) typeSel.addEventListener('change', () => renderRecycleList(kind));
      if (nameInp) nameInp.addEventListener('input', () => renderRecycleList(kind));
      if (dateInp) dateInp.addEventListener('input', () => renderRecycleList(kind));
    });

    // -------------------------------------------------
  // ===== RECYCLE BIN: Select-all + bulk delete =====
  // -------------------------------------------------
  const recycleUserSelectAll = document.getElementById('recycleUserSelectAll');
  if (recycleUserSelectAll) {
    recycleUserSelectAll.addEventListener('change', (e) => {
      const checked = e.target.checked;
      document
        .querySelectorAll('#recycleUserList .recycle-select')
        .forEach(cb => cb.checked = checked);
    });
  }

  const recycleSystemSelectAll = document.getElementById('recycleSystemSelectAll');
  if (recycleSystemSelectAll) {
    recycleSystemSelectAll.addEventListener('change', (e) => {
      const checked = e.target.checked;
      document
        .querySelectorAll('#recycleSystemList .recycle-select')
        .forEach(cb => cb.checked = checked);
    });
  }

  const recycleUserBulkDelete = document.getElementById('recycleUserBulkDelete');
  if (recycleUserBulkDelete) {
    recycleUserBulkDelete.addEventListener('click', () => {
      bulkDeleteRecycle('user');
    });
  }

  const recycleSystemBulkDelete = document.getElementById('recycleSystemBulkDelete');
  if (recycleSystemBulkDelete) {
    recycleSystemBulkDelete.addEventListener('click', () => {
      bulkDeleteRecycle('system');
    });
  }

    RECYCLE_FILTERS_BOUND = true;
  }

  // Initial render
  renderRecycleList('user');
  renderRecycleList('system');
  switchRecycleTab('user');
}


function matchesDateFilter(file, filterStr) {
  if (!filterStr) return true; // no filter -> match all

  filterStr = filterStr.trim();
  const fileDate = getFileDate(file);
  if (isNaN(fileDate)) return false;

  // 1) Year only: 2025
  const yearMatch = filterStr.match(/^(\d{4})$/);
  if (yearMatch) {
    const year = Number(yearMatch[1]);
    return fileDate.getFullYear() === year;
  }

  // 2) Month + Year: 11-2025 or 11/2025
  const monthYearMatch = filterStr.match(/^(\d{1,2})[-/](\d{4})$/);
  if (monthYearMatch) {
    const month = Number(monthYearMatch[1]); // 1â€“12
    const year = Number(monthYearMatch[2]);
    return (
      fileDate.getFullYear() === year &&
      fileDate.getMonth() + 1 === month
    );
  }

  // 3) Full date: DD-MM-YYYY or DD/MM/YYYY
  const fullDMY = filterStr.match(/^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/);
  if (fullDMY) {
    const day = Number(fullDMY[1]);
    const month = Number(fullDMY[2]) - 1; // JS month 0â€“11
    const year = Number(fullDMY[3]);

    return (
      fileDate.getFullYear() === year &&
      fileDate.getMonth() === month &&
      fileDate.getDate() === day
    );
  }

  // 4) Fallback: ISO date from old <input type="date"> (YYYY-MM-DD)
  const iso = filterStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (iso) {
    const [_, y, m, d] = iso;
    const fileIso = fileDate.toISOString().slice(0, 10);
    return fileIso === `${y}-${m}-${d}`;
  }

  // If format not recognized -> no match
  return false;
}

function renderFilesList() {
  const quotations = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const invoices   = loadFromLS(SAVED_INVOICES_KEY, []);

  const searchQuery = (document.getElementById('filesSearch')?.value || '')
    .trim()
    .toLowerCase();

  const dateFilterRaw =
    (document.getElementById('filesDate')?.value || '').trim();

  const statusFilter =
    (document.getElementById('paymentStatusFilter')?.value || 'all')
      .toLowerCase();

  // Reuse the flexible date filter you already had
  function matchesDateFilter(file, filterStr) {
    if (!filterStr) return true;

    const d = getFileDate(file); // uses global getFileDate()
    if (!d || isNaN(d.getTime())) return false;

    const year  = d.getFullYear();
    const month = d.getMonth() + 1;
    const day   = d.getDate();

    const iso = d.toISOString().slice(0, 10);

    const f = filterStr.trim();

    // 1) Year only: 2025
    if (/^\d{4}$/.test(f)) {
      return year === Number(f);
    }

    // 2) Month + Year: 11-2025 or 11/2025
    if (/^\d{1,2}[-/]\d{4}$/.test(f)) {
      const parts = f.split(/[-/]/);
      const fMonth = Number(parts[0]);
      const fYear  = Number(parts[1]);
      return year === fYear && month === fMonth;
    }

    // 3) Full date: DD-MM-YYYY or DD/MM/YYYY
    if (/^\d{1,2}[-/]\d{1,2}[-/]\d{4}$/.test(f)) {
      const parts = f.split(/[-/]/);
      const fDay   = Number(parts[0]);
      const fMonth = Number(parts[1]);
      const fYear  = Number(parts[2]);
      return year === fYear && month === fMonth && day === fDay;
    }

    // 4) Old date input style: YYYY-MM-DD
    if (/^\d{4}-\d{2}-\d{2}$/.test(f)) {
      return iso === f;
    }

    // Unknown format -> don't filter by date
    return true;
  }

  function recordMatchesDate(created) {
    if (!dateFilterRaw) return true;
    if (!created) return false;
    return matchesDateFilter({ date: created.toISOString() }, dateFilterRaw);
  }

  // ---------- Quotations ----------
  const qList = document.getElementById('filesList');
  qList.innerHTML = '';
  let foundQ = 0;

  quotations.slice().reverse().forEach(q => {
    const created = q.createdAt ? new Date(q.createdAt) : null;

    // Date filter
    if (!recordMatchesDate(created)) return;

    // Client name filter
    if (
      searchQuery &&
      !(String(q.clientName || '').toLowerCase().includes(searchQuery))
    ) return;

    foundQ++;

    const item = document.createElement('div');
    item.className = 'file-item';

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `
      <input type="checkbox"
             class="file-select quote-select"
             data-id="${q.id}"
             style="width:18px;height:18px;margin-right:8px" />
      <div>
        <div class="font-semibold">${q.clientName || 'Unnamed'}</div>
        <div class="text-xs text-gray-500">
          ${created ? created.toLocaleString() : 'No date'}
        </div>
      </div>
    `;

    // right side: "View" button (same viewer as calendar popup)
    const actions = document.createElement('div');
    actions.innerHTML = `
      <button
        class="py-1 px-2 rounded border text-sm"
        onclick="openQuotationViewerById('${q.id}')">
        View
      </button>
    `;

    item.appendChild(meta);
    item.appendChild(actions);
    qList.appendChild(item);
  });

  document
    .getElementById('filesEmpty')
    .classList.toggle('hidden', foundQ > 0);

  // ---------- Invoices ----------
  const invList = document.getElementById('invoicesList');
  invList.innerHTML = '';
  let foundI = 0;

  invoices.slice().reverse().forEach(inv => {
    const created = inv.createdAt ? new Date(inv.createdAt) : null;

    // Date filter
    if (!recordMatchesDate(created)) return;

    // Client name filter
    if (
      searchQuery &&
      !(String(inv.clientName || '').toLowerCase().includes(searchQuery))
    ) return;

    foundI++;

    const item = document.createElement('div');

    const status = String(inv.status || '').toLowerCase();
    const isVoid      = status === 'void';
    const isValidated = status === 'valid-from-void';   // orange

    // background colour
    item.className =
      'file-item' +
      (isVoid ? ' bg-red-50'
              : isValidated ? ' bg-green-50'
                            : '');

    const meta = document.createElement('div');
    meta.className = 'meta';

    const idForInvoice = inv.invoiceId || inv.id;

    meta.innerHTML = `
      <input type="checkbox"
             class="invoice-select"
             data-id="${idForInvoice}"
             style="width:18px;height:18px;margin-right:8px" />
      <div>
        <div class="font-semibold ${
          isVoid ? 'text-red-600'
                 : isValidated ? 'text-green-600'
                               : ''
        }">
          ${inv.clientName || 'Unnamed'}
          ${
            isVoid
              ? '<span class="ml-2 text-xs font-bold px-1.5 py-0.5 rounded bg-red-100 text-red-700 align-middle">VOID</span>'
              : isValidated
              ? '<span class="ml-2 text-xs font-bold px-1.5 py-0.5 rounded bg-green-100 text-green-900 align-middle">VALID</span>'
              : ''
          }
        </div>
        <div class="text-xs text-gray-500">
          ${created ? created.toLocaleString() : 'No date'}
        </div>
      </div>
    `;

    // right side: "View" button for invoices
    const actions = document.createElement('div');
    actions.innerHTML = `
      <button
        class="py-1 px-2 rounded border text-sm"
        onclick="openInvoiceViewerById('${idForInvoice}')">
        View
      </button>
    `;

    item.appendChild(meta);
    item.appendChild(actions);
    invList.appendChild(item);
  });

  document
    .getElementById('invoicesEmpty')
    .classList.toggle('hidden', foundI > 0);

  // ---------- Payment Info (Invoices with status) ----------
  const pList = document.getElementById('paymentsList');
  if (pList) {
    pList.innerHTML = '';
    let foundP = 0;

    function computePaymentStatus(inv) {
      // 1) If you later store explicit status on invoice, respect it
      const raw = String(inv.paymentStatus || inv.statusPayment || '').toLowerCase();
      if (raw === 'pending') return 'Pending';
      if (raw === 'partial' || raw === 'partial paid') return 'Partial paid';
      if (raw === 'completed' || raw === 'complete') return 'Paid';

      // 2) Else derive from amounts â€“ this will start working
      //    once you store advance/final paid on the invoice object.
      const billed   = Number(inv.final || inv.actual || 0) || 0;
      const advance  = Number(inv.advancePaid || inv.paymentAdvance || 0) || 0;
      const finalPd  = Number(inv.finalPaid   || inv.paymentFinal   || 0) || 0;
      const totalPaid = advance + finalPd;

      if (!billed) return 'Pending';
      if (totalPaid <= 0) return 'Pending';
      if (totalPaid + 0.01 < billed) return 'Partial paid';
      return 'Completed';
    }

    invoices.slice().reverse().forEach(inv => {
      const created = inv.createdAt ? new Date(inv.createdAt) : null;

      // Date filter
      if (!recordMatchesDate(created)) return;

      // Combined search on name, contact, ids
      if (searchQuery) {
        const hay = [
          inv.clientName,
          inv.clientContact,
          inv.invoiceId,
          inv.invoiceNo
        ]
          .filter(Boolean)
          .join(' ')
          .toLowerCase();

        if (!hay.includes(searchQuery)) return;
      }

      const statusLabel = computePaymentStatus(inv);
      const statusKey =
        statusLabel.toLowerCase().startsWith('partial')
          ? 'partial'
          : statusLabel.toLowerCase();

      if (statusFilter !== 'all' && statusKey !== statusFilter) return;

      foundP++;

      const item = document.createElement('div');
      item.className = 'file-item';

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `
        <div>
          <div class="font-semibold">${inv.clientName || 'Unnamed'}</div>
          <div class="text-xs text-gray-500">
            ${created ? created.toLocaleString() : 'No date'}
          </div>
          <div class="mt-1 text-[11px]">
            <span class="inline-block px-2 py-0.5 rounded-full text-[11px] ${
              statusKey === 'completed' || statusKey === 'paid'
                ? 'bg-green-100 text-green-700'
                : statusKey === 'partial'
                ? 'bg-yellow-100 text-yellow-700'
                : 'bg-red-100 text-red-700'
            }">
              ${statusLabel}
            </span>
          </div>
        </div>
      `;

      const actions = document.createElement('div');
      const idForInvoice = inv.invoiceId || inv.id;

      actions.innerHTML = `
        <button
          class="py-1 px-2 rounded border text-sm"
          onclick="openPaymentInfoForInvoiceId('${idForInvoice}')">
          View
        </button>
      `;

      item.appendChild(meta);
      item.appendChild(actions);
      pList.appendChild(item);
    });

    const emptyP = document.getElementById('paymentsEmpty');
    if (emptyP) {
      emptyP.classList.toggle('hidden', foundP > 0);
    }
  }
}



// Healper-function
function getCheckedQuoteIds() {
  return Array.from(
    document.querySelectorAll('#filesList .quote-select:checked')
  ).map(cb => cb.dataset.id);
}

function getCheckedInvoiceIds() {
  return Array.from(
    document.querySelectorAll('#invoicesList .invoice-select:checked')
  ).map(cb => cb.dataset.id);
}

// Convert yyyy-mm-dd or dd/mm/yyyy to dd-MMM-yyyy
function formatDateShortMonth(dateStr) {
  if (!dateStr) return "";

  // Format already like dd/mm/yyyy or dd-mm-yyyy
  if (/^\d{2}[\/-]\d{2}[\/-]\d{4}$/.test(dateStr)) {
    const parts = dateStr.includes("/") ? dateStr.split("/") : dateStr.split("-");
    const d = parts[0], m = parts[1], y = parts[2];
    return `${d}-${getShortMonth(m)}-${y}`;
  }

  // Format yyyy-mm-dd (ISO)
  const parts = dateStr.split("-");
  if (parts.length === 3) {
    return `${parts[2]}-${getShortMonth(parts[1])}-${parts[0]}`;
  }

  return dateStr;
}

function getShortMonth(m) {
  const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  const index = parseInt(m, 10) - 1;
  return months[index] || m;
}





// --- NEW table-style PDF generator with DOM pagination ---
// Keeps letterhead background + proper tables + Event headers
async function createPdfBlobFromQuotation(q) {
  if (!q) throw new Error("No quotation data");

  // Decide which letterhead to use
  const layoutKey = (q && (q.invoiceId || q.invoiceId === 0))
    ? INVOICE_LAYOUT_KEY
    : QUOTATION_LAYOUT_KEY;
  const layoutData = localStorage.getItem(layoutKey) || "";

  function normalizePhone(contact) {
  // Keep digits only: "+91 98765-43210" -> "919876543210"
  return (contact || '').replace(/\D+/g, '');
}

  // ---- helpers for amounts ----
  function indianFormat(num) {
    const x = Number(num || 0);
    if (!x) return "0";
    const str = Math.round(x).toString();
    if (str.length <= 3) return str;
    const last3 = str.slice(-3);
    const rest = str.slice(0, -3);
    const formattedRest = rest.replace(/\B(?=(\d{2})+(?!\d))/g, ",");
    return formattedRest + "," + last3;
  }

  function fmtPriceForDetailRow(num) {
    const n = Number(num || 0);
    if (!n) return "-NA-";
    return "Rs. " + indianFormat(n);
  }

  function fmtPrice(num) {
    const n = Number(num || 0);
    if (!n) return "";
    return "Rs. " + indianFormat(n);
  }

  // ---- create a full A4 page with letterhead + content box ----
  function createPdfPage(isFirstPage) {
    const page = document.createElement("div");
    page.className = "pdf-page";

    // A4 at 96dpi: 794 x 1123
    page.style.width = "794px";
    page.style.height = "1123px";
    page.style.position = "relative";
    page.style.boxSizing = "border-box";
    page.style.overflow = "hidden";
    page.style.backgroundColor = "#ffffff";

    if (layoutData) {
      page.style.backgroundImage = `url(${layoutData})`;
      page.style.backgroundSize = "cover";
      page.style.backgroundRepeat = "no-repeat";
      page.style.backgroundPosition = "top left";
    }

    const content = document.createElement("div");
    content.className = "pdf-content";

    // first page: more top gap; other pages: slightly smaller top gap
    content.style.position = "absolute";
    content.style.top = isFirstPage ? "265px" : "225px";
    content.style.left = "30px";
    content.style.right = "30px";
    content.style.bottom = "40px";   // bottom margin
    content.style.padding = "20px 25px";
    content.style.background = "transparent";
    content.style.boxSizing = "border-box";
    content.style.fontFamily = "sans-serif";
    content.style.fontSize = "13px";

    page.appendChild(content);
    return { page, content };
  }

  // ---- build individual BLOCKS (tables) as DOM nodes ----
  const tableStyle =
    "width:100%;border-collapse:collapse;border:1px solid #000;margin-bottom:14px;font-size:13px;background:transparent;";
  const tdLabelStyle =
    "border:1px solid #000;padding:6px 8px;width:28%;vertical-align:top;word-wrap:break-word;white-space:normal;text-align:left;background:transparent;";
  const tdValueStyle =
    "border:1px solid #000;padding:6px 8px;width:47%;vertical-align:middle;word-wrap:break-word;white-space:normal;text-align:center;background:transparent;";
  const tdPriceStyle =
    "border:1px solid #000;padding:6px 8px;width:25%;vertical-align:middle;word-wrap:break-word;white-space:normal;text-align:right;font-weight:bold;background:transparent;";

  function makeBlock(html) {
    const wrap = document.createElement("div");
    wrap.innerHTML = html.trim();
    return wrap.firstElementChild;
  }

  const blocks = [];

  // ---------- 1) CLIENT DETAILS TABLE ----------
  const clientTableHTML = `
    <table style="${tableStyle}">
      <tr>
        <td style="${tdLabelStyle}; font-size:16px;">Client Name</td>
        <td colspan="2" style="${tdValueStyle}">
          <span style="color:#4f0202; font-weight:bold; font-size:16px;">
            ${(q.clientName || "").toString().replace(/</g, "&lt;")}
          </span>
        </td>
      </tr>
      <tr>
        <td style="${tdLabelStyle}; font-size:16px;">Client Contact</td>
        <td colspan="2" style="${tdValueStyle}">
          <span style="color:#4f0202; font-weight:bold; font-size:16px;">
            ${(q.clientContact || "").toString().replace(/</g, "&lt;")}
          </span>
        </td>
      </tr>
    </table>
  `;
  blocks.push(makeBlock(clientTableHTML));

  // ---------- 2) EVENT TABLE(S) ----------
  const events = Array.isArray(q.events) ? q.events : [];
  events.forEach((ev, index) => {
    const eName       = (ev.name        || "").toString();
    const eDate       = (ev.date        || "").toString();
    const displayDate = formatDateShortMonth(eDate);
    const eTime       = (ev.time        || "").toString();
    const eLocation   = (ev.location    || "").toString();
    const eNotes      = (ev.notes       || "").toString();
    const pkgName     = (ev.packageName || "").toString();
    const addonData   = (ev.addonDetails|| "").toString();

    const pkgPrice       = Number(ev.packagePrice   || 0);
    const addOnPrice     = Number(ev.addOnPrice     || 0);
    const transportPrice = Number(ev.transportPrice || 0);

    // header "Event - N"
    const eventHeader = document.createElement("div");
    eventHeader.style.fontWeight = "bold";
    eventHeader.style.fontSize = "15px";
    eventHeader.style.margin = "10px 0 6px 2px";
    eventHeader.textContent = `Event - ${index + 1}`;

    let html = `<table style="${tableStyle}">`;

  // Row 1: Event Name - Haldi Ceremony
html += `
  <tr>
    <td style="${tdLabelStyle}">Event Name</td>
    <td colspan="2" style="${tdValueStyle} color:black; font-weight:bold; font-size:16px;">
      ${eName.replace(/</g,"&lt;")}
    </td>
  </tr>
`;

// Row 2: Package Selected - Photography  + price
html += `
  <tr>
    <td style="${tdLabelStyle}">Package Selected</td>
    <td style="${tdValueStyle} font-weight:bold;">
      ${pkgName.replace(/</g,"&lt;")}
    </td>
    <td style="${tdPriceStyle}; text-align:right;">
      ${fmtPriceForDetailRow(pkgPrice)}
    </td>
  </tr>
`;

    // Date & Time row (no price here)
    html += `
      <tr>
        <td style="${tdLabelStyle}">Date &amp; Time</td>
        <td colspan="2" style="${tdValueStyle}">
          ${(displayDate || "-")}${
            eTime ? (" | " + eTime.replace(/</g,"&lt;")) : ""
          }
        </td>        
      </tr>
    `;

    // Location row (right column = transport price)
    if (eLocation.trim() !== "") {
      html += `
        <tr>
          <td style="${tdLabelStyle}">Location</td>
          <td style="${tdValueStyle}">
            ${eLocation.replace(/</g,"&lt;")}
          </td>
          <td style="${tdPriceStyle}">
            ${fmtPriceForDetailRow(transportPrice)}
          </td>
        </tr>
      `;
    }

    // Add-ons (details + price)
    if (addonData || addOnPrice) {
      html += `
        <tr>
          <td style="${tdLabelStyle}">Add-ons</td>
          <td style="${tdValueStyle}">
            ${addonData.replace(/</g,"&lt;")}
          </td>
          <td style="${tdPriceStyle}">
            ${fmtPriceForDetailRow(addOnPrice)}
          </td>
        </tr>
      `;
    }

    // Notes / Complimentary
    if (eNotes.trim() !== "") {
      html += `
        <tr>
          <td style="${tdLabelStyle}">Notes &amp; Complimentary</td>
          <td colspan="2" style="${tdValueStyle}">
            ${eNotes.replace(/</g,"&lt;")}
          </td>
        </tr>
      `;
    }

    html += `</table>`;

    // Wrap header + table together so they move as one block
    const eventBlock = document.createElement("div");
    eventBlock.appendChild(eventHeader);
    eventBlock.appendChild(makeBlock(html));

    blocks.push(eventBlock);
  });

  // ---------- 3) PRICE SUMMARY (title + table as one block) ----------
  const actual   = Number(q.actual   || 0);
  const discount = Number(q.discount || 0);
  const finalAmt = Number(q.final    || 0);
  const isInvoice = !!(q && (q.invoiceId || q.invoiceId === 0));

  const summaryTitle = document.createElement("div");
  summaryTitle.style.fontWeight = "bold";
  summaryTitle.style.fontSize = "15px";
  summaryTitle.style.margin = "10px 0 6px 2px";
  summaryTitle.textContent = isInvoice ? "Invoice Summary" : "Quotation Summary";

  let summaryHTML = `<table style="${tableStyle}">`;
  if (discount > 0) {
    summaryHTML += `
      <tr>
        <td style="${tdLabelStyle}; color:#a3294e; font-weight:bold; font-size:20px; text-align:center">
          Actual Price
          </td>
        <td style="${tdPriceStyle}; color:#a3294e; font-weight:bold; font-size:20px; text-align:center">
          ${fmtPrice(actual)}
          </td>
      </tr>
      <tr>
        <td style="${tdLabelStyle}; color:#e80e0e; font-weight:bold; font-size:20px; text-align:center">
          Discount
          </td>
        <td style="${tdPriceStyle}; color:#e80e0e; font-weight:bold; font-size:20px; text-align:center">
          ${fmtPrice(discount)}
          </td>
      </tr>
    `;
  }
  summaryHTML += `
    <tr>
      <td style="${tdLabelStyle}; color:#227316; font-weight:bold; font-size:20px; text-align:center">
        Final Price
        </td>      
      <td style="${tdPriceStyle}; color:#227316; font-weight:bold; font-size:20px; text-align:center">
        ${fmtPrice(finalAmt)}
        </td>
    </tr>
  `;
  summaryHTML += `</table>`;

  const summaryBlock = document.createElement("div");
  summaryBlock.appendChild(summaryTitle);
  summaryBlock.appendChild(makeBlock(summaryHTML));
  blocks.push(summaryBlock);

  // ---- Build paginated pages in an off-screen root ----
  const root = document.createElement("div");
  root.style.position = "fixed";
  root.style.left = "-99999px";
  root.style.top = "0";
  root.style.zIndex = "999999";
  root.style.width = "794px";
  root.style.boxSizing = "border-box";
  document.body.appendChild(root);

  let current = createPdfPage(true);
  let currentPage = current.page;
  let currentContent = current.content;
  root.appendChild(currentPage);

  function contentMaxHeight() {
    // how tall the content area can be
    return currentContent.clientHeight || currentContent.offsetHeight || 0;
  }

  blocks.forEach(block => {
    currentContent.appendChild(block);
    const maxH = contentMaxHeight();
    if (currentContent.scrollHeight > maxH + 1) {
      // doesnâ€™t fit â†’ move block to next page
      currentContent.removeChild(block);
      const next = createPdfPage(false);
      currentPage = next.page;
      currentContent = next.content;
      root.appendChild(currentPage);
      currentContent.appendChild(block);
    }
  });

  try {
    // ---- Capture each page with html2canvas and add to jsPDF ----
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF("p", "pt", "a4");

    const pageEls = Array.from(root.querySelectorAll(".pdf-page"));
    const HTML2CANVAS_SCALE = 2;

    for (let i = 0; i < pageEls.length; i++) {
      const pageEl = pageEls[i];

      // let layout settle
      // eslint-disable-next-line no-await-in-loop
      await new Promise(r => requestAnimationFrame(r));

      // eslint-disable-next-line no-await-in-loop
      const canvas = await html2canvas(pageEl, {
        scale: HTML2CANVAS_SCALE,
        useCORS: true,
        allowTaint: true,
        logging: false,
        backgroundColor: "#ffffff"
      });

      const imgData = canvas.toDataURL("image/jpeg", 0.95);
      const pw = pdf.internal.pageSize.getWidth();
      const ph = pdf.internal.pageSize.getHeight();

      if (i > 0) pdf.addPage();
      pdf.addImage(imgData, "JPEG", 0, 0, pw, ph);
    }

    const blob = pdf.output("blob");
    root.remove();
    return blob;

  } catch (err) {
    console.error("createPdfBlobFromQuotation (DOM pagination) error:", err);
    root.remove();
    throw err;
  }
}

function formatDocDateTimeForFilename(doc) {
  if (!doc) return "Unknown";

  const raw = doc.createdAt || doc.date || new Date().toISOString();
  const d = new Date(raw);

  if (isNaN(d.getTime())) return "Unknown";

  const dd = String(d.getDate()).padStart(2, "0");
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const yyyy = d.getFullYear();
  const hh = String(d.getHours()).padStart(2, "0");
  const mi = String(d.getMinutes()).padStart(2, "0");

  // Example: 07-12-2025 14.30  (no ':' to keep filenames safe)
  return `${dd}-${mm}-${yyyy} ${hh}.${mi}`;
}

async function exportQuotationPDF(q) {
  try {
    const blob = await createPdfBlobFromQuotation(q);
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;

    const isInvoice = !!(q && (q.invoiceId || q.invoiceId === 0));
    const baseLabel = isInvoice ? "Invoice" : "Quotation";
    const clientName = (q.clientName || "").trim() || baseLabel;
    const dateTimeLabel = formatDocDateTimeForFilename(q);

    // Quotation - Client Name (Quotation Date & Time)
    // Invoice   - Client Name (Invoice Date & Time)
    a.download = `${baseLabel} - ${clientName} (${dateTimeLabel}).pdf`;

    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error(e);
    showMessage('Failed to create PDF.');
  }
}

// FILES â†’ Quotations actions (uses the new PDF generator)
async function handleFileAction(id, action) {
  const quotations = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const q = quotations.find(x => x.id === id);
  if (!q) {
    showMessage("Quotation not found.");
    return;
  }

  if (action === "download") {

    exportQuotationPDF(q);

  } else if (action === "share") {

    try {
      const blob = await createPdfBlobFromQuotation(q);
      const isInvoice = !!(q && (q.invoiceId || q.invoiceId === 0));
      const baseLabel = isInvoice ? "Invoice" : "Quotation";
      const clientName = (q.clientName || "").trim() || baseLabel;
      const dateTimeLabel = formatDocDateTimeForFilename(q);

      const file = new File(
        [blob],
        `${baseLabel} - ${clientName} (${dateTimeLabel}).pdf`,
        { type: "application/pdf" }
      );

      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: `${q.clientName} â€” Quotation`,
          text: `Quotation for ${q.clientName}`
        });
      } else if (navigator.share) {
        const url = URL.createObjectURL(file);
        await navigator.share({
          url,
          title: `${q.clientName} â€” Quotation`,
          text: `Quotation for ${q.clientName}`
        }).catch(() => {});
        URL.revokeObjectURL(url);
      } else {
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = `${baseLabel} - ${clientName} (${dateTimeLabel}).pdf`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

    } catch (err) {
      console.error(err);
      showMessage("Share failed; falling back to download.");
      try { exportQuotationPDF(q); } catch (e) {}
    }

  } else if (action === "generate_invoice") {

    try {
      const invoices = loadFromLS(SAVED_INVOICES_KEY, []);

      // ðŸ” DEDUPE: same client name + contact (case-insensitive)
      const keyName = (q.clientName || '').trim().toLowerCase();
      const keyContact = (q.clientContact || '').trim().toLowerCase();

      const duplicate = invoices.find(inv => {
        if (!inv) return false;
        const invName = (inv.clientName || '').trim().toLowerCase();
        const invContact = (inv.clientContact || '').trim().toLowerCase();
        return invName && invContact &&
               invName === keyName && invContact === keyContact;
      });

      if (duplicate) {
        const goEdit = confirm(
          'An invoice already exists in Files for this client & contact.\n\n' +
          'Open the existing invoice instead of generating a new one?'
        );

        if (goEdit) {
          const existingId = duplicate.invoiceId || duplicate.id;
          CURRENT_EDIT_INVOICE_ID = existingId;
          localStorage.setItem('CURRENT_EDIT_INVOICE', JSON.stringify(duplicate));
          navigate('invoice');
        }

        // âŒ no new invoice when duplicate found (even if user chose "No")
        return;
      }

      // âœ… No duplicate â†’ create fresh invoice
      const newInvoice = {
        ...q,
        invoiceId: "inv_" + Date.now() + "_" + Math.floor(Math.random() * 9999),
        createdAt: new Date().toISOString()
      };
      invoices.push(newInvoice);
      saveToLS(SAVED_INVOICES_KEY, invoices);
      renderFilesList();
      showMessage("Invoice generated and saved to Files â†’ Invoices.");
      switchFilesTab("invoices");

      // ðŸ” Auto-save to Drive (if signed in)
      if (typeof autoSaveDrive === 'function') {
        autoSaveDrive('invoice generated from files');
      }

    } catch (err) {
      console.error(err);
      showMessage("Failed to generate invoice.");
    }

  } else if (action === "edit") {   // <-- now correctly positioned

    CURRENT_EDIT_QUOTATION_ID = q.id;
    localStorage.setItem("CURRENT_EDIT_QUOTATION", JSON.stringify(q));
    navigate("quotation");

  }
}

// FILES â†’ Invoices actions (also uses the new generator)
async function handleInvoiceAction(invoiceId, action) {
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);
  const inv = invoices.find(x => (x.invoiceId === invoiceId) || (x.id === invoiceId));
  if (!inv) { showMessage("Invoice not found."); return; }

  if (action === "download") {

    exportQuotationPDF(inv);

  } else if (action === "share") {

    try {
      const blob = await createPdfBlobFromQuotation(inv);
      const baseLabel = "Invoice";
      const clientName = (inv.clientName || "").trim() || baseLabel;
      const dateTimeLabel = formatDocDateTimeForFilename(inv);

      const file = new File(
        [blob],
        `${baseLabel} - ${clientName} (${dateTimeLabel}).pdf`,
        { type: "application/pdf" }
      );

      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: `${inv.clientName} â€” Invoice`,
          text: `Invoice for ${inv.clientName}`
        });
      } else if (navigator.share) {
        const url = URL.createObjectURL(file);
        await navigator.share({
          url,
          title: `${inv.clientName} â€” Invoice`,
          text: `Invoice for ${inv.clientName}`
        }).catch(() => {});
        URL.revokeObjectURL(url);
      } else {
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = `${baseLabel} - ${clientName} (${dateTimeLabel}).pdf`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

    } catch (err) {
      console.error(err);
      showMessage("Share failed; falling back to download.");
      try { exportQuotationPDF(inv); }
      catch (e) { showMessage("Failed to download PDF."); }
    }

  } else if (action === "edit") {

    // enable edit mode
    CURRENT_EDIT_INVOICE_ID = inv.invoiceId || inv.id;
    localStorage.setItem("CURRENT_EDIT_INVOICE", JSON.stringify(inv));

    // navigate to invoice builder
    navigate("invoice");
  }
}

  

/* -------------------------
   Open quotation viewer by id (from calendar popup)
   ------------------------- */
function openQuotationViewerById(qid){
  const all = loadFromLS(SAVED_QUOTATIONS_KEY, []);
  const q = all.find(x => x.id === qid);
  if (!q) {
    showMessage('Quotation not found.');
    return;
  }

  const events = Array.isArray(q.events) ? q.events : [];

  // Compute totals safely (fallback if not stored)
  let actual = 0;
  if (typeof q.actual === 'number') {
    actual = q.actual;
  } else {
    actual = events.reduce((s, e) =>
      s +
      Number(e.packagePrice || 0) +
      Number(e.addOnPrice || 0) +
      Number(e.transportPrice || 0),
      0
    );
  }

  let discount = typeof q.discount === 'number' ? q.discount : 0;
  let final = typeof q.final === 'number' ? q.final : Math.max(0, actual - discount);

  let msg = "";

   // ---------------- HEADER -----------------
msg += `<b style="color:#0b5ed7; font-size:15px;">Client Name</b> : ${q.clientName || ''}<br>`;

const contactText = (q.clientContact || '').trim();
const contactEsc  = contactText.replace(/'/g, "\\'");  // for onclick string

// label
msg += `<b style="color:#0b5ed7;">Contact</b> : `;

// number + icon on the SAME line
if (contactText) {
  msg += `<span style="display:inline-flex;align-items:center;">${contactText}<i data-lucide="phone" class="w-4 h-4 text-blue-600 ml-1 cursor-pointer" onclick="openContactOptions('${contactEsc}')"></i></span>`;
} else {
  msg += `-`;
}

msg += `<br><br>`;


  // ---------------- TOTALS -----------------
msg += `<div style="margin:8px 0; padding:6px 8px; border:1px solid #ddd; border-radius:6px; background:#fafafa;"`; 

  msg += `<b style="color:#ba2121;">Actual Price</b> : <b>â‚¹${actual}</b><br>`;
  msg += `<b style="color:#ba2121;">Discount</b> : <b>â‚¹${discount}</b><br>`;
  msg += `<b style="color:#198754; font-size:15px;">Final Price</b> : <b>â‚¹${final}</b><br><br>`;
msg += `</div>`;

  // ---------------- EVENTS -----------------
  msg += `<b style="color:#6f42c1;">Events:</b><br>`;

  if (!events.length) {
    msg += `<i>(No events saved in this quotation)</i>`;
  } else {
    events.forEach((ev, idx) => {      
      
      msg += `<div style="margin:8px 0; padding:6px 8px; border:1px solid #ddd; border-radius:6px; background:#fafafa;">`;

      msg += `<b style="color:#333;">#${idx + 1} â€” ${ev.name || '(No name)'}</b><br>`;
      msg += `<span style="color:#555;">Date</span> : ${ev.date || '-'}<br>`;
      msg += `<span style="color:#555;">Time</span> : ${ev.time || '-'}<br>`;
      msg += `<span style="color:#555;">Location</span> : ${ev.location || '-'}<br>`;

      const pkgName  = ev.packageName || '';
      const pkgPrice = Number(ev.packagePrice || 0);
      if (pkgName || pkgPrice) {
        msg += `<span style="color:#555;">Package</span> : <b>${pkgName}</b> â€” <b style="color:#198754;">â‚¹${pkgPrice}</b><br>`;
      }

      const addOnPrice = Number(ev.addOnPrice || 0);
      if (addOnPrice || ev.addonDetails) {
        msg += `<span style="color:#555;">Add-ons</span> : <b style="color:#ff7f00;">â‚¹${addOnPrice}</b>`;
        if (ev.addonDetails) msg += ` â€” <span>${ev.addonDetails}</span>`;
        msg += `<br>`;
      }

      const transportPrice = Number(ev.transportPrice || 0);
      if (transportPrice) {
        msg += `<span style="color:#555;">Transport</span> : <b style="color:#d63384;">â‚¹${transportPrice}</b><br>`;
      }

      if (ev.notes) {
        msg += `<span style="color:#555;">Notes</span> : <i>${ev.notes}</i><br>`;
      }

      msg += `</div>`;
    });
  }
   
  showMessage(msg, `Quotation â€” ${q.clientName || 'Unnamed'}`);

  // ----- Configure footer buttons for QUOTATION view -----
  const downloadBtn  = document.getElementById('messageDownloadBtn');
  const shareBtn     = document.getElementById('messageShareBtn');
  const genInvBtn    = document.getElementById('messageGenerateInvoiceBtn');
  const editBtn      = document.getElementById('messageEditBtn');
  const paidBtn      = document.getElementById('messagePaidBtn');

  // Hide all action buttons first
  [downloadBtn, shareBtn, genInvBtn, editBtn, paidBtn].forEach(btn => {
    if (btn) btn.classList.add('hidden');
  });

  const quoteId = q.id;

  if (downloadBtn) {
    downloadBtn.classList.remove('hidden');
    downloadBtn.onclick = () => handleFileAction(quoteId, 'download');
  }
  if (shareBtn) {
    shareBtn.classList.remove('hidden');
    shareBtn.onclick = () => handleFileAction(quoteId, 'share');
  }
  if (genInvBtn) {
    genInvBtn.classList.remove('hidden');
    genInvBtn.onclick = () => {
      closeMessage();
      handleFileAction(quoteId, 'generate_invoice');
    };
  }

  if (editBtn) {
    editBtn.classList.remove('hidden');
    editBtn.onclick = () => {
      closeMessage();
      handleFileAction(quoteId, 'edit');
    };
  }
  // Quotations do not use Paid button
}


function openInvoiceViewerById(invId){
  const all = loadFromLS(SAVED_INVOICES_KEY, []);
  const inv = all.find(x => (x.invoiceId === invId) || (x.id === invId));
  if (!inv) {
    showMessage('Invoice not found.');
    return;
  }

  const events = Array.isArray(inv.events) ? inv.events : [];

  // totals (with safe fallbacks)
  let actual = 0;
  if (typeof inv.actual === 'number') {
    actual = inv.actual;
  } else {
    actual = events.reduce((s, e) =>
      s +
      Number(e.packagePrice || 0) +
      Number(e.addOnPrice || 0) +
      Number(e.transportPrice || 0),
      0
    );
  }

  let discount = typeof inv.discount === 'number' ? inv.discount : 0;
  let final = typeof inv.final === 'number' ? inv.final : Math.max(0, actual - discount);

  let msg = "";

  // ---------- HEADER ----------
  msg += `<b style="color:#0b5ed7; font-size:15px;">Client Name</b> : ${inv.clientName || ''}<br>`;

  const contactText = (inv.clientContact || '').trim();
  const contactEsc  = contactText.replace(/'/g, "\\'");

  msg += `<b style="color:#0b5ed7;">Contact</b> : `;
  if (contactText) {
    msg += `<span style="display:inline-flex;align-items:center;">${contactText}<i data-lucide="phone" class="w-4 h-4 text-blue-600 ml-1 cursor-pointer" onclick="openContactOptions('${contactEsc}')"></i></span>`;
  } else {
    msg += `-`;
  }
  msg += `<br><br>`;

  // ---------- TOTALS ----------
  msg += `<div style="margin:8px 0; padding:6px 8px; border:1px solid #ddd; border-radius:6px; background:#fafafa;">`;
  msg += `<b style="color:#ba2121;">Actual Price</b> : <b>â‚¹${actual}</b><br>`;
  msg += `<b style="color:#ba2121;">Discount</b> : <b>â‚¹${discount}</b><br>`;
  msg += `<b style="color:#198754; font-size:15px;">Final Price</b> : <b>â‚¹${final}</b><br><br>`;
  msg += `</div>`;

    // ---------- EVENTS ----------
  msg += `<b style="color:#6f42c1;">Events:</b><br>`;

  if (!events.length) {
    msg += `<i>(No events saved in this invoice)</i>`;
  } else {
    events.forEach((ev, idx) => {
      msg += `<div style="margin:8px 0; padding:6px 8px; border:1px solid #ddd; border-radius:6px; background:#fafafa;">`;

      msg += `<b style="color:#333;">#${idx + 1} â€” ${ev.name || '(No name)'}</b><br>`;
      msg += `<span style="color:#555;">Date</span> : ${ev.date || '-'}<br>`;
      msg += `<span style="color:#555;">Time</span> : ${ev.time || '-'}<br>`;
      msg += `<span style="color:#555;">Location</span> : ${ev.location || '-'}<br>`;

      const pkgName  = ev.packageName || '';
      const pkgPrice = Number(ev.packagePrice || 0);
      if (pkgName || pkgPrice) {
        msg += `<span style="color:#555;">Package</span> : <b>${pkgName}</b> â€” <b style="color:#198754;">â‚¹${pkgPrice}</b><br>`;
      }

      const addOnPrice = Number(ev.addOnPrice || 0);
      if (addOnPrice || ev.addonDetails) {
        msg += `<span style="color:#555;">Add-ons</span> : <b style="color:#ff7f00;">â‚¹${addOnPrice}</b>`;
        if (ev.addonDetails) msg += ` â€” <span>${ev.addonDetails}</span>`;
        msg += `<br>`;
      }

      const transportPrice = Number(ev.transportPrice || 0);
      if (transportPrice) {
        msg += `<span style="color:#555;">Transport</span> : <b style="color:#d63384;">â‚¹${transportPrice}</b><br>`;
      }

      if (ev.notes) {
        msg += `<span style="color:#555;">Notes</span> : <i>${ev.notes}</i><br>`;
      }

      msg += `</div>`;
    });
  }

  // store current invoice context for Payment Info
  window.CURRENT_VIEWED_INVOICE = {
    id: inv.invoiceId || inv.id,
    actual,
    discount,
    final,
    invoice: inv
  };

  // open the standard popup
    showMessage(msg, `Invoice â€” ${inv.clientName || 'Unnamed'}`);

  // ----- Configure footer buttons for INVOICE view -----
  const downloadBtn  = document.getElementById('messageDownloadBtn');
  const shareBtn     = document.getElementById('messageShareBtn');
  const genInvBtn    = document.getElementById('messageGenerateInvoiceBtn');
  const editBtn      = document.getElementById('messageEditBtn');
  const paidBtn      = document.getElementById('messagePaidBtn');

  // Hide all action buttons first
  [downloadBtn, shareBtn, genInvBtn, editBtn, paidBtn].forEach(btn => {
    if (btn) btn.classList.add('hidden');
  });

  const safeInvId = inv.invoiceId || inv.id;

  if (downloadBtn) {
    downloadBtn.classList.remove('hidden');
    downloadBtn.onclick = () => handleInvoiceAction(safeInvId, 'download');
  }
  if (shareBtn) {
    shareBtn.classList.remove('hidden');
    shareBtn.onclick = () => handleInvoiceAction(safeInvId, 'share');
  }
   if (editBtn) {
    editBtn.classList.remove('hidden');
    editBtn.onclick = () => {
      // close the modal so edit screen is visible
      closeMessage();
      handleInvoiceAction(safeInvId, 'edit');
    };
  }

  if (paidBtn) {
    paidBtn.classList.remove('hidden');
    paidBtn.onclick = () => {
      // close the modal and open the existing payment info popup
      closeMessage();
      openPaymentInfoModal();
    };
  }
  // Generate Invoice button is not needed in invoice view
}

// Open Payment Info directly from Files â†’ Payment Info tab
function openPaymentInfoForInvoiceId(invoiceId) {
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);
  const inv = invoices.find(
    x => (x.invoiceId === invoiceId) || (x.id === invoiceId)
  );

  if (!inv) {
    showMessage('Invoice not found.');
    return;
  }

  const events = Array.isArray(inv.events) ? inv.events : [];

  // Compute totals safely (same style as openInvoiceViewerById)
  let actual = 0;
  if (typeof inv.actual === 'number') {
    actual = inv.actual;
  } else {
    actual = events.reduce(
      (s, e) =>
        s +
        Number(e.packagePrice || 0) +
        Number(e.addOnPrice || 0) +
        Number(e.transportPrice || 0),
      0
    );
  }

  let discount = typeof inv.discount === 'number' ? inv.discount : 0;
  let final = typeof inv.final === 'number'
    ? inv.final
    : Math.max(0, actual - discount);

  // Seed CURRENT_VIEWED_INVOICE so Payment Info modal knows the billed amount
  window.CURRENT_VIEWED_INVOICE = {
    id: inv.invoiceId || inv.id,
    actual,
    discount,
    final,
    invoice: inv
  };

  // Directly open Payment Info popup (no invoice viewer)
  openPaymentInfoModal();
}

// ---- Payment Info helpers ----

function openPaymentInfoModal() {
  // Close the invoice viewer popup (but keep CURRENT_VIEWED_INVOICE)
  if (typeof closeMessage === 'function') {
    closeMessage();
  }

  const modal = document.getElementById('paymentInfoModal');
  if (!modal) return;

  const billedInput   = document.getElementById('paymentBilledAmount');
  const revisedInput  = document.getElementById('paymentRevisedAmount');
  const revisedChk    = document.getElementById('paymentRevisedEnable');
  const advInput      = document.getElementById('paymentAdvancePaid');
  const finalInput    = document.getElementById('paymentFinalPaid');
  const pendingInput  = document.getElementById('paymentPending');
  const partialLog    = document.getElementById('paymentPartialLog');
  const partialValue  = document.getElementById('paymentPartialValue');
  const paidBtn       = document.getElementById('paymentPaidFinalBtn');
  const miscInput     = document.getElementById('paymentMiscAmount');

  // Context from invoice viewer or payment tracker
  const ctx = window.CURRENT_VIEWED_INVOICE || null;
  const inv = ctx && ctx.invoice ? ctx.invoice : null;

  // ------------------ Set Payment Info Heading ------------------
const headMain = document.getElementById('paymentInfoHeadingMain');
const headSub  = document.getElementById('paymentInfoHeadingSub');

const cName = inv?.clientName || ctx?.clientName || "Client";
const cContact = inv?.clientContact || ctx?.clientContact || "";

// Event Date (first event only)
let eventDate = "";
if (inv?.events?.length > 0) {
  const e0 = inv.events[0];
  const rawDate = e0.eventDate || e0.date;  // <-- support both keys

  if (rawDate) {
    const d = new Date(rawDate);
    if (!isNaN(d.getTime())) {
      eventDate = d.toLocaleDateString("en-IN");
    }
  }
}


// MAIN HEADING WITH CALL ICON (uses contact chooser)
headMain.innerHTML = `
  Payment Info - ${cName}${cContact ? " - " + cContact : ""}
  ${cContact ? `
    <button
      type="button"
      class="inline-flex items-center justify-center rounded-full border px-1.5 py-0.5 text-[11px] ml-2"
      data-contact="${(cContact || '').replace(/"/g, '&quot;')}"
      onclick="openContactOptions(this.dataset.contact)"
    >
      <i data-lucide="phone-call" class="w-4 h-4"></i>
    </button>
  ` : ""}
`;

// Enable lucide icons
lucide.createIcons();

// SUB LINE
headSub.textContent = eventDate ? `Event Date: ${eventDate}` : "";


  // 1) Billed amount from context (actual/final)
  let billed = 0;
  if (ctx && typeof ctx.actual === 'number') {
    billed = ctx.actual;
  }
  if (ctx && typeof ctx.final === 'number' && ctx.final > 0) {
    // if you want final to be the billed base instead of actual
    billed = ctx.final;
  }

  if (billedInput) {
    billedInput.value = billed.toFixed(2);
  }

  // 2) Load any previously saved payment values from the invoice
  const savedRevisedEnabled = inv && typeof inv.paymentRevisedEnabled === 'boolean'
    ? inv.paymentRevisedEnabled
    : false;

  const savedRevisedAmount = inv && typeof inv.paymentRevisedAmount === 'number'
    ? inv.paymentRevisedAmount
    : 0;

  const savedAdvance = inv && typeof inv.advancePaid === 'number'
    ? inv.advancePaid
    : 0;

  const savedFinalPaid = inv && typeof inv.finalPaid === 'number'
    ? inv.finalPaid
    : 0;

  const savedPartialLog = inv && typeof inv.paymentPartialLog === 'string'
    ? inv.paymentPartialLog
    : '';
  
   const savedMisc = inv && typeof inv.miscAmount === 'number'
    ? inv.miscAmount
    : 0;  

  // 3) Apply saved state to controls

  // Revised
  if (revisedChk) {
    revisedChk.checked  = savedRevisedEnabled;
    revisedChk.disabled = false;
  }

  if (revisedInput) {
    if (savedRevisedEnabled && savedRevisedAmount > 0) {
      revisedInput.disabled = false;
      revisedInput.value    = savedRevisedAmount.toFixed(2);
    } else {
      revisedInput.disabled = true;
      revisedInput.value    = '';
    }
    revisedInput.classList.remove('field-error-red');
  }

  // Advance Paid
  if (advInput) {
    if (savedAdvance > 0) {
      advInput.value = savedAdvance.toFixed(2);
    } else {
      advInput.value = '';
    }
  }

  // Final Paid â€“ whatever was saved (sum of partial + previous)
  if (finalInput) {
    if (savedFinalPaid > 0) {
      finalInput.value = savedFinalPaid.toFixed(2);
    } else {
      finalInput.value = '0.00';
    }
  }

  // ðŸ”§ Initialize partial sum tracker on Final Paid so recalcPaymentPending
  // does NOT wipe out your saved total.
  if (finalInput) {
    let partialFromSaved = 0;
    if (savedFinalPaid > 0 && savedFinalPaid >= savedAdvance) {
      partialFromSaved = savedFinalPaid - savedAdvance;
    }
    finalInput.dataset.partialSum = partialFromSaved.toFixed(2);
  }
  // Pending will be recalculated below

  // Partial history + current partial input
  if (partialLog) {
    partialLog.value = savedPartialLog;
    partialLog.scrollTop = partialLog.scrollHeight;
  }
  if (partialValue) {
    partialValue.value = '';
  }

  // Miscellaneous
  if (miscInput) {
    miscInput.value = savedMisc > 0 ? savedMisc.toFixed(2) : '';
  }

  // Buttons
  if (paidBtn) {
    // will be updated by recalcPaymentPending based on pending
    paidBtn.disabled = true;
  }

  // Recalculate pending & button states based on loaded values
  if (typeof recalcPaymentPending === 'function') {
    recalcPaymentPending();
  }

   // ðŸ‘‰ NEW: recalc profit for THIS invoice based on loaded values
  if (typeof recalcProfit === 'function') {
    recalcProfit();
  } else {
    const profitInput = document.getElementById('paymentProfit');
    if (profitInput) profitInput.value = '';
  }

  modal.style.display = 'flex';
}




// Open Payment Info where only Advance + Partial payment are allowed (from calendar)
// Open Payment Info where only Advance + Partial payment are allowed (from calendar)
function openPaymentInfoModalRestrictedFromCalendar() {
  const modal = document.getElementById('paymentInfoModal');
  if (!modal) return;

  const billedInput  = document.getElementById('paymentBilledAmount');
  const revisedCheck = document.getElementById('paymentRevisedEnable');
  const revisedInput = document.getElementById('paymentRevisedAmount');
  const advanceInput = document.getElementById('paymentAdvancePaid');
  const finalInput   = document.getElementById('paymentFinalPaid');
  const pendingInput = document.getElementById('paymentPending');
  const partialBtn   = document.getElementById('paymentPartialBtn');
  const paidBtn      = document.getElementById('paymentPaidFinalBtn');
  const miscInput    = document.getElementById('paymentMiscAmount');

    // ðŸ§  Use CURRENT_VIEWED_INVOICE + saved invoice to pre-fill if it exists
  const ctx = window.CURRENT_VIEWED_INVOICE || {};
   const ctxFlow  = window.CALENDAR_BOOKING_FLOW || null;
  const allInvs  = loadFromLS(SAVED_INVOICES_KEY, [])

  // ðŸ§  Try to get existing invoice:
  // 1) ctx.invoice (if already set)
  // 2) By quotationId from CALENDAR_BOOKING_FLOW / ctx
  let inv = ctx.invoice || null;
  const quotationId =
    (ctxFlow && ctxFlow.quotationId) ||
    ctx.quotationId ||
    null;

  if (!inv && quotationId) {
    inv = allInvs.find(x =>
      x.quotationId === quotationId ||
      x.id === quotationId
    ) || null;

    if (inv) {
      ctx.invoice = inv;
      window.CURRENT_VIEWED_INVOICE = ctx;
    }
  }

  // 1ï¸âƒ£ Decide billed base
  const billedRaw =
    (inv && typeof inv.final === 'number')
      ? inv.final
      : (typeof ctx.final === 'number'
          ? ctx.final
          : (typeof ctx.actual === 'number' ? ctx.actual : 0));

  const billed = Number(billedRaw) || 0;

  // 2ï¸âƒ£ Read previously saved payment fields (if any)
  const savedAdvance = inv && typeof inv.advancePaid === 'number'
    ? inv.advancePaid
    : 0;

  const savedFinalPaid = inv && typeof inv.finalPaid === 'number'
    ? inv.finalPaid
    : 0;

  const savedPartialLog = inv && typeof inv.paymentPartialLog === 'string'
    ? inv.paymentPartialLog
    : '';

     const savedMisc = inv && typeof inv.miscAmount === 'number'
    ? inv.miscAmount
    : 0;

  // 3ï¸âƒ£ Apply to controls

  // Billed amount
  if (billedInput) {
    billedInput.value = billed.toFixed(2);
  }

  // Advance Paid
  if (advanceInput) {
    // If we have something saved, show it; otherwise behave like fresh
    advanceInput.value = savedAdvance > 0
      ? savedAdvance.toFixed(2)
      : '0';
  }

  // Final Paid (sum of partial + previous)
  if (finalInput) {
    finalInput.value = savedFinalPaid > 0
      ? savedFinalPaid.toFixed(2)
      : '0';
  }

  // Pending = billed - (advance + final)
  if (pendingInput) {
    const pendingRaw = Math.max(0, billed - (savedAdvance + savedFinalPaid));
    pendingInput.value = pendingRaw.toFixed(2);
    pendingInput.dataset.rawPending = String(pendingRaw);
  }

  // Partial history + current partial input
  const partialLog   = document.getElementById('paymentPartialLog');
  const partialValue = document.getElementById('paymentPartialValue');

  if (partialLog) {
    partialLog.value = savedPartialLog;
    partialLog.scrollTop = partialLog.scrollHeight;
  }
  if (partialValue) {
    partialValue.value = '';
  }

  // Keep track of how much of Final comes from partials so handlePartialAmountApply works
  if (finalInput) {
    let partialFromSaved = 0;
    if (savedFinalPaid > 0 && savedFinalPaid >= savedAdvance) {
      partialFromSaved = savedFinalPaid - savedAdvance;
    }
    finalInput.dataset.partialSum = partialFromSaved.toFixed(2);
  }

  // 4ï¸âƒ£ Disable revised amount & final payment (same as before)
  if (revisedCheck) {
    revisedCheck.checked = false;
    revisedCheck.disabled = true;
  }
  if (revisedInput) {
    revisedInput.value = '';
    revisedInput.disabled = true;
  }
  if (finalInput) {
    finalInput.disabled = true;
  }

  // Let existing logic compute pending + enable Partial as usual
  recalcPaymentPending();

  recalcProfit();

  // Hard-disable the "Paid" (final) button
  if (paidBtn) {
    paidBtn.disabled = true;
    paidBtn.classList.add('opacity-50');
  }

  // Ensure Partial button is available when there is pending
  if (partialBtn && pendingInput) {
    if (Number(pendingInput.dataset.rawPending || '0') > 0) {
      partialBtn.disabled = false;
      partialBtn.classList.remove('opacity-50');
    }
  }

   if (miscInput) {
    miscInput.value = savedMisc > 0 ? savedMisc.toFixed(2) : '';
  }

  if (typeof recalcProfit === 'function') {
  recalcProfit();
}

  modal.style.display = 'flex';
}


function closePaymentInfoModal() {
  const modal = document.getElementById('paymentInfoModal');
  if (modal) modal.style.display = 'none';

  // If we came here from calendar booking and user closed without Partial payment,
  // revert the booked flag(s).
  const ctx = window.CALENDAR_BOOKING_FLOW;
  if (ctx && ctx.fromCalendar) {
    try {
      if (ctx.mode === 'multi-all') {
        setQuotationBookings(ctx.quotationId, false);
      } else if (ctx.eventId) {
        setSingleEventBooking(ctx.eventId, false);
      }

      if (ctx.dateISO && typeof openCalendarDatePopup === 'function') {
        openCalendarDatePopup(ctx.dateISO);
      }
      if (typeof renderCalendar === 'function') {
        renderCalendar();
      }
    } catch (e) {
      console.warn('Failed to revert calendar booking after closing payment modal:', e);
    } finally {
      window.CALENDAR_BOOKING_FLOW = null;
    }
  }
}


// Enable/disable Revised Amount field
function toggleRevisedAmount() {
  const chk   = document.getElementById('paymentRevisedEnable');
  const input = document.getElementById('paymentRevisedAmount');
  if (!chk || !input) return;

  if (chk.checked) {
    input.disabled = false;
  } else {
    input.disabled = true;
    input.classList.remove('field-error-red');
    // optional: keep or clear value
    // input.value = '';
  }
  recalcPaymentPending();
}

function recalcProfit() {
  const misc  = parseFloat(document.getElementById('paymentMiscAmount').value) || 0;
  const finalPaid = parseFloat(document.getElementById('paymentFinalPaid').value) || 0;

  const profit = finalPaid - misc;
  document.getElementById('paymentProfit').value = profit;
}

// Core math for Pending + button enabling
function recalcPaymentPending() {
  const billedInput  = document.getElementById('paymentBilledAmount');
  const revisedInput = document.getElementById('paymentRevisedAmount');
  const revisedChk   = document.getElementById('paymentRevisedEnable');
  const advInput     = document.getElementById('paymentAdvancePaid');
  const finalInput   = document.getElementById('paymentFinalPaid');
  const pendingInput = document.getElementById('paymentPending');
  const paidBtn      = document.getElementById('paymentPaidFinalBtn');
  const saveBtn      = document.getElementById('paymentSaveBtn');

  let billed = parseFloat(billedInput?.value || '0');
  if (isNaN(billed)) billed = 0;

  const revisedEnabled = !!revisedChk?.checked;
  let revised = parseFloat(revisedInput?.value || '0');
  if (isNaN(revised)) revised = 0;

  // base amount (billed or revised)
  let base = billed;
  if (revisedEnabled && revised > 0) {
    base = revised;
  }

  // Advance Paid (user typed)
  let adv = parseFloat(advInput?.value || '0');
  if (isNaN(adv)) adv = 0;

  // Sum of partial amounts (hidden tracker)
  let partialSum = 0;
  if (finalInput && finalInput.dataset && finalInput.dataset.partialSum != null) {
    partialSum = parseFloat(finalInput.dataset.partialSum || '0');
    if (isNaN(partialSum)) partialSum = 0;
  }

  // Final Paid = Advance Paid + ALL partial amounts
  const finalTotal = adv + partialSum;
  if (finalInput) {
    finalInput.value = finalTotal.toFixed(2);
  }

  // Pending = Base - FinalTotal
  const rawPending = base - finalTotal;
  const displayPending = Math.abs(rawPending);

  if (pendingInput) {
    pendingInput.value = displayPending.toFixed(2);
    pendingInput.dataset.rawPending = String(rawPending);
  }

  // fully-paid check
  const isFullyPaid = rawPending <= 0;

  // Paid button enabled only when nothing is pending (<= 0)
  if (paidBtn) {
    paidBtn.disabled = !isFullyPaid;
    paidBtn.classList.toggle('opacity-50', !isFullyPaid);
  }

  // Save button disabled when fully paid
  if (saveBtn) {
    saveBtn.disabled = isFullyPaid;
    saveBtn.classList.toggle('opacity-50', isFullyPaid);
  }
}



function handlePaymentSave(markCompleted = false) {
  const ctx     = window.CURRENT_VIEWED_INVOICE || {};
  const ctxFlow = window.CALENDAR_BOOKING_FLOW || null;

  // We may not have a real invoice yet if we came from calendar.
  let invIdCtx = ctx.id;

  // If no id at all AND not from calendar â†’ same old error
  if (!invIdCtx && !(ctxFlow && ctxFlow.fromCalendar)) {
    alert('No invoice selected. Please open Payment Info from an invoice or Payment Tracker.');
    return;
  }

  // --- Grab all inputs ---
  const billedInput   = document.getElementById('paymentBilledAmount');
  const revisedInput  = document.getElementById('paymentRevisedAmount');
  const revisedChk    = document.getElementById('paymentRevisedEnable');
  const advInput      = document.getElementById('paymentAdvancePaid');
  const finalInput    = document.getElementById('paymentFinalPaid');
  const pendingInput  = document.getElementById('paymentPending');
  const partialLog    = document.getElementById('paymentPartialLog');
  const miscInput     = document.getElementById('paymentMiscAmount');
  // Helper: safely read numbers even if formatted
  function readNum(inputEl) {
    if (!inputEl) return 0;
    const v = inputEl.value || '';
    if (typeof parseINR === 'function') {
      return parseINR(v);
    }
    const n = parseFloat(v.replace(/,/g, ''));
    return isNaN(n) ? 0 : n;
  }

  const billed         = readNum(billedInput);
  const revisedEnabled = !!(revisedChk && revisedChk.checked);
  const revisedAmount  = readNum(revisedInput);
  const advancePaid    = readNum(advInput);
  const finalPaid      = readNum(finalInput);
   const miscAmount     = miscInput ? readNum(miscInput) : 0;

  // Base = revised if enabled and > 0, else billed
  let baseAmount = billed;
  if (revisedEnabled && revisedAmount > 0) {
    baseAmount = revisedAmount;
  }

  // If pendingInput has a raw value stored, use it; else recompute
  let rawPending;
  if (pendingInput && pendingInput.dataset && pendingInput.dataset.rawPending !== undefined) {
    const n = parseFloat(pendingInput.dataset.rawPending);
    rawPending = isNaN(n) ? (baseAmount - (advancePaid + finalPaid)) : n;
  } else {
    rawPending = baseAmount - (advancePaid + finalPaid);
  }

  const pendingAbs     = Math.abs(rawPending);
  const partialHistory = partialLog ? (partialLog.value || '') : '';

  // --- Load invoices from storage ---
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);

  let idx = invoices.findIndex(inv =>
    String(inv.invoiceId || inv.id) === String(invIdCtx)
  );

  let inv;

  // If invoice not found BUT we came from calendar booking,
  // create a new invoice from the quotation *now* (this is your
  // "Invoice should be created after user clicks Save" behaviour).
  if (idx === -1 && ctxFlow && ctxFlow.fromCalendar && ctxFlow.quotationId) {
  // Use helper that enforces "one invoice per quotation"
  const res = ensureInvoiceForCalendarFlow({
    skipRender: true,
    skipDrive: true
  });

  if (!res || !res.invoice) {
    alert('Could not create/update calendar invoice. Cannot save payment info.');
    return;
  }

  const safeId = res.invoice.invoiceId || res.invoice.id;

  // Reload fresh invoices and find this invoice by its id
  const freshInvoices = loadFromLS(SAVED_INVOICES_KEY, []);
  idx = freshInvoices.findIndex(v =>
    String(v.invoiceId || v.id) === String(safeId)
  );

  if (idx === -1) {
    alert('Calendar invoice not found after creation. Cannot save payment info.');
    return;
  }

  // Replace local invoices[] with the up-to-date copy
  invoices.length = 0;
  Array.prototype.push.apply(invoices, freshInvoices);

  inv = invoices[idx];

  window.CURRENT_VIEWED_INVOICE = {
    id: safeId,
    actual: inv.actual,
    discount: inv.discount,
    final: inv.final,
    invoice: inv
  };

} else if (idx === -1) {
  // Non-calendar: same old behaviour
  alert('Invoice not found in storage. Cannot save payment info.');
  return;
} else {
  // idx !== -1: same as before
  inv = invoices[idx];
}


  // --- Persist payment-related fields onto the invoice object ---
  inv.billedAmount          = baseAmount;          // optional, for reference
  inv.paymentRevisedEnabled = revisedEnabled;
  inv.paymentRevisedAmount  = revisedEnabled ? revisedAmount : 0;

  // These two are the important ones for Payment Tracker:
  inv.advancePaid           = advancePaid;
  inv.finalPaid             = finalPaid;

  inv.paymentPendingRaw     = rawPending;
  inv.paymentPendingAbs     = pendingAbs;
  inv.paymentPartialLog     = partialHistory;
  inv.paymentLastUpdated    = new Date().toISOString();
   inv.miscAmount           = miscAmount;

  // --- Derive paymentStatus (used in Payment Info tab) ---
  const billedForStatus = Number(inv.final || inv.actual || baseAmount || 0) || 0;
  const totalPaid       = advancePaid + finalPaid;

  let statusPayment = 'pending';
  if (markCompleted) {
    // only "Paid" button is allowed to fully complete the invoice
    statusPayment = 'completed';
    inv.paymentCompletedAt = new Date().toISOString();
  } else {
    if (!billedForStatus || totalPaid <= 0) {
      statusPayment = 'pending';
    } else {
      // any positive payment but not marked as completed => partial
      statusPayment = 'partial';
    }
  }
  inv.paymentStatus = statusPayment;

  const profitInput = document.getElementById('paymentProfit');
let profit = 0;
if (profitInput) {
  profit = readNum(profitInput); // same helper as others
} else {
  profit = finalPaid - miscAmount;
}

inv.paymentProfit = Number.isFinite(profit) ? Number(profit) : 0;

  // Put back & save
  invoices[idx] = inv;
  saveToLS(SAVED_INVOICES_KEY, invoices);

  // Also refresh CURRENT_VIEWED_INVOICE.invoice so next open shows latest
  window.CURRENT_VIEWED_INVOICE.invoice = inv;

  // Re-render lists (Files + Payment Tracker)
  if (typeof renderFilesList === 'function') {
    renderFilesList();
  }

  // ðŸ”„ Auto-save to Drive (works for both Save + Paid)
  try {
    if (typeof autoSaveDrive === 'function' && window.accessToken) {
      autoSaveDrive(markCompleted ? 'payment marked paid' : 'payment info saved');
    }
  } catch (e) {
    console.warn('Auto-save to Drive after payment save failed:', e);
  }

  // Small toast + close
  if (typeof showUpdateToast === 'function') {
    showUpdateToast(markCompleted ? 'Payment marked as Paid' : 'Payment info saved');
  } else {
    alert(markCompleted ? 'Payment marked as Paid.' : 'Payment info saved.');
  }

  // âœ… IMPORTANT: if this came from calendar booking, do NOT revert bookings
  if (ctxFlow && ctxFlow.fromCalendar) {
    window.CALENDAR_BOOKING_FLOW = null;
    try {
      if (ctxFlow.dateISO && typeof openCalendarDatePopup === 'function') {
        openCalendarDatePopup(ctxFlow.dateISO);
      }
      if (typeof renderCalendar === 'function') {
        renderCalendar();
      }
    } catch (e) {
      console.warn('Calendar refresh after payment save failed:', e);
    }
  }

  closePaymentInfoModal();
}

// Apply Partial Amount â†’ updates Final Paid, history log, and Pending
function handlePartialAmountApply() {
  const partialInput = document.getElementById('paymentPartialValue');
  const finalInput   = document.getElementById('paymentFinalPaid');
  const logArea      = document.getElementById('paymentPartialLog');

  if (!partialInput || !finalInput || !logArea) return;

  const raw = (partialInput.value || '').trim();
  let amount = parseFloat(raw);

// allow both +ve and -ve, just block 0 / invalid
  if (!raw || isNaN(amount) || amount === 0) {
    alert('Please enter a non-zero partial amount. Use -value to correct a mistake.');
    return;
  }

  // 1ï¸âƒ£ Update PARTIAL SUM stored in dataset
  let partialSum = 0;
  if (finalInput.dataset && finalInput.dataset.partialSum != null) {
    partialSum = parseFloat(finalInput.dataset.partialSum || '0');
    if (isNaN(partialSum)) partialSum = 0;
  }
  partialSum += amount;
  finalInput.dataset.partialSum = partialSum.toFixed(2);

  // 2ï¸âƒ£ Append to history log with date + time
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-IN');
  const timeStr = now.toLocaleTimeString('en-IN', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });

  const line = `[${dateStr} ${timeStr}] ${amount.toFixed(2)}`;
  const existing = logArea.value.trim();
  logArea.value = existing ? (existing + '\n' + line) : line;
  logArea.scrollTop = logArea.scrollHeight;

  // 3ï¸âƒ£ Clear partial input
  partialInput.value = '';

  // 4ï¸âƒ£ Recalculate Final Paid + Pending
  recalcPaymentPending();
}

function updateCurrentInvoicePreviewFromCalendar(quotationId) {
  const preview = prepareInvoicePreviewFromQuotation(quotationId);
  if (!preview) return;

  const { quotation: q } = preview;
  let { actual, discount, final } = preview;

  const bookings  = loadFromLS(BOOKED_EVENTS_KEY, {});
  const allEvents = Array.isArray(q.events) ? q.events : [];

  let effectiveEvents   = allEvents;
  let effectiveActual   = actual;
  let effectiveDiscount = (typeof discount === 'number') ? discount : 0;
  let effectiveFinal    = final;

  if (allEvents.length) {
    const bookedEvents = allEvents.filter(ev => ev.eventId && bookings[ev.eventId]);
    const bookedCount  = bookedEvents.length;
    const totalCount   = allEvents.length;
    const allBookedNow = bookedCount > 0 && bookedCount === totalCount;

    // Partial booking -> only include booked events in preview
    if (!allBookedNow && bookedCount > 0) {
      effectiveEvents = bookedEvents.map(ev => ({ ...ev }));

      effectiveActual = bookedEvents.reduce((sum, ev) => {
        return sum +
          Number(ev.packagePrice   || 0) +
          Number(ev.addOnPrice     || 0) +
          Number(ev.transportPrice || 0);
      }, 0);

      effectiveFinal = Math.max(0, effectiveActual - effectiveDiscount);
    }
  }

  // This is what Payment Info uses
  window.CURRENT_VIEWED_INVOICE = {
    id:       q.id || q.quotationId || quotationId,
    actual:   effectiveActual,
    discount: effectiveDiscount,
    final:    effectiveFinal,
    invoice: {
      ...q,
      events:   effectiveEvents,
      actual:   effectiveActual,
      discount: effectiveDiscount,
      final:    effectiveFinal
    }
  };
}


// Create / update invoice when coming from Calendar booking flow.
// Re-uses the quotation totals and respects VOID / NORMAL logic.
function ensureInvoiceForCalendarFlow(options = {}) {
  const opts = options || {};
  const ctxFlow = window.CALENDAR_BOOKING_FLOW;
  const ctxInvoice = window.CURRENT_VIEWED_INVOICE || {};

  if (!ctxFlow || !ctxFlow.fromCalendar) {
    return null;
  }

  const quotationId = ctxFlow.quotationId;
  const willBeVoid  = !!ctxFlow.willBeVoid;
  const dateISO     = ctxFlow.dateISO;

  const preview = prepareInvoicePreviewFromQuotation(quotationId);
  if (!preview) {
    alert('Quotation missing for this booking. Invoice not created.');
    return null;
  }

  const { quotation: q } = preview;
  let   { actual, discount, final } = preview;

  // ðŸ” Adjust events + totals based on current bookings
  const bookings   = loadFromLS(BOOKED_EVENTS_KEY, {});
  const allEvents  = Array.isArray(q.events) ? q.events : [];

  let effectiveEvents   = allEvents;
  let effectiveActual   = actual;
  let effectiveDiscount = (typeof discount === 'number') ? discount : 0;
  let effectiveFinal    = final;

  if (allEvents.length) {
    const bookedEvents = allEvents.filter(ev => ev.eventId && bookings[ev.eventId]);
    const bookedCount  = bookedEvents.length;
    const totalCount   = allEvents.length;
    const allBookedNow = bookedCount > 0 && bookedCount === totalCount;

    // â—Partial booking case:
    // NOT all events booked, but at least one booked â†’ show only booked events
    if (!allBookedNow && bookedCount > 0) {
      // shallow clone to avoid mutating quotation
      effectiveEvents = bookedEvents.map(ev => ({ ...ev }));

      effectiveActual = bookedEvents.reduce((sum, ev) => {
        return sum +
          Number(ev.packagePrice   || 0) +
          Number(ev.addOnPrice     || 0) +
          Number(ev.transportPrice || 0);
      }, 0);

      // keep same discount, apply on new actual
      effectiveFinal = Math.max(0, effectiveActual - effectiveDiscount);
    }
  }

  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);

  // ðŸ” Find existing invoice for this quotation (if any)
  let idx = -1;

  // 1ï¸âƒ£ Prefer currently opened invoice (safer)
  if (ctxInvoice && (ctxInvoice.invoice || ctxInvoice.id)) {
    const currentInvObj = ctxInvoice.invoice || {};
    const currentId =
      currentInvObj.invoiceId ||
      currentInvObj.id ||
      ctxInvoice.id;

    if (currentId) {
      idx = invoices.findIndex(inv =>
        String(inv.invoiceId || inv.id) === String(currentId)
      );
    }
  }

  // 2ï¸âƒ£ Fallback: match by quotationId
  if (idx === -1) {
    idx = invoices.findIndex(inv =>
      inv.quotationId === quotationId ||
      inv.id === quotationId
    );
  }

  let targetInvoice;
  const nowIso = new Date().toISOString();

  if (idx !== -1) {
    // âœ… Update existing invoice for this quotation
    const old = invoices[idx];

    targetInvoice = {
      ...old,
      ...q,
      events:   effectiveEvents,
      actual:   effectiveActual,
      discount: effectiveDiscount,
      final:    effectiveFinal,
      // keep original invoiceId / createdAt
      invoiceId: old.invoiceId || old.id,
      createdAt: old.createdAt || nowIso,
      quotationId
    };

    if (willBeVoid) {
      // Make this invoice VOID
      targetInvoice.status   = 'void';
      targetInvoice.voidedAt = old.voidedAt || nowIso;
    } else {
      // Make / keep this invoice as NORMAL (validated)
      if (String(old.status || '').toLowerCase() === 'void') {
        targetInvoice.status   = 'valid-from-void';
        targetInvoice.voidedAt = undefined;
      } else {
        delete targetInvoice.status;
        delete targetInvoice.voidedAt;
      }
    }

    invoices[idx] = targetInvoice;

  } else {
    // ðŸ†• No existing invoice â†’ create new
    targetInvoice = {
      ...q,
      events:   effectiveEvents,
      invoiceId: 'inv_' + Date.now(),
      createdAt: nowIso,
      quotationId,
      actual:   effectiveActual,
      discount: effectiveDiscount,
      final:    effectiveFinal
    };

    if (willBeVoid) {
      targetInvoice.status   = 'void';
      targetInvoice.voidedAt = nowIso;
    }

    invoices.push(targetInvoice);
  }

  saveToLS(SAVED_INVOICES_KEY, invoices);

  // Update CURRENT_VIEWED_INVOICE for Payment Info
  window.CURRENT_VIEWED_INVOICE = {
    id:       targetInvoice.invoiceId || targetInvoice.id,
    actual:   effectiveActual,
    discount: effectiveDiscount,
    final:    effectiveFinal,
    invoice:  targetInvoice
  };

  if (!opts.skipRender && typeof renderFilesList === 'function') {
    renderFilesList();
  }

  if (!opts.skipDrive && typeof autoSaveDrive === 'function') {
    autoSaveDrive('invoice generated/updated from calendar booking');
  }

  return { invoice: targetInvoice, willBeVoid, dateISO };
}



function handlePaymentPartial() {
  const ctxFlow = window.CALENDAR_BOOKING_FLOW;
  const ctxInvoice = window.CURRENT_VIEWED_INVOICE || {};

  // If not in calendar booking flow, keep old simple behaviour
  if (!ctxFlow || !ctxFlow.fromCalendar) {
    alert('Partial payment logic placeholder â€“ implement as needed.');
    closePaymentInfoModal();
    return;
  }

  // We are in calendar booking flow
  const quotationId = ctxFlow.quotationId;
  const willBeVoid  = !!ctxFlow.willBeVoid;
  const dateISO     = ctxFlow.dateISO;

  const preview = prepareInvoicePreviewFromQuotation(quotationId);
  if (!preview) {
    alert('Quotation missing for this booking. Invoice not created.');
    closePaymentInfoModal();
    return;
  }

  const { quotation: q, actual, discount, final } = preview;
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []);

  // ðŸ” Find existing invoice for this quotation (if any)
  let idx = invoices.findIndex(inv =>
    inv.quotationId === quotationId ||
    inv.id === quotationId
  );

  let targetInvoice;
  const nowIso = new Date().toISOString();

  if (idx !== -1) {
    // âœ… Update existing invoice for this quotation
    const old = invoices[idx];

    // copy old, then overwrite with fresh quotation + totals
    targetInvoice = {
      ...old,
      ...q,
      actual,
      discount,
      final,
      // keep original invoiceId / createdAt
      invoiceId: old.invoiceId || old.id,
      createdAt: old.createdAt || nowIso,
      quotationId
    };

    if (willBeVoid) {
      // Make this invoice VOID
      targetInvoice.status   = 'void';
      targetInvoice.voidedAt = old.voidedAt || nowIso;
    } else {
      // Make / keep this invoice as NORMAL (validated)
      // If it was void before, treat as validated-from-void
      if (String(old.status || '').toLowerCase() === 'void') {
        targetInvoice.status   = 'valid-from-void';
        targetInvoice.voidedAt = undefined;
      } else {
        // already normal; ensure no void flags
        delete targetInvoice.status;
        delete targetInvoice.voidedAt;
      }
    }

    invoices[idx] = targetInvoice;

  } else {
    // âŒ No existing invoice for this quotation â†’ create new
    targetInvoice = {
      ...q,
      invoiceId: 'inv_' + Date.now(),
      createdAt: nowIso,
      quotationId,
      actual,
      discount,
      final
    };

    if (willBeVoid) {
      targetInvoice.status   = 'void';
      targetInvoice.voidedAt = nowIso;
    }

    invoices.push(targetInvoice);
  }

  saveToLS(SAVED_INVOICES_KEY, invoices);

  // Update CURRENT_VIEWED_INVOICE
  window.CURRENT_VIEWED_INVOICE = {
    id: targetInvoice.invoiceId || targetInvoice.id,
    actual,
    discount,
    final,
    invoice: targetInvoice
  };

  if (typeof renderFilesList === 'function') {
    renderFilesList();
  }

  if (typeof autoSaveDrive === 'function') {
    autoSaveDrive('invoice generated/updated from calendar partial payment');
  }

  if (willBeVoid) {
    showMessage('Void invoice updated for this quotation.', 'Invoice');
  } else {
    showMessage('Invoice updated for this quotation.', 'Invoice');
  }

  // âœ… Commit: clear flow so closePaymentInfoModal does NOT revert bookings
  window.CALENDAR_BOOKING_FLOW = null;
  closePaymentInfoModal();

  // refresh calendar UI
  try {
    if (dateISO && typeof openCalendarDatePopup === 'function') {
      openCalendarDatePopup(dateISO);
    }
    if (typeof renderCalendar === 'function') {
      renderCalendar();
    }
  } catch (e) {
    console.warn('Calendar refresh after partial payment failed:', e);
  }
}



function handlePaymentPaidFinal() {
  const pendingInput = document.getElementById('paymentPending');

  let rawPending = 0;
  if (pendingInput) {
    if (pendingInput.dataset && pendingInput.dataset.rawPending !== undefined) {
      rawPending = parseFloat(pendingInput.dataset.rawPending || '0');
    } else {
      rawPending = parseFloat(pendingInput.value || '0');
    }
  }
  if (isNaN(rawPending)) rawPending = 0;

  // Safety check â€“ should already be enforced by disabled button
  if (rawPending > 0.01) {
    alert('Pending amount must be 0.00 before marking as Paid.');
    return;
  }

  // Delegate to save logic with "completed" flag
  handlePaymentSave(true);
}



// ==== Add-Event button helpers (quotation + invoice screens) ====

// Quotation Add Event
function setAddEventEnabled(enabled) {
  const btn = document.getElementById('addEventBtn');
  if (!btn) return;

  btn.disabled = !enabled;

  if (enabled) {
    btn.classList.remove('text-gray-400', 'cursor-not-allowed', 'opacity-60');
    btn.classList.add('text-blue-600', 'hover:underline');
  } else {
    btn.classList.add('text-gray-400', 'cursor-not-allowed', 'opacity-60');
    btn.classList.remove('text-blue-600', 'hover:underline');
  }
}

// Invoice Add Event
function setInvoiceAddEventEnabled(enabled) {
  const btn = document.getElementById('invoiceAddEventBtn');
  if (!btn) return;

  btn.disabled = !enabled;

  if (enabled) {
    btn.classList.remove('text-gray-400', 'cursor-not-allowed', 'opacity-60');
    btn.classList.add('text-blue-600', 'hover:underline');
  } else {
    btn.classList.add('text-gray-400', 'cursor-not-allowed', 'opacity-60');
    btn.classList.remove('text-blue-600', 'hover:underline');
  }
}

// recompute based on any event-panel having data-dirty="true"
// for BOTH quotation and invoice containers
function recomputeAddEventState() {
  // --- quotation container ---
  const quoteContainer = document.getElementById('eventsContainer');
  if (quoteContainer) {
    const qPanels  = Array.from(quoteContainer.querySelectorAll('.event-panel'));
    const qHasDirty = qPanels.some(p => p.dataset.dirty === 'true');
    // Rule:
    // - if NO panels â†’ allow Add Event
    // - if any dirty â†’ block Add Event
    setAddEventEnabled(!qHasDirty || qPanels.length === 0);
  }

  // --- invoice container ---
  const invContainer = document.getElementById('invoiceEventsContainer');
  if (invContainer) {
    const iPanels  = Array.from(invContainer.querySelectorAll('.event-panel'));
    const iHasDirty = iPanels.some(p => p.dataset.dirty === 'true');
    setInvoiceAddEventEnabled(!iHasDirty || iPanels.length === 0);
  }
}

function markPanelDirty(panel) {
  if (!panel) return;
  panel.dataset.dirty = 'true';
  recomputeAddEventState();
}

function markPanelClean(panel) {
  if (!panel) return;
  panel.dataset.dirty = 'false';
  recomputeAddEventState();
}


/* -------------------------
   UI: event panels for quotations (create/edit)
   ------------------------- */
let eventCounter = 0;
function createEventPanel(prefill = {}) {
  eventCounter++;
  const id = `eventPanel_${eventCounter}`;
  const cont = document.getElementById('eventsContainer');
  if (!cont) return;
  const panel = document.createElement('div');
  panel.className = 'event-panel';
  panel.id = id;

  panel.innerHTML = `
    <div class="header">
      <div>
        <div class="flex items-center gap-2">
          <strong class="event-title">New Event</strong>
          <span class="text-xs text-gray-500 event-sub"></span>
        </div>
        <div class="text-xs text-gray-400">Tap to expand</div>
      </div>
      <div class="flex items-center gap-2">
        <button type="button" class="text-xs text-red-500 remove-event-btn">Remove</button>
      </div>
    </div>
    <div class="body hidden">
      <div class="mb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-sm font-semibold text-gray-700">Event Name</h4>
          <label class="flex items-center text-xs text-gray-600">
            <input type="checkbox" class="mr-2 eventFetchName"> Fetch Master
          </label>
        </div>
        <div class="event-name-area">
          <input type="text"
                 class="event-eventNameManual block w-full border-gray-300 rounded p-2 text-sm"
                 placeholder="Manually enter event name">
        </div>
      </div>

      <div class="mb-3">
        <label class="block text-xs font-medium text-gray-700 mb-1">Event Date</label>
        <input type="date"
               class="event-eventDate border-gray-300 rounded p-2 text-sm w-full" />
      </div>

      <div class="mb-3">
        <label class="block text-xs font-medium text-gray-700 mb-1">Event Time</label>
        <div class="flex gap-2">
          <input type="number"
                 min="1" max="12"
                 value="6"
                 class="event-eventHour border-gray-300 rounded p-2 text-sm text-center w-20" />
          <input type="number"
                 min="0" max="59"
                 value="30"
                 class="event-eventMinute border-gray-300 rounded p-2 text-sm text-center w-20" />
          <select class="event-eventPeriod border-gray-300 rounded p-2 text-sm w-20">
            <option>AM</option>
            <option selected>PM</option>
          </select>
        </div>
      </div>

      <div class="mb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-sm font-semibold text-gray-700">Event Location</h4>
          <label class="flex items-center text-xs text-gray-600">
            <input type="checkbox" class="mr-2 eventFetchLocation"> Fetch Map
          </label>
        </div>
        <div class="flex gap-2 mb-2">
          <button type="button" class="py-2 px-3 rounded bg-gray-100 event-mapBtn hidden">
            Use Map Calculator
          </button>
          <input type="text"
                 class="event-eventLocationManual block w-full border-gray-300 rounded p-2 text-sm"
                 placeholder="Manually enter destination" />
        </div>
        <label class="text-xs text-gray-700">Transport Price (â‚¹)</label>
        <input type="number" step="100"
               class="event-transportPrice block w-full border-gray-300 rounded p-2 text-sm"
               value="0.00" />
      </div>

      <div class="mb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-sm font-semibold text-gray-700">Package</h4>
          <label class="flex items-center text-xs text-gray-600">
            <input type="checkbox" class="mr-2 eventFetchPackage"> Fetch Master
          </label>
        </div>
        <div class="event-package-area">
          <input type="text"
                 class="event-packageSelectedManual block w-full border-gray-300 rounded p-2 text-sm"
                 placeholder="Manually enter package name" />
          <input type="number" step="1000"
                 class="event-packageManualPrice block w-full border-gray-300 rounded p-2 text-sm mt-2"
                 placeholder="Manual price (â‚¹)" value="0.00" />
        </div>
      </div>

      <div class="mb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-sm font-semibold text-gray-700">AddOns</h4>
          <label class="flex items-center text-xs text-gray-600">
            <input type="checkbox" class="mr-2 eventFetchAddOn"> Fetch Master
          </label>
        </div>
        <div class="event-addon-area">
          <div class="event-addon-master hidden mb-2"></div>
          <textarea class="event-addon-manual block w-full border-gray-300 rounded p-2 text-sm"
                    rows="3"
                    placeholder="Type items like: (Extra light rental) (Custom filter)"></textarea>
          <div class="mt-2 flex items-center justify-between">
            <div class="text-xs text-gray-500">**Output:**</div>
            <div class="flex gap-2">
              <button type="button"
                      class="event-apply-addon-master hidden py-1 px-2 rounded bg-blue-600 text-white text-sm">
                Apply Selected
              </button>
            </div>
          </div>
          <pre class="event-addon-display mt-2 p-2 bg-gray-50 rounded text-sm text-gray-700 min-h-[3rem]"></pre>
        </div>
        <label class="text-xs text-gray-700 mt-2">AddOn Price (â‚¹)</label>
        <input type="number" step="100"
               class="event-addOnPrice block w-full border-gray-300 rounded p-2 text-sm"
               value="0.00" />
      </div>

      <div class="mb-3">
        <label class="text-sm font-semibold text-gray-700">
          Notes & Complimentary Items
        </label>
        <textarea class="event-notes block w-full border-gray-300 rounded p-2 text-sm mt-1"
                  rows="3"
                  placeholder="Add notes and complimentary items for this event."></textarea>
      </div>

      <div class="mt-3 text-right">
        <button type="button"
                class="py-2 px-3 rounded bg-gray-100 update-btn">
          Update
        </button>
      </div>
    </div>
  `;
  cont.appendChild(panel);

  const modeHidden = document.createElement('input');
  modeHidden.type = 'hidden';
  modeHidden.className = 'event-packageMode';
  modeHidden.value = 'master'; // default to master until user toggles
  panel.appendChild(modeHidden);

  // Apply Aâ€“Z + auto-capitalize rules on manual text fields
  attachAlphaOnlyCapitalize(panel.querySelector('.event-eventNameManual'));
  attachAlphaOnlyCapitalize(panel.querySelector('.event-eventLocationManual'));
  attachAlphaOnlyCapitalize(panel.querySelector('.event-packageSelectedManual'));

  // Any input/change inside this panel makes it "dirty"
  panel.addEventListener('input', (e) => {
    // ignore clicks on the Update button itself
    if (e.target.closest('.update-btn')) return;
    markPanelDirty(panel);
  });
  panel.addEventListener('change', (e) => {
    if (e.target.closest('.update-btn')) return;
    markPanelDirty(panel);
  });

  // --- toggles and wiring (same as before) ---
  panel.querySelector('.header').addEventListener('click', () => {
    panel.querySelector('.body').classList.toggle('hidden');
  });

  panel.querySelector('.remove-event-btn')?.addEventListener('click', (ev) => {
    ev.stopPropagation();
    panel.remove();
    updateSummaryUI();
    recomputeAddEventState();
  });

  panel.querySelector('.eventFetchName')?.addEventListener('change', (ev) => {
    const area = panel.querySelector('.event-name-area');
    if (ev.target.checked) {
      const sel = document.createElement('select');
      sel.className =
        'event-eventNameMaster block w-full border-gray-300 rounded p-2 text-sm';
      sel.innerHTML =
        '<option value="">-- Select Master Event --</option>';
      masterEventNames.forEach((n) => {
        const o = document.createElement('option');
        o.value = n;
        o.textContent = n;
        sel.appendChild(o);
      });
      area.innerHTML = '';
      area.appendChild(sel);
      sel.addEventListener('change', updateSummaryUI);
    } else {
      area.innerHTML =
        '<input type="text" class="event-eventNameManual block w-full border-gray-300 rounded p-2 text-sm" placeholder="Manually enter event name">';
         attachAlphaOnlyCapitalize(area.querySelector(".event-eventNameManual"));
      }
  });

  panel.querySelector('.eventFetchPackage')?.addEventListener('change', (ev) => {
  const area = panel.querySelector('.event-package-area');

  // Ensure the hidden mode input exists
  let modeInput = panel.querySelector('.event-packageMode');
  if (!modeInput) {
    modeInput = document.createElement('input');
    modeInput.type = 'hidden';
    modeInput.className = 'event-packageMode';
    modeInput.value = 'master';
    panel.appendChild(modeInput);
  }

  if (ev.target.checked) {
    // MASTER mode
    modeInput.value = 'master';

    const wrapper = document.createElement('div');
    wrapper.innerHTML = `
      <select class="event-packageMaster block w-full border-gray-300 rounded p-2 text-sm">
        <option value="">-- Select Package --</option>
      </select>
      <input type="number" step="1000"
             class="event-packagePrice block w-full border-gray-300 rounded p-2 text-sm mt-2"
             readonly value="0.00" />
    `;
    area.innerHTML = '';
    area.appendChild(wrapper);
    const sel = panel.querySelector('.event-packageMaster');
    masterPackages.forEach((p) => {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = `${p.name} â€” â‚¹${p.price}`;
      opt.dataset.price = p.price;
      sel.appendChild(opt);
    });
    sel.onchange = () => {
      const opt = sel.options[sel.selectedIndex];
      const price = opt && opt.dataset ? parseFloat(opt.dataset.price) || 0 : 0;
      const priceInp = panel.querySelector('.event-packagePrice');
      if (priceInp) priceInp.value = price;
      updateSummaryUI();
      if (typeof updateInvoiceSummaryUI === 'function') {
        updateInvoiceSummaryUI();
      }
    };

  } else {
    // MANUAL mode
    modeInput.value = 'manual';
    area.innerHTML = `
      <input type="text"
             class="event-packageSelectedManual block w-full border-gray-300 rounded p-2 text-sm"
             placeholder="Manually enter package name" />
      <input type="number" step="1000"
             class="event-packageManualPrice block w-full border-gray-300 rounded p-2 text-sm mt-2"
             placeholder="Manual price (â‚¹)" value="0.00" />
    `;
    attachAlphaOnlyCapitalize(area.querySelector(".event-packageSelectedManual"));
    panel.querySelector('.event-packageManualPrice')?.addEventListener('input', updateSummaryUI);
  }
});


  // addons toggle
  panel.querySelector('.eventFetchAddOn')?.addEventListener('change', (ev) => {
    const masterContainer = panel.querySelector('.event-addon-master');
    const manualTextarea = panel.querySelector('.event-addon-manual');
    const displayPre = panel.querySelector('.event-addon-display');
    const applyBtn = panel.querySelector('.event-apply-addon-master');
    if (ev.target.checked) {
      masterContainer.classList.remove('hidden');
      applyBtn.classList.remove('hidden');
      manualTextarea.classList.add('hidden');
      displayPre.textContent = '';
      masterContainer.innerHTML = '';
      if (masterAddOns.length === 0)
        masterContainer.innerHTML =
          '<p class="text-sm text-gray-500 p-2">No add-ons in master.</p>';
      else
        masterAddOns.forEach((a) => {
          const row = document.createElement('div');
          row.className = 'flex items-center justify-between p-1';
          row.innerHTML = `
            <label class="flex items-center gap-2">
              <input type="checkbox"
                     data-price="${a.price}"
                     data-name="${a.name}"
                     class="panel-addon-checkbox">
              <span class="text-sm">${a.name}</span>
            </label>
            <span class="text-sm font-bold text-green-600">
              â‚¹${a.price}
            </span>`;
          masterContainer.appendChild(row);
        });
    } else {
      masterContainer.classList.add('hidden');
      applyBtn.classList.add('hidden');
      manualTextarea.classList.remove('hidden');
      displayPre.textContent = '';
    }
  });

  panel.querySelector('.event-apply-addon-master')?.addEventListener('click', () => {
    const checked = Array.from(
      panel.querySelectorAll('.panel-addon-checkbox')
    ).filter((cb) => cb.checked);
    const names = checked.map(
      (cb, i) =>
        `${i + 1}. ${cb.dataset.name} (â‚¹${Number(cb.dataset.price)})`
    );
    const sum = checked.reduce(
      (s, cb) => s + Number(cb.dataset.price || 0),
      0
    );
    panel.querySelector('.event-addon-display').textContent =
      names.join('\n') || 'No items selected.';
    panel.querySelector('.event-addOnPrice').value = sum;
    updateSummaryUI();
  if (typeof updateInvoiceSummaryUI === 'function') {
      updateInvoiceSummaryUI();
    }
  });

  panel.querySelector('.event-addon-manual')?.addEventListener('input', () => {
    const raw = panel.querySelector('.event-addon-manual').value || '';
    const matches = [...raw.matchAll(/\((.*?)\)/g)];
    const list = matches
      .map((m, i) => `${i + 1}. ${m[1].trim()}`)
      .join('\n');
    panel.querySelector('.event-addon-display').textContent =
      list ||
      (raw.trim()
        ? 'No items found in (brackets).'
        : 'Enter (Text) above to see the numbered list here.');
  });

  const chkLoc = panel.querySelector('.eventFetchLocation');
  const mapBtn = panel.querySelector('.event-mapBtn');
  const manualLoc = panel.querySelector('.event-eventLocationManual');
  // ðŸ‘‰ apply Aâ€“Z + auto-capital rule on manual typing
if (typeof attachAlphaOnlyCapitalize === 'function' && manualLoc) {
  attachAlphaOnlyCapitalize(manualLoc);
}
  chkLoc?.addEventListener('change', (ev) => {
    if (ev.target.checked) {
      mapBtn.classList.remove('hidden');
      manualLoc.classList.remove('hidden');
      manualLoc.readOnly = true;
    } else {
      mapBtn.classList.add('hidden');
      manualLoc.readOnly = false;
    }
  });
  mapBtn?.addEventListener('click', (ev) => {
  ev.stopPropagation();

  // Remember which screen we came from (quotation OR invoice)
  localStorage.setItem(
    'map_return_screen',
    JSON.stringify({
      screen: currentScreen || 'quotation',
      panelId: id
    })
  );

  navigate('maps');
});

  // inputs updating summary
    const hookPriceChange = (selector) => {
    const el = panel.querySelector(selector);
    if (!el) return;
    el.addEventListener('input', () => {
      updateSummaryUI();
      if (typeof updateInvoiceSummaryUI === 'function') {
        updateInvoiceSummaryUI();
      }
    });
  };

  hookPriceChange('.event-transportPrice');
  hookPriceChange('.event-addOnPrice');
  hookPriceChange('.event-packageManualPrice');


  panel.querySelector('.update-btn')?.addEventListener('click', (ev) => {
    ev.stopPropagation();
    const res = validateEventPanel(panel);
    if (!res.valid) {
      showMessage(res.message);
    } else {
      updateEventPanelSummary(panel.id);
      markPanelClean(panel);           // âœ… this panel is now "saved"
      showUpdateToast('Event updated');
    }
  });

  // ---------- ðŸŸ£ PREFILL WHEN EDITING ----------
  if (prefill && typeof prefill === 'object') {
    // Name
    if (prefill.name) {
      const nameInput = panel.querySelector('.event-eventNameManual');
      if (nameInput) nameInput.value = prefill.name;
    }

    // Date
    if (prefill.date) {
      const dateInput = panel.querySelector('.event-eventDate');
      if (dateInput) dateInput.value = prefill.date;
    }

    // Time: parse "hh:mm AM/PM"
    if (prefill.time) {
      const m = prefill.time.match(/(\d{1,2}):(\d{1,2})\s*(AM|PM)?/i);
      if (m) {
        const h = m[1];
        const min = m[2];
        const per = (m[3] || '').toUpperCase();
        const hEl = panel.querySelector('.event-eventHour');
        const mEl = panel.querySelector('.event-eventMinute');
        const pEl = panel.querySelector('.event-eventPeriod');
        if (hEl) hEl.value = h;
        if (mEl) mEl.value = min;
        if (pEl && per) {
          Array.from(pEl.options).forEach((opt) => {
            if (opt.text.toUpperCase() === per) pEl.value = opt.value;
          });
        }
      }
    }

    // Location
    if (prefill.location) {
      const locInput = panel.querySelector('.event-eventLocationManual');
      if (locInput) locInput.value = prefill.location;
    }

    // Package (manual mode)
    if (prefill.packageName || typeof prefill.packagePrice !== 'undefined') {
      const pkgNameInput = panel.querySelector('.event-packageSelectedManual');
      const pkgPriceInput = panel.querySelector('.event-packageManualPrice');
      if (pkgNameInput && prefill.packageName) {
        pkgNameInput.value = prefill.packageName;
      }
      if (pkgPriceInput && typeof prefill.packagePrice !== 'undefined') {
        pkgPriceInput.value = Number(prefill.packagePrice || 0);
      }
    }

    // Add-on details + price
    if (typeof prefill.addOnPrice !== 'undefined') {
      const addOnPriceInput = panel.querySelector('.event-addOnPrice');
      if (addOnPriceInput) {
        addOnPriceInput.value = Number(prefill.addOnPrice || 0);
      }
    }
    if (prefill.addonDetails) {
      const addonDisplay = panel.querySelector('.event-addon-display');
      const addonManual = panel.querySelector('.event-addon-manual');
      if (addonDisplay) addonDisplay.textContent = prefill.addonDetails;
      if (addonManual) addonManual.value = prefill.addonDetails;
    }

    // Transport price
    if (typeof prefill.transportPrice !== 'undefined') {
      const tInput = panel.querySelector('.event-transportPrice');
      if (tInput) {
        tInput.value = Number(prefill.transportPrice || 0);
      }
    }

    // Notes
    if (prefill.notes) {
      const notesEl = panel.querySelector('.event-notes');
      if (notesEl) notesEl.value = prefill.notes;
    }

    // Update header (title & date pill)
    updateEventPanelSummary(id);
  }
  // Initial dirty state:
  // - existing events loaded from storage (have prefill data) â†’ clean
  // - brand-new empty event â†’ dirty (user must click Update once)
  if (prefill && Object.keys(prefill).length > 0) {
    panel.dataset.dirty = 'false';
  } else {
    panel.dataset.dirty = 'true';
  }
  recomputeAddEventState();

  updateSummaryUI();
  createLucide();
  return id;
}

/* ==== EDIT SUPPORT: load quotation/invoice into forms ==== */

// Fill quotation screen from saved object (client + events)
function loadQuotationIntoForm(q) {
  const nameEl    = document.getElementById('clientNameInput');
  const contactEl = document.getElementById('clientContactInput');
  const discEl    = document.getElementById('quotationDiscount');
  const container = document.getElementById('eventsContainer');

  if (nameEl)    nameEl.value    = q.clientName    || '';
  if (contactEl) contactEl.value = q.clientContact || '';
  if (discEl) {
    const d = q.discount != null ? Number(q.discount) : 0;
    discEl.value = d;
  }

  if (!container) return;

  container.innerHTML = '';

  const events = Array.isArray(q.events) ? q.events : [];

  if (!events.length) {
    const id = createEventPanel();
    const panel = document.getElementById(id);
    if (panel) panel.dataset.eventId = '';
  } else {
    events.forEach(ev => {
      const id = createEventPanel(ev); // prefill fields
      const panel = document.getElementById(id);
      if (panel && ev.eventId) {
        panel.dataset.eventId = ev.eventId;   // keep eventId for calendar
      }
    });
  }

  updateSummaryUI();
}

// Called whenever we open the Quotation screen
function populateQuotationFields() {
  const stored = localStorage.getItem('CURRENT_EDIT_QUOTATION');
  const container = document.getElementById('eventsContainer');
  if (!container) return;

  if (!stored) {
  // New quotation mode
  const nameInput    = document.getElementById('clientNameInput');
  const contactInput = document.getElementById('clientContactInput');
  // ðŸ”¤ Restrictions:
    // Client Name: Aâ€“Z + spaces, first letter auto-capitalised
    if (nameInput) {
      attachAlphaOnlyCapitalize(nameInput);
      nameInput.value = '';
    }

    // ðŸ“ž Client Contact: digits only, max 10 while typing
    if (contactInput) {
      attachNumbersOnly(contactInput);
      contactInput.value = '';
    }
  const discEl = document.getElementById('quotationDiscount');
  if (discEl) discEl.value = '0.00';

  container.innerHTML = '';
  const id = createEventPanel();
  document.getElementById(id); // just ensure created
  updateSummaryUI();
  CURRENT_EDIT_QUOTATION_ID = null;
  return;
}

  try {
    const q = JSON.parse(stored);
    CURRENT_EDIT_QUOTATION_ID = q.id;
    loadQuotationIntoForm(q);
  } catch (e) {
    console.error(e);
  } finally {
    localStorage.removeItem('CURRENT_EDIT_QUOTATION');
  }
}

// Fill invoice screen from saved object
function loadInvoiceIntoForm(inv) {
  const nameEl    = document.getElementById('invoiceClientNameInput');
  const contactEl = document.getElementById('invoiceClientContactInput');
  const discEl    = document.getElementById('invoiceDiscount');
  const container = document.getElementById('invoiceEventsContainer');

  // ðŸ”¤ Restrictions for invoice client fields (same as quotation)
  if (nameEl)    attachAlphaOnlyCapitalize(nameEl);   // Aâ€“Z + spaces, auto-capitalize
  if (contactEl) attachNumbersOnly(contactEl);        // digits only while typing

  if (nameEl)    nameEl.value    = inv.clientName    || '';
  if (contactEl) contactEl.value = inv.clientContact || '';
  if (discEl) {
    const d = inv.discount != null ? Number(inv.discount) : 0;
    discEl.value = d;
  }

  if (!container) return;

  container.innerHTML = '';

  const events = Array.isArray(inv.events) ? inv.events : [];

  if (!events.length) {
    const id = createEventPanel();
    const panel = document.getElementById(id);
    if (panel) container.appendChild(panel);
  } else {
    events.forEach(ev => {
      const id = createEventPanel(ev); // prefill
      const panel = document.getElementById(id);
      if (panel) container.appendChild(panel); // move panel to invoice container
    });
  }

  // update invoice summary from current panels
  updateInvoiceSummaryUI();
   recomputeAddEventState();
}

// Called whenever we open the Invoice screen
function populateInvoiceFields() {
  const stored = localStorage.getItem('CURRENT_EDIT_INVOICE');
  const container = document.getElementById('invoiceEventsContainer');
  if (!container) return;

  if (!stored) {
  // New invoice mode
  const invNameInput    = document.getElementById('invoiceClientNameInput');
  const invContactInput = document.getElementById('invoiceClientContactInput');
 // ðŸ”¤ Restrictions (same as quotation)
    if (invNameInput) {
      attachAlphaOnlyCapitalize(invNameInput);  // Aâ€“Z + spaces, auto-capitalize
      invNameInput.value = '';
    }
    if (invContactInput) {
      attachNumbersOnly(invContactInput);       // digits only while typing
      invContactInput.value = '';
    }

  const discEl = document.getElementById('invoiceDiscount');
  if (discEl) discEl.value = '0.00';

    container.innerHTML = '';
    const id = createEventPanel();
    const panel = document.getElementById(id);
    if (panel) container.appendChild(panel);

    updateInvoiceSummaryUI();
    recomputeAddEventState();


    CURRENT_EDIT_INVOICE_ID = null;
    return;
  }

  try {
    const inv = JSON.parse(stored);
    CURRENT_EDIT_INVOICE_ID = inv.invoiceId || inv.id;
    loadInvoiceIntoForm(inv);
  } catch (e) {
    console.error(e);
  } finally {
    localStorage.removeItem('CURRENT_EDIT_INVOICE');
  }
}

// === Fetch + render client requests ===
async function refreshClientRequestsUI() {
  const listEl  = document.getElementById('clientReqList');
  const emptyEl = document.getElementById('clientReqEmpty');
  if (!listEl || !emptyEl) return;

  listEl.innerHTML =
    '<div class="text-[11px] text-gray-400 py-2">Loadingâ€¦</div>';
  emptyEl.classList.add('hidden');

  const ownerId = getClientReqOwnerId();
  if (!ownerId) {
    listEl.innerHTML =
      '<div class="text-[11px] text-red-500 py-2">Please sign in first.</div>';
    if (typeof updateClientReqBadge === 'function') {
      updateClientReqBadge(0);
    }
    return;
  }

  try {
    const res = await fetch(
      CLIENT_REQ_API_URL + '?ownerId=' + encodeURIComponent(ownerId)
    );
    const data = await res.json();

    if (!data.ok) throw new Error(data.message);

    // ðŸ‘‡ change const â†’ let
    let items = data.items || [];

    // ðŸ”¹ Filter out any requests that are already in System/User recycle as client-request
    try {
      const systemList = loadFromLS(RECYCLE_SYSTEM_KEY, []) || [];
      const userList   = loadFromLS(RECYCLE_USER_KEY, [])   || [];

      const removedSet = new Set(
        [...systemList, ...userList]
          .filter(
            (entry) =>
              entry &&
              entry.type === 'client-request' &&
              entry.rowIndex != null
          )
          .map((entry) => String(entry.rowIndex))
      );

      items = items.filter(
        (row) => !removedSet.has(String(row.rowIndex))
      );
    } catch (e) {
      console.warn(
        'Client-requests filter by recycle bins failed:',
        e
      );
    }

    // âœ… SORT: latest first (higher rowIndex = newer)
    items.sort((a, b) => {
      const ra = Number(a.rowIndex || 0);
      const rb = Number(b.rowIndex || 0);
      return rb - ra; // descending
    });

    listEl.innerHTML = '';

    if (!items.length) {
      emptyEl.classList.remove('hidden');

      if (typeof updateClientReqBadge === 'function') {
        updateClientReqBadge(0);
      }
      return;
    }

    items.forEach((row) => {
      let payload = {};
      try { payload = JSON.parse(row.payloadJson); } catch {}

      const clientName = payload.clientName || '--';
      const contact    = payload.clientContact || '';

      const card = document.createElement('div');
      card.className = 'border border-gray-200 rounded-lg p-2 bg-white shadow-sm';
      card.dataset.payloadJson = row.payloadJson;
      card.dataset.rowIndex = row.rowIndex || '';

      card.innerHTML = `
        <div class="flex justify-between items-start gap-2">
          <div>
            <div class="text-[13px] font-semibold text-gray-800">${clientName}</div>
            <div class="text-[11px] text-gray-500">${contact}</div>
          </div>
          <div class="flex flex-col items-end gap-1">
            <button
              class="clientReqViewBtn text-[11px] px-2 py-1 rounded-full border border-gray-200 bg-white hover:bg-gray-50"
            >
              View
            </button>
          </div>
        </div>
      `;

      listEl.appendChild(card);
    });

    const count = items.length;
    if (typeof updateClientReqBadge === 'function') {
      updateClientReqBadge(count);
    }

  } catch (e) {
    console.error(e);
    listEl.innerHTML =
      '<div class="text-[11px] text-red-500">Failed to load.</div>';
    if (typeof updateClientReqBadge === 'function') {
      updateClientReqBadge(0);
    }
  }
}

async function shareClientRequestSnapshot(payload) {
  try {
    const bodyEl = document.getElementById('messageBody');
    if (!bodyEl) {
      alert('Preview not ready to share.');
      return;
    }

    if (typeof html2canvas !== 'function') {
      alert('Sharing as image is not supported in this browser (html2canvas missing).');
      return;
    }

    // Take screenshot of the popup content
    const canvas = await html2canvas(bodyEl, {
      scale: 2,
      backgroundColor: '#ffffff',
      useCORS: true
    });

    const blob = await new Promise(resolve =>
      canvas.toBlob(resolve, 'image/png', 0.95)
    );
    if (!blob) {
      alert('Could not create image from client request.');
      return;
    }

    const safeName = (payload.clientName || 'Client')
      .replace(/[^a-z0-9_\-]+/gi, '_');
    const fileName = `ClientRequest-${safeName}.png`;

    // Try to create a File (for modern browsers)
    let file = null;
    try {
      file = new File([blob], fileName, { type: 'image/png' });
    } catch (_) {
      // Older browsers may not support File constructor â€“ weâ€™ll still fall back
    }

    // Build a helpful text with WA link
    const textLines = [];
    textLines.push('Client enquiry details from Makeovrs');

    if (payload.clientName) {
      textLines.push('Name: ' + payload.clientName);
    }
    if (payload.clientContact) {
      textLines.push('Contact: ' + payload.clientContact);

      // Build WhatsApp deep link based on the contact
      const raw = String(payload.clientContact || '').trim();
      const cleaned = raw.replace(/[^\d+]/g, '');
      let waDigits = cleaned.replace(/[^\d]/g, '');
      if (waDigits.length === 10) {
        // Assume Indian number â†’ add 91
        waDigits = '91' + waDigits;
      }
      if (waDigits) {
        textLines.push('WhatsApp link: https://wa.me/' + waDigits);
      }
    }

    const shareText = textLines.join('\n');

    // 1ï¸âƒ£ Best case: share with image file + text
    if (
      file &&
      navigator.canShare &&
      navigator.canShare({ files: [file] })
    ) {
      await navigator.share({
        files: [file],
        title: `Client Request - ${payload.clientName || ''}`,
        text: shareText
      });
      return;
    }

    // 2ï¸âƒ£ Second best: share only text, open image in new tab
    if (navigator.share) {
      await navigator.share({
        title: `Client Request - ${payload.clientName || ''}`,
        text: shareText
      });

      const url = URL.createObjectURL(blob);
      window.open(url, '_blank'); // user can long-press / save / share from here
      return;
    }

    // 3ï¸âƒ£ Fallback: just open image in new tab and instruct user
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    alert(
      'Your browser does not support direct sharing. ' +
      'The image is opened in a new tab â€“ long-press and share via WhatsApp.'
    );
  } catch (err) {
    console.error('shareClientRequestSnapshot failed', err);
    alert('Sharing failed. Please try again.');
  }
}


// === Mark a client request as imported & move it to System recycle ===
// === Mark a client request as imported & move it to System recycle ===
async function refreshClientRequestsUI() {
  const listEl  = document.getElementById('clientReqList');
  const emptyEl = document.getElementById('clientReqEmpty');
  if (!listEl || !emptyEl) return;

  listEl.innerHTML =
    '<div class="text-[11px] text-gray-400 py-2">Loadingâ€¦</div>';
  emptyEl.classList.add('hidden');

  const ownerId = getClientReqOwnerId();
  if (!ownerId) {
    listEl.innerHTML =
      '<div class="text-[11px] text-red-500 py-2">Please sign in first.</div>';
    if (typeof updateClientReqBadge === 'function') {
      updateClientReqBadge(0);
    }
    return;
  }

  // âœ… Use JSONP instead of fetch (to avoid CORS)
  return new Promise((resolve, reject) => {
    const callbackName = 'clientReqCb_' + Date.now();

    // Define global callback â€“ called by Apps Script
    window[callbackName] = function (data) {
      try {
        if (!data || data.ok === false) {
          console.error('Client-requests error:', data && data.message);
          listEl.innerHTML =
            '<div class="text-[11px] text-red-500">Failed to load.</div>';
          if (typeof updateClientReqBadge === 'function') {
            updateClientReqBadge(0);
          }
          reject(data);
          return;
        }

        // ðŸ‘‡ same logic as before, just using data from JSONP
        let items = data.items || [];

        // ðŸ”¹ Filter: remove items already in recycle bins
        try {
          const systemList = loadFromLS(RECYCLE_SYSTEM_KEY, []) || [];
          const userList   = loadFromLS(RECYCLE_USER_KEY, [])   || [];

          const removedSet = new Set(
            [...systemList, ...userList]
              .filter(
                (entry) =>
                  entry &&
                  entry.type === 'client-request' &&
                  entry.rowIndex != null
              )
              .map((entry) => String(entry.rowIndex))
          );

          items = items.filter(
            (row) => !removedSet.has(String(row.rowIndex))
          );
        } catch (e) {
          console.warn(
            'Client-requests filter by recycle bins failed:',
            e
          );
        }

        // âœ… SORT: latest first (higher rowIndex = newer)
        items.sort((a, b) => {
          const ra = Number(a.rowIndex || 0);
          const rb = Number(b.rowIndex || 0);
          return rb - ra; // descending
        });

        listEl.innerHTML = '';

        if (!items.length) {
          emptyEl.classList.remove('hidden');
          if (typeof updateClientReqBadge === 'function') {
            updateClientReqBadge(0);
          }
          resolve([]);
          return;
        }

        items.forEach((row) => {
          // We already got parsed data from backend
          const clientName = row.clientName || '--';
          const contact    = row.clientContact || '';

          // Keep payloadJson for your existing "View" popup logic
          const payloadJson =
            row.payloadJson ||
            JSON.stringify({
              clientName: row.clientName || '',
              clientContact: row.clientContact || '',
              events: row.events || []
            });

          const card = document.createElement('div');
          card.className = 'border border-gray-200 rounded-lg p-2 bg-white shadow-sm';
          card.dataset.payloadJson = payloadJson;
          card.dataset.rowIndex = row.rowIndex || '';

          card.innerHTML = `
            <div class="flex justify-between items-start gap-2">
              <div>
                <div class="text-[13px] font-semibold text-gray-800">${clientName}</div>
                <div class="text-[11px] text-gray-500">${contact}</div>
              </div>
              <div class="flex flex-col items-end gap-1">
                <button
                  class="clientReqViewBtn text-[11px] px-2 py-1 rounded-full border border-gray-200 bg-white hover:bg-gray-50"
                >
                  View
                </button>
              </div>
            </div>
          `;

          listEl.appendChild(card);
        });

        const count = items.length;
        if (typeof updateClientReqBadge === 'function') {
          updateClientReqBadge(count);
        }

        resolve(items);
      } finally {
        // Cleanup: remove callback + script tag
        delete window[callbackName];
        if (script && script.parentNode) {
          script.parentNode.removeChild(script);
        }
      }
    };

    // Create <script> tag for JSONP call
    const script = document.createElement('script');
    script.src =
      CLIENT_REQ_API_URL +
      '?ownerId=' + encodeURIComponent(ownerId) +
      '&callback=' + encodeURIComponent(callbackName);

    script.onerror = function (err) {
      delete window[callbackName];
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
      console.error('Client-requests JSONP error:', err);
      listEl.innerHTML =
        '<div class="text-[11px] text-red-500">Failed to load.</div>';
      if (typeof updateClientReqBadge === 'function') {
        updateClientReqBadge(0);
      }
      reject(err);
    };

    document.body.appendChild(script);
  });
}



// === View popup for a client request (Accept / Decline / Close) ===
function openClientRequestPreview(payload, rowIndex) {
  payload = payload || {};
  const events = Array.isArray(payload.events) ? payload.events : [];

  const clientName   = (payload.clientName || '--').trim();
  const contactText  = (payload.clientContact || '').trim();
  const contactEsc   = contactText.replace(/'/g, "\\'");

  let html = '';

  // ---------- HEADER ----------
  html += `<div style="font-size:14px; line-height:1.5;">`;
  html += `  <div style="margin-bottom:8px;">`;
  html += `    <div style="font-weight:600; font-size:15px; color:#0b5ed7;">${clientName || '--'}</div>`;

  if (contactText) {
    html += `    <div style="font-size:12px; color:#555; display:inline-flex; align-items:center; gap:4px;">`;
    html += `      ${contactText}`;
    html += `      <i data-lucide="phone" class="w-4 h-4 text-blue-600 cursor-pointer" onclick="openContactOptions('${contactEsc}')"></i>`;
    html += `    </div>`;
  }

  html += `  </div>`;

  // ---------- EVENTS ----------
  if (!events.length) {
    html += `<div style="font-size:12px; color:#888;">No event details found.</div>`;
  } else {
    events.forEach((ev, idx) => {
      const name     = (ev.name || '').trim() || '(No name)';
      const date     = ev.date || '';
      const pkg      = ev.packageIdea || '';
      const location = ev.location || '';
      const addons   = ev.addons || '';
      const notes    = ev.notes || '';

      html += `
        <div style="
          border:1px solid #e5e7eb;
          border-radius:8px;
          padding:8px 10px;
          margin-bottom:8px;
          background:#f9fafb;
        ">
          <div style="font-weight:600; font-size:13px; margin-bottom:4px;">
            Event ${idx + 1}: ${name}
          </div>
          <div style="font-size:12px; color:#444;">
            ${date ? `<div><span style="color:#555;">Date</span> : ${date}</div>` : ''}
            ${pkg ? `<div><span style="color:#555;">Package idea</span> : ${pkg}</div>` : ''}
            ${location ? `<div><span style="color:#555;">Location</span> : ${location}</div>` : ''}
            ${addons ? `<div><span style="color:#555;">Add-ons</span> : ${addons}</div>` : ''}
            ${notes ? `<div><span style="color:#555;">Notes</span> : <i>${notes}</i></div>` : ''}
          </div>
        </div>
      `;
    });
  }

  html += `</div>`; // end main wrapper

  // Open the standard modal
  showMessage(html, 'Client Request');

// --- Capture modal context so subsequent save can archive the sheet row ---
try {
  CURRENT_CLIENT_REQ_CTX = {
    rowIndex: rowIndex,                // âœ” correct: from function argument
    ownerId: getClientReqOwnerId(),    // âœ” best available owner ID
    payload: payload || {}             // optional but helpful
  };

  console.log("SET CURRENT_CLIENT_REQ_CTX =", CURRENT_CLIENT_REQ_CTX);
} catch (e) {
  console.warn("Failed to set CURRENT_CLIENT_REQ_CTX", e);
  CURRENT_CLIENT_REQ_CTX = null;
}

  /// Hide buttons that are not used here (keep Share visible for image sharing)
['messagePaidBtn','messageEditBtn']
  .forEach(id => document.getElementById(id)?.classList.add('hidden'));

// Configure Share button for client-request image sharing
const shareBtn = document.getElementById('messageShareBtn');
if (shareBtn) {
  shareBtn.classList.remove('hidden');
  shareBtn.textContent = 'Share';
  shareBtn.onclick = () => {
    shareClientRequestSnapshot(payload);
  };
}

// Map footer buttons
  const green = document.getElementById('messageGenerateInvoiceBtn'); // Create quotation
  const black = document.getElementById('messageDownloadBtn');        // Delete (Decline)
  const red   = document.getElementById('messageCloseBtn');           // Close

  // 1ï¸âƒ£ CREATE QUOTATION (GREEN)
  if (green) {
    green.classList.remove('hidden');
    green.textContent = 'Create Quotation';
    green.onclick = () => {
      CURRENT_CLIENT_REQ_CTX = { rowIndex, payload };
      createQuotationFromClientRequestPayload(payload);
      closeMessage();

      const panel = document.getElementById('clientRequestsPanel');
      if (panel) panel.classList.add('hidden');
    };
  }

  // 2ï¸âƒ£ DECLINE / DELETE (BLACK button)
  if (black) {
    black.classList.remove('hidden');
    black.textContent = 'Decline';
    black.onclick = async () => {
      await markClientRequestDeclined({ rowIndex, payload });
      closeMessage();
    };
  }

  // 3ï¸âƒ£ CLOSE (RED button text)
  if (red) {
    red.classList.remove('hidden');
    red.textContent = 'Close';
  }

  // Refresh icons (phone icon etc.)
  if (typeof createLucide === 'function') {
    createLucide();
  }
}

// â­ Mark a client request as imported & move it to System recycle
async function markClientRequestImported(ctx) {
  try {
    if (!ctx) {
      console.warn('markClientRequestImported: no ctx', ctx);
      return;
    }

    const rowIndex = Number(ctx.rowIndex || 0);
    const payload  = ctx.payload || {};
    const ownerId  = ctx.ownerId || (typeof getClientReqOwnerId === 'function'
      ? getClientReqOwnerId()
      : null);

    if (!rowIndex) {
      console.warn('markClientRequestImported: invalid rowIndex', ctx.rowIndex);
      return;
    }

    // 1ï¸âƒ£ Tell Google Sheet to set status = "imported"
    try {
      const body = {
        _action: 'markImported',
        rowIndex: rowIndex
      };
      if (ownerId) body.ownerId = ownerId;

      await fetch(CLIENT_REQ_API_URL, {
        method: 'POST',
        mode: 'no-cors',           // avoid CORS noise, fire-and-forget
        body: JSON.stringify(body) // Apps Script parses JSON from postData
      });

      console.log('markClientRequestImported: request sent for row', rowIndex);
    } catch (e) {
      console.warn(
        'markClientRequestImported: sheet update may have CORS/network issues, but request was sent:',
        e
      );
    }

    // 2ï¸âƒ£ Move this request into Recycle â†’ System list
    try {
      const systemList = loadFromLS(RECYCLE_SYSTEM_KEY, []) || [];
      const nowIso     = new Date().toISOString();

      systemList.push({
        recycleId: 'recycle_' + Date.now() + '_' + Math.random().toString(36).slice(2),
        type: 'client-request',
        kind: 'client-request',
        label: payload.clientName || 'Client Request',
        clientName: payload.clientName,
        clientContact: payload.clientContact,
        rowIndex: rowIndex,
        payload: payload,
        removedAt: nowIso,
        reason: 'Imported into quotation'
      });

      saveToLS(RECYCLE_SYSTEM_KEY, systemList);

      // Refresh Recycle â†’ System tab + floating client-requests list
      try { renderRecycleList && renderRecycleList('system'); } catch (e) {}
      try { refreshClientRequestsUI && refreshClientRequestsUI(); } catch (e) {}
    } catch (e) {
      console.warn('markClientRequestImported: recycle move failed', e);
    }
  } catch (e) {
    console.error('markClientRequestImported fatal error', e);
  }
}



function cleanupOldClientRequestSystemRemoved() {
  try {
    const systemList = loadFromLS(RECYCLE_SYSTEM_KEY, []) || [];
    const cutoffMs =
      Date.now() - CLIENT_REQUEST_RETENTION_DAYS * 24 * 60 * 60 * 1000;

    const filtered = systemList.filter(item => {
      if (!item) return false;

      // Only apply N-day cleanup to client-request entries
      if (item.kind !== 'client-request') return true;

      const t = item.removedAt ? Date.parse(item.removedAt) : NaN;
      if (isNaN(t)) return true; // if no valid date, keep it

      return t >= cutoffMs; // keep only if NOT older than cutoff
    });

    if (filtered.length !== systemList.length) {
      saveToLS(RECYCLE_SYSTEM_KEY, filtered);
    }
  } catch (e) {
    console.warn('Cleanup of old client-request system-removed items failed', e);
  }
}



// === Convert client request â†’ prefilled quotation ===
function createQuotationFromClientRequestPayload(payload) {
  const qDraft = {
    clientName: payload.clientName || '',
    clientContact: payload.clientContact || '',
    discount: 0,
    events: (payload.events || []).map(ev => ({
      name: ev.name || '',
      date: ev.date || '',
      packageName: ev.packageIdea || '',
      packagePrice: 0,
      addOnPrice: 0,
      transportPrice: 0,
      addonDetails: ev.addons || '',
      notes: ev.notes || '',
      location: ev.location || ''
    }))
  };

  // Store draft so quotation screen can pick it up
  localStorage.setItem('CURRENT_EDIT_QUOTATION', JSON.stringify(qDraft));

  // This will call populateQuotationFields() internally
  navigate('quotation');
}

function cancelMapPrice() {
  // Do NOT create extra history, and do NOT re-run init on return screen
  const navOpts = { pushHistory: false, skipInit: true };

  const raw = localStorage.getItem('map_return_screen');

  // Always hide the confirm row
  document.getElementById('map-confirm-row')?.classList.add('hidden');

  // If for some reason nothing stored, just fall back to quotation
  if (!raw) {
    navigate('quotation', navOpts);
    return;
  }

  try {
    const parsed = JSON.parse(raw);
    const targetScreen =
      parsed && parsed.screen === 'invoice' ? 'invoice' : 'quotation';

    // â— IMPORTANT: don't touch transport price or location,
    // just return back to the same screen.
    navigate(targetScreen, navOpts);
  } catch (e) {
    console.warn('cancelMapPrice parse error', e);
    navigate('quotation', navOpts);
  }
}


// call this from navigation logic when maps screen is shown (maps initialization will be done by navigate('maps') handler)
function confirmMapPrice() {
  // âœ… do NOT push history, and do NOT re-run init logic on return screen
  const navOpts = { pushHistory: false, skipInit: true };

  const raw = localStorage.getItem('map_return_screen');
  if (!raw) {
    document.getElementById('map-confirm-row')?.classList.add('hidden');
    // fallback: old behaviour â†’ go to quotation
    navigate('quotation', navOpts);
    return;
  }

  try {
    const parsed = JSON.parse(raw);

    if (parsed && parsed.panelId) {
      const panelId = parsed.panelId;
      const targetScreen =
        parsed.screen === 'invoice' ? 'invoice' : 'quotation';

      const panelTransport = document.querySelector(
        `#${panelId} .event-transportPrice`
      );
      const panelLoc = document.querySelector(
        `#${panelId} .event-eventLocationManual`
      );

      // ---- transport price ----
      if (panelTransport && typeof tempTransportPrice === 'object') {
        const price =
          typeof tempTransportPrice.price === 'number'
            ? tempTransportPrice.price
            : 0;
        panelTransport.value = price;
      }

      // ---- destination / location ----
      if (panelLoc && typeof tempTransportPrice === 'object') {
        const routeDesc = tempTransportPrice.description || '';

        if (routeDesc) {
          try {
            const toIndex = routeDesc.indexOf(' to ');
            const dashIndex = routeDesc.indexOf(' - ');
            if (toIndex >= 0 && dashIndex > toIndex) {
              const dest = routeDesc.substring(toIndex + 4, dashIndex).trim();
              panelLoc.value = dest || routeDesc;
            } else {
              panelLoc.value = routeDesc;
            }
            panelLoc.classList.remove('field-error-orange', 'field-error-red');
          } catch (e) {
            console.warn('Route parsing failed', e);
          }
        }
      }

      // clean up + refresh summaries
      localStorage.removeItem('map_return_screen');
      document.getElementById('map-confirm-row')?.classList.add('hidden');

      if (typeof updateSummaryUI === 'function') updateSummaryUI();
      if (typeof updateInvoiceSummaryUI === 'function')
        updateInvoiceSummaryUI();

      // ðŸ‘ˆ Go back to the same screen we came from
      navigate(targetScreen, navOpts);
      return;
    }
  } catch (e) {
    console.warn('confirmMapPrice parse error', e);
  }

  // fallback
  localStorage.removeItem('map_return_screen');
  document.getElementById('map-confirm-row')?.classList.add('hidden');
  navigate('quotation', navOpts);
}

function initClientRequestsFloatingUi() {
  const app    = document.getElementById('app');
  const fab    = document.getElementById('clientRequestsFab');
  const panel  = document.getElementById('clientRequestsPanel');
  const close  = document.getElementById('clientReqCloseBtn');
  const refreshBtn = document.getElementById('clientReqRefreshBtn');
  const listEl = document.getElementById('clientReqList');
  const formBtn = document.getElementById('clientFormBtn');

  if (!app || !fab || !panel) return;

    // ðŸ”’ Hide / show floating button based on sign-in
  try {
    const isSigned = localStorage.getItem('gdrive_signed_in') === '1';
    if (!isSigned) {
      fab.classList.add('hidden');
      panel.classList.add('hidden');
    } else {
      fab.classList.remove('hidden');
      panel.classList.add('hidden');
    }
  } catch (e) {
    console.warn('Client-req FAB sign-in check failed', e);
  }


  // ------------- OPEN / CLOSE PANEL ON TAP -------------
  let clickAllowedAfterDrag = true;

  fab.addEventListener('click', () => {
    // if we just dragged, ignore this click
    if (!clickAllowedAfterDrag) {
      clickAllowedAfterDrag = true;
      return;
    }
    panel.classList.toggle('hidden');
    if (!panel.classList.contains('hidden')) {
      refreshClientRequestsUI();
    }
  });

  if (close) {
    close.addEventListener('click', () => {
      panel.classList.add('hidden');
    });
  }

  if (refreshBtn) {
    refreshBtn.addEventListener('click', () => {
      refreshClientRequestsUI();
    });
  }

  // ------------- LIST BUTTONS (VIEW / CREATE) -------------
  if (listEl) {
    listEl.addEventListener('click', (e) => {
      const card = e.target.closest('[data-payload-json]');
      if (!card) return;

      let payload = {};
      try {
        payload = JSON.parse(card.dataset.payloadJson || '{}');
      } catch {
        payload = {};
      }

      const rowIndex = card.dataset.rowIndex || '';

      if (!rowIndex) {
        alert('Missing row index for this client request.');
        return;
      }

      // View â†’ open popup with Accept / Decline / Close
      if (e.target.closest('.clientReqViewBtn')) {
        openClientRequestPreview(payload, rowIndex);
        return;
      }

        // Open quotation pre-filled from this client request
        createQuotationFromClientRequestPayload(payload);

        // Close the floating panel (optional)
        panel.classList.add('hidden');
        return;
    });
  }

  // ------------- DRAGGING (MOUSE + TOUCH via POINTER EVENTS) -------------
  let drag = {
    active: false,
    startX: 0,
    startY: 0,
    origX:  0,
    origY:  0,
    moved:  false
  };

  fab.style.touchAction = 'none'; // helps on mobile

  fab.addEventListener('pointerdown', (e) => {
    drag.active = true;
    drag.moved  = false;
    clickAllowedAfterDrag = true;

    const appRect = app.getBoundingClientRect();
    const fabRect = fab.getBoundingClientRect();

    drag.origX = fabRect.left - appRect.left;
    drag.origY = fabRect.top  - appRect.top;
    drag.startX = e.clientX;
    drag.startY = e.clientY;

    fab.setPointerCapture(e.pointerId);
    fab.classList.add('dragging');
  });

  fab.addEventListener('pointermove', (e) => {
    if (!drag.active) return;

    const dx = e.clientX - drag.startX;
    const dy = e.clientY - drag.startY;

    // treat as drag if moved a bit
    if (Math.abs(dx) > 4 || Math.abs(dy) > 4) {
      drag.moved = true;
      clickAllowedAfterDrag = false;
    }

    const appRect = app.getBoundingClientRect();
    let x = drag.origX + dx;
    let y = drag.origY + dy;

    const maxX = appRect.width  - fab.offsetWidth  - 4;
    const maxY = appRect.height - fab.offsetHeight - 4;

    x = Math.max(4, Math.min(maxX, x));
    y = Math.max(4, Math.min(maxY, y));

    fab.style.left   = x + 'px';
    fab.style.top    = y + 'px';
    fab.style.right  = 'auto';
    fab.style.bottom = 'auto';
  });

  function endDrag(e) {
    if (!drag.active) return;
    drag.active = false;
    fab.classList.remove('dragging');
    try {
      if (e && e.pointerId != null) {
        fab.releasePointerCapture(e.pointerId);
      }
    } catch (_) {}
  }

  fab.addEventListener('pointerup', endDrag);
  fab.addEventListener('pointercancel', endDrag);
}



document.addEventListener('DOMContentLoaded', initClientRequestsFloatingUi);

function updateClientReqBadge(count) {
  const badge = document.getElementById("clientReqBadge");
  if (!badge) return;

  if (count > 0) {
    badge.textContent = count;
    badge.classList.remove("hidden");
  } else {
    badge.classList.add("hidden");
  }
}

function updateEventPanelSummary(panelId){
  const panel = document.getElementById(panelId); if(!panel) return;
  const name = panel.querySelector('.event-eventNameMaster')?.value || panel.querySelector('.event-eventNameManual')?.value || '';
  const date = panel.querySelector('.event-eventDate')?.value || '';
  const titleEl = panel.querySelector('.event-title'); if(titleEl) titleEl.textContent = name; // keep the app name input in sync with saved value
const nameInput = document.getElementById('appNameInput');
if (nameInput) nameInput.value = name;

  const subEl = panel.querySelector('.event-sub'); if(subEl) subEl.textContent = date ? `â€¢ ${date}` : '';
}

function collectEventsFromPanels(){
  const panels = Array.from(document.querySelectorAll('#eventsContainer > .event-panel'));
  return panels.map(panel => {
    const name = (panel.querySelector('.event-eventNameMaster')?.value || panel.querySelector('.event-eventNameManual')?.value || '').trim();
    const date = (panel.querySelector('.event-eventDate')?.value || '').trim();

    // package: return BOTH name and price
    let packageName = '';
    let packagePrice = 0;

    const pkgMasterEl = panel.querySelector('.event-packageMaster');
    if (pkgMasterEl) {
      const opt = pkgMasterEl.options[pkgMasterEl.selectedIndex];
      const optText = opt ? (opt.textContent || '') : '';
      packageName = optText.split('â€”')[0].trim();
      packagePrice = parseFloat(opt?.dataset?.price ?? (opt?.getAttribute('data-price') ?? '0')) || 0;
    } else {
      // Try several possible manual selectors (defensive)
      const manualNameSelectors = [
        '.event-packageSelectedManual',
        '.packageManualName',
        '.package-manual-name',
        'input[name="packageName"]'
      ];
      const manualPriceSelectors = [
        '.event-packageManualPrice',
        '.packageManualPrice',
        '.package-manual-price',
        'input[name="packagePrice"]'
      ];

      // find manual name
      for (const s of manualNameSelectors) {
        const el = panel.querySelector(s);
        if (el && (el.value || el.textContent)) {
          packageName = (el.value || el.textContent || '').trim();
          break;
        }
      }

      // find manual price
      for (const s of manualPriceSelectors) {
        const el = panel.querySelector(s);
        if (el) {
          // if it's an input, read .value; otherwise try textContent
          const val = (el.value ?? el.textContent ?? '').toString().trim();
          if (val !== '') {
            packagePrice = parseFloat(val.replace(/[^\d.-]/g, '')) || 0;
            break;
          }
        }
      }

      // If still zero, attempt reading a sibling element (some templates have a different layout)
      if (!packagePrice) {
        const alt = panel.querySelector('input[type="number"], input[type="text"]');
        if (alt && alt !== null) {
          const val = (alt.value ?? '').toString().trim();
          if (val) packagePrice = parseFloat(val.replace(/[^\d.-]/g, '')) || 0;
        }
      }

      if (!packagePrice && packageName) {
        console.warn('collectEventsFromPanels: manual package name found but price missing for:', packageName);
      }
      if (!packageName && packagePrice) {
        console.warn('collectEventsFromPanels: manual package price found but name missing (price=' + packagePrice + ')', panel);
      }
    }

    const addOnPrice = parseFloat(panel.querySelector('.event-addOnPrice')?.value ?? '0') || 0;
    const transportPrice = parseFloat(panel.querySelector('.event-transportPrice')?.value ?? '0') || 0;
    const notes = (panel.querySelector('.event-notes')?.value || '').trim();

    return {
      name,
      date,
      packageName,
      packagePrice,
      addOnPrice,
      transportPrice,
      notes
    };
  });
}



function updateSummaryUI(){
  const events = collectEventsFromPanels();
  const actual = events.reduce((s,e)=> s + Number(e.packagePrice||0) + Number(e.addOnPrice||0) + Number(e.transportPrice||0), 0);
  const discountInput = document.getElementById('quotationDiscount'); let discount = parseFloat(discountInput?.value) || 0; if(discount < 0) discount = 0;
  const finalPrice = Math.max(0, actual - discount);
  document.getElementById('summaryActual').textContent = `â‚¹${actual}`; document.getElementById('summaryFinal').textContent = `â‚¹${finalPrice}`;
}   // <-- keep this

// ===== INVOICE SUMMARY HELPERS =====
function collectInvoiceEventsFromPanels(){
  const panels = Array.from(document.querySelectorAll('#invoiceEventsContainer > .event-panel'));
  return panels.map(panel => {
    // include packageName (master or manual) + price
    let packageName = '';
    let packagePrice = 0;

    const pkgMasterSel = panel.querySelector('.event-packageMaster');
    if (pkgMasterSel) {
      const opt = pkgMasterSel.options[pkgMasterSel.selectedIndex];
      if (opt) {
        packageName = (opt.textContent || '').split('â€”')[0].trim();
        packagePrice = opt.dataset && opt.dataset.price ? parseFloat(opt.dataset.price) : 0;
      }
    } else {
      packageName = (panel.querySelector('.event-packageSelectedManual')?.value || '').trim();
      packagePrice = parseFloat(panel.querySelector('.event-packageManualPrice')?.value || 0) || 0;
    }

    const addOnPrice = parseFloat(panel.querySelector('.event-addOnPrice')?.value || 0);
    const transportPrice = parseFloat(panel.querySelector('.event-transportPrice')?.value || 0);

    return {
      packageName,
      packagePrice,
      addOnPrice,
      transportPrice
    };
  });
}


function updateInvoiceSummaryUI(){
  const events = collectInvoiceEventsFromPanels();
  const actual = events.reduce(
    (s,e)=> s + Number(e.packagePrice||0) + Number(e.addOnPrice||0) + Number(e.transportPrice||0),
    0
  );

  let discount = parseFloat(document.getElementById('invoiceDiscount')?.value || 0);
  if (isNaN(discount) || discount < 0) discount = 0;

  const final = Math.max(0, actual - discount);

  const actualEl = document.getElementById('invoiceSummaryActual');
  const finalEl  = document.getElementById('invoiceSummaryFinal');

  if (actualEl) actualEl.textContent = `â‚¹${actual}`;
  if (finalEl)  finalEl.textContent  = `â‚¹${final}`;
}

//â¬‡ï¸ NOW PASTE THIS WHOLE FUNCTION HERE
function updateInvoiceSummaryUI() {
  const panels = Array.from(
    document.querySelectorAll('#invoiceEventsContainer > .event-panel')
  );

  let actual = 0;

  panels.forEach(panel => {
    // --- package price (from master or manual) ---
    let packagePrice = 0;

    const pkgMasterSel = panel.querySelector('.event-packageMaster');
    if (pkgMasterSel) {
      const opt = pkgMasterSel.options[pkgMasterSel.selectedIndex];
      if (opt && opt.dataset && opt.dataset.price) {
        packagePrice = parseFloat(opt.dataset.price) || 0;
      }
    } else {
      packagePrice = parseFloat(
        panel.querySelector('.event-packageManualPrice')?.value || 0
      );
    }

    const addOnPrice = parseFloat(
      panel.querySelector('.event-addOnPrice')?.value || 0
    );
    const transportPrice = parseFloat(
      panel.querySelector('.event-transportPrice')?.value || 0
    );

    actual +=
      Number(packagePrice || 0) +
      Number(addOnPrice || 0) +
      Number(transportPrice || 0);
  });

  let discount = parseFloat(
    document.getElementById('invoiceDiscount')?.value || 0
  );
  if (isNaN(discount) || discount < 0) discount = 0;

  const final = Math.max(0, actual - discount);

  const actualEl = document.getElementById('invoiceSummaryActual');
  const finalEl  = document.getElementById('invoiceSummaryFinal');

  if (actualEl) actualEl.textContent = `â‚¹${actual}`;
  if (finalEl)  finalEl.textContent  = `â‚¹${final}`;
}

/* clear red fields after input */
function attachFieldClearOnInput(panel) {
  panel.querySelectorAll('.field-error-red').forEach(el => {
    el.addEventListener('input', () => {
      el.classList.remove('field-error-red');
    }, { once: true });
  });
}

// Restrict manual text fields to Aâ€“Z + spaces, and auto-capitalize words
function attachAlphaOnlyCapitalize(inputEl) {
  if (!inputEl) return;

  inputEl.addEventListener('input', () => {
    let v = inputEl.value || '';

    // Keep only letters and spaces
    v = v.replace(/[^a-zA-Z\s]/g, '');

    // Collapse multiple spaces
    v = v.replace(/\s+/g, ' ');

    // Trim left
    v = v.replace(/^\s+/, '');

    if (!v) {
      inputEl.value = '';
      return;
    }

    // Capitalize first letter of each word
    v = v
      .split(' ')
      .map(word =>
        word
          ? word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
          : ''
      )
      .join(' ');

    inputEl.value = v;
  });
}

function attachNumbersOnly(inputEl) {
  if (!inputEl) return;

  inputEl.addEventListener('input', () => {
    // allow digits only
    let v = inputEl.value.replace(/[^0-9]/g, '');

    // Limit to 10 digits max
    if (v.length > 10) v = v.slice(0, 10);

    inputEl.value = v;
  });
}



/* simple validate for update button */
function validateEventPanel(panel){

  const name = (panel.querySelector('.event-eventNameMaster')?.value 
             || panel.querySelector('.event-eventNameManual')?.value 
             || '').trim();

  const date = panel.querySelector('.event-eventDate')?.value || '';

  const pkgPrice = panel.querySelector('.event-packagePrice')?.value 
                || panel.querySelector('.event-packageManualPrice')?.value 
                || 0;

  if (!name)  {
    const f = panel.querySelector('.event-eventNameMaster') || panel.querySelector('.event-eventNameManual');
    if (f) f.classList.add('field-error-red');
    attachFieldClearOnInput(panel);
    return { valid:false, message:'Event name required' };
  }

  if (!date)  {
    const f = panel.querySelector('.event-eventDate');
    if (f) f.classList.add('field-error-red');
    attachFieldClearOnInput(panel);
    return { valid:false, message:'Event date required' };
  }

  if (!(parseFloat(pkgPrice) > 0)) {
    const f = panel.querySelector('.event-packagePrice') || panel.querySelector('.event-packageManualPrice');
    if (f) f.classList.add('field-error-red');
    attachFieldClearOnInput(panel);
    return { valid:false, message:'Package price must be > 0' };
  }

  // ðŸ”´ NEW: transport â†’ requires location
  const locationInput = panel.querySelector('.event-eventLocationManual');
  const locationVal = (locationInput?.value || '').trim();
  const transportRaw = panel.querySelector('.event-transportPrice')?.value;
  const transportPrice = transportRaw === '' || transportRaw == null
    ? 0
    : parseFloat(transportRaw);

  if (transportPrice > 0 && !locationVal) {
    if (locationInput) locationInput.classList.add('field-error-red');
    attachFieldClearOnInput(panel);
    return { valid:false, message:'Location details not entered' };
  }

  // --- Add-on consistency checks (Option C) ---
    // --- Add-on consistency checks ---
  const addonDisplay = panel.querySelector('.event-addon-display');
  const addonManual  = panel.querySelector('.event-addon-manual');

  let addonDetails = '';

  // Same filtering logic as save: ignore placeholders
  if (
    addonDisplay &&
    addonDisplay.textContent &&
    addonDisplay.textContent.trim() &&
    !/Enter \(Text\)/i.test(addonDisplay.textContent) &&
    !/No items selected/i.test(addonDisplay.textContent)
  ) {
    addonDetails = addonDisplay.textContent.trim();
  } else if (addonManual && addonManual.value.trim()) {
    addonDetails = addonManual.value.trim();
  }

  const addonPriceInput = panel.querySelector('.event-addOnPrice');
  const addonPriceRaw   = addonPriceInput?.value;
  const addonPrice =
    addonPriceRaw === '' || addonPriceRaw == null || isNaN(parseFloat(addonPriceRaw))
      ? 0
      : parseFloat(addonPriceRaw);

  // choose a field to highlight when details are missing
  const addonDetailsErrorField = addonManual || addonDisplay;

  // Case 1: details present but price invalid / missing
  if (addonDetails && addonPrice <= 0) {
    if (addonPriceInput) addonPriceInput.classList.add('field-error-red');
    attachFieldClearOnInput(panel);
    return {
      valid: false,
      message: 'Add-on price is required for entered add-on details'
    };
  }

  // Case 2: price present but no details
  if (addonPrice > 0 && !addonDetails) {
    if (addonDetailsErrorField)
      addonDetailsErrorField.classList.add('field-error-red');
    attachFieldClearOnInput(panel);
    return {
      valid: false,
      message: 'Add-on details are required when add-on price is entered'
    };
  }
   // âœ… all good
  return { valid: true, message: '' };
}



/* -------------------------
   Maps: real Google Maps + Places autocomplete + Directions
   Replaces simulatedLocations, handleAutocomplete, resetMapCalculator, calculateDistancePrice
   ------------------------- */

// --- Safe no-op in case any inline handlers still exist ---
function handleAutocomplete() { /* noop: Places handles autocomplete now */ }

// --- Attach PlaceAutocompleteElement (new) with a fallback to Autocomplete (old) ---
function attachPlaceAutocompleteToInput(inputEl) {
  if (!inputEl) return null;

  // New preferred element (if available)
  if (window.google && google.maps && google.maps.places && google.maps.places.PlaceAutocompleteElement) {
    try {
      const elem = new google.maps.places.PlaceAutocompleteElement({
        input: inputEl,
        fields: ['formatted_address', 'geometry', 'name']
      });
      elem.addListener('place_changed', () => {
        const place = elem.getPlace();
        if (place && place.formatted_address) inputEl.value = place.formatted_address;
        // optionally store geometry if needed: place.geometry.location
      });
      return elem;
    } catch (e) {
      console.warn('PlaceAutocompleteElement attach failed, falling back', e);
      // fall through to fallback below
    }
  }

  // Fallback for older clients/accounts â€” Autocomplete
  if (window.google && google.maps && google.maps.places && google.maps.places.Autocomplete) {
    try {
      const ac = new google.maps.places.Autocomplete(inputEl, {
        types: ['geocode', 'establishment'],
        fields: ['formatted_address', 'geometry', 'name']
      });
      ac.addListener('place_changed', () => {
        const p = ac.getPlace();
        if (p && p.formatted_address) inputEl.value = p.formatted_address;
      });
      // ensure suggestions show even if map isn't bound
      try { ac.bindTo && ac.bindTo('bounds', window._gmap || new google.maps.Map(document.createElement('div'))); } catch(e){ /* ignore */ }
      return ac;
    } catch (err) {
      console.warn('Autocomplete fallback failed', err);
    }
  }

  // If nothing available, just return null
  return null;
}

// High-level setup function used by your maps init flow
function setupPlacesAutocomplete() {
  if (!window.google || !google.maps) {
    // SDK not loaded yet â€” ensureMapsInitOnFirstShow will retry later
    return;
  }

  const originEl = document.getElementById('origin');
  const destEl = document.getElementById('destination');

  // remove any old inline handlers to avoid interference
  if (originEl) { originEl.oninput = null; originEl.onfocus = null; originEl.onkeydown = null; }
  if (destEl) { destEl.oninput = null; destEl.onfocus = null; destEl.onkeydown = null; }

  // attach new element / fallback
  window._placeElemOrigin = attachPlaceAutocompleteToInput(originEl);
  window._placeElemDest = attachPlaceAutocompleteToInput(destEl);

  // optional: trigger suggestions when user types (helps on mobile)
  if (originEl && window.google && google.maps && google.maps.event) {
    originEl.addEventListener('keydown', () => { try { google.maps.event.trigger(originEl, 'keydown'); } catch(e){} });
  }
  if (destEl && window.google && google.maps && google.maps.event) {
    destEl.addEventListener('keydown', () => { try { google.maps.event.trigger(destEl, 'keydown'); } catch(e){} });
  }
}

// Google Maps objects (will be initialized on demand)
let _gmap = null;
let _directionsService = null;
let _directionsRenderer = null;
let _placesAutocompleteOrigin = null;
let _placesAutocompleteDestination = null;

function ensureGoogleMapsLoaded() {
  // The app should have already loaded the Maps JS with Places library.
  // If not, you must add the script tag with key & libraries=places.
  if (!window.google || !google.maps) throw new Error('Google Maps SDK not loaded. Add script with &libraries=places');
  if (!_gmap) {
    const el = document.getElementById('map-display');
    if (!el) return; // nothing to initialize
    // create map inside existing display area
    _gmap = new google.maps.Map(el, {
      center: { lat: 20.5937, lng: 78.9629 }, // India center fallback
      zoom: 6,
      mapTypeControl: false,
      fullscreenControl: false,
      streetViewControl: false
    });
    _directionsService = new google.maps.DirectionsService();
    _directionsRenderer = new google.maps.DirectionsRenderer({ suppressMarkers: false });
    _directionsRenderer.setMap(_gmap);
  }
}

// Places Autocomplete setup for origin/destination inputs (keeps existing dropdown behaviour minimal)
function setupPlacesAutocomplete() {
  try {
    ensureGoogleMapsLoaded();
  } catch (e) {
    console.warn('Maps SDK not available for autocomplete', e);
    return;
  }

  const originEl = document.getElementById('origin');
  const destEl = document.getElementById('destination');

  if (originEl && google.maps.places) {
    _placesAutocompleteOrigin = new google.maps.places.Autocomplete(originEl, { types: ['geocode', 'establishment'] });
    _placesAutocompleteOrigin.addListener('place_changed', () => {
      // when user selects, we keep the value and optionally trigger calculation
      // don't force calculate until user clicks Calculate
    });
  }

  if (destEl && google.maps.places) {
    _placesAutocompleteDestination = new google.maps.places.Autocomplete(destEl, { types: ['geocode', 'establishment'] });
    _placesAutocompleteDestination.addListener('place_changed', () => {
      //
    });
  }
}

// preserve the old reset behaviour but clear map and renderer
function resetMapCalculator(){
  ['origin','destination'].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=''; });
  [['pricePerKm','0.50'],['baseCharges','5.00'],['waitingCharges','0.00'],['tollCharges','0.00']].forEach(([id,val])=>{
    const el=document.getElementById(id);
    if (el) el.value = val;
  });
  document.getElementById('isRoundTrip').checked=false;
  const routeTextEl = document.getElementById('route-text');
  if (routeTextEl) routeTextEl.textContent='Route Not Set';
  const costBreakdownEl = document.getElementById('cost-breakdown');
  if (costBreakdownEl) costBreakdownEl.innerHTML='<p class="text-center text-gray-500 pt-2">Enter route details and click calculate.</p>';
  const totalRes = document.getElementById('total-result');
  if (totalRes) totalRes.innerHTML='<span>TOTAL COST</span><span class="app-color-text">â‚¹0.00</span>';
  tempTransportPrice={price:0,source:'manual',description:''};
  document.getElementById('map-confirm-row')?.classList.add('hidden');

  // clear directions from map
  if (_directionsRenderer) {
    _directionsRenderer.setDirections({ routes: [] });
  }
}

// ðŸ”§ Fetch toll estimate for a route using Google Routes API
async function fetchTollForRoute(origin, dest) {
  const apiKey = "AIzaSyCqRTP3fzHbjfJ0ZkDABWm6nPlLaHmhNsY"; // use your existing key (Routes enabled)

  const body = {
    origin: { address: origin },
    destination: { address: dest },
    travelMode: "DRIVE",
    extraComputations: ["TOLLS"],
    routeModifiers: {
      // tweak later if you want passes like FASTag, etc.
      vehicleInfo: { emissionType: "GASOLINE" }
      // tollPasses: ["IN_FASTAG"]
    }
  };

  const resp = await fetch("https://routes.googleapis.com/directions/v2:computeRoutes", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Goog-Api-Key": apiKey,
      "X-Goog-FieldMask": "routes.travelAdvisory.tollInfo"
    },
    body: JSON.stringify(body)
  });

  if (!resp.ok) {
    console.warn("Routes API error:", resp.status, await resp.text());
    return null;
  }

  const data = await resp.json();
  const tollInfo = data.routes?.[0]?.travelAdvisory?.tollInfo;
  if (!tollInfo || !tollInfo.estimatedPrice || !tollInfo.estimatedPrice.length) {
    // Route may have tolls but no price data
    return null;
  }

  // Prefer INR, else take first
  const money = tollInfo.estimatedPrice.find(m => m.currencyCode === "INR")
              || tollInfo.estimatedPrice[0];

  const units = Number(money.units || 0);
  const nanos = Number(money.nanos || 0); // 1e9 nanos = 1 unit
  const value = units + nanos / 1e9;

  return value; // e.g. 245.5
}


// calculateDistancePrice â€” uses DirectionsService to get distance in km and duration
// calculateDistancePrice â€” uses DirectionsService to get distance in km and duration
// DirectionsService + automatic tolls via Routes API
let tempTransportPrice = { price: 0, source: 'manual', description: '' };

async function calculateDistancePrice() {
  const origin = document.getElementById('origin')?.value.trim() || '';
  const dest   = document.getElementById('destination')?.value.trim() || '';
  const perKm  = parseFloat(document.getElementById('pricePerKm')?.value) || 0;
  const base   = parseFloat(document.getElementById('baseCharges')?.value) || 0;
  const wait   = parseFloat(document.getElementById('waitingCharges')?.value) || 0;
  const round  = document.getElementById('isRoundTrip')?.checked || false;

  const tollInputEl = document.getElementById('tollCharges');
  const manualToll  = parseFloat(tollInputEl?.value) || 0;

  if (!origin || !dest) {
    return showMessage('Enter valid Origin and Destination.');
  }
  if (perKm <= 0) {
    return showMessage('Enter a positive Rate per KM');
  }

  // ðŸŒ 1) Try to get toll from Routes API and put it into the Toll Charges field
  let tollFromApi = null;
  try {
    tollFromApi = await fetchTollForRoute(origin, dest);
    if (tollFromApi != null && tollInputEl) {
      tollInputEl.value = tollFromApi.toFixed(0); // reflect automatically in UI
    }
  } catch (e) {
    console.warn("Failed to fetch toll from Routes API", e);
  }

  // Use API toll if available, else manual
  const baseToll = (tollFromApi != null) ? tollFromApi : manualToll;

  // 2) Make sure Maps JS SDK is loaded (for distance + map route)
  try {
    ensureGoogleMapsLoaded();
  } catch (e) {
    console.warn('Maps SDK missing, cannot calculate real route', e);
    return showMessage('Maps SDK not loaded. Please ensure your API key and script are included.');
  }

  const request = {
    origin,
    destination: dest,
    travelMode: google.maps.TravelMode.DRIVING,
    provideRouteAlternatives: false,
    unitSystem: google.maps.UnitSystem.METRIC
  };

  const routeTextEl     = document.getElementById('route-text');
  const costBreakdownEl = document.getElementById('cost-breakdown');

  if (routeTextEl) {
    routeTextEl.textContent = 'Calculating route...';
  }
  if (costBreakdownEl) {
    costBreakdownEl.innerHTML = '<p class="text-sm text-gray-500">Calculating...</p>';
  }
  document.getElementById('map-confirm-row')?.classList.add('hidden');

  _directionsService.route(request, (result, status) => {
    try {
      if (status !== 'OK' || !result || !result.routes || result.routes.length === 0) {
        console.warn('Directions failed', status, result);
        if (routeTextEl) {
          routeTextEl.textContent = 'Route not found.';
        }
        if (costBreakdownEl) {
          costBreakdownEl.innerHTML =
            '<p class="text-sm text-red-500">Route not found.</p>';
        }
        tempTransportPrice = { price: 0, source: 'manual', description: '' };
        return;
      }

            const route = result.routes[0];
      let meters = 0;
      let secs   = 0;

      route.legs.forEach(leg => {
        meters += leg.distance?.value || 0;
        secs   += leg.duration?.value || 0;
      });

      // distance & time
      const kmRaw = meters / 1000;
      const kmForPrice = Math.round(kmRaw);     // for price maths (8 Ã— 36 = 288)
      const mins  = Math.round(secs / 60);
      const hrs   = Math.floor(mins / 60);

      // ðŸ” Round trip: double RATE PER KM and TOLL
      const effectivePerKm = round ? perKm * 2 : perKm;
      const effectiveToll  = round ? baseToll * 2 : baseToll;

      const distanceCharge = kmForPrice * effectivePerKm;
      const totalPrice     = Math.max(
        0,
        Number(base) + Number(distanceCharge) + Number(wait) + Number(effectiveToll)
      );

      // ---------- TEXTS ----------

      // nice readable time text
      const timeText =
  hrs > 0
    ? `${hrs} hr ${mins % 60} min`
    : `${mins} min`;

// 1 decimal for display
const kmText = Math.round(kmRaw);

// update the small line below the map
const infoEl = document.getElementById('map-time-distance');
if (infoEl) {
  infoEl.textContent = `${kmText} km â€¢ ${timeText}`;
}

      // ---------- COST BREAKDOWN UI ----------
      if (costBreakdownEl) {
        costBreakdownEl.innerHTML = `
          <div class="text-sm space-y-1">
            <div class="flex justify-between">
              <span>Base</span>
              <span>â‚¹${base.toFixed(0)}</span>
            </div>

            <div class="flex justify-between">
              <span>
                <span class="font-semibold text-red-600">
                  Distance: ${kmForPrice} km
                </span>
                <span> Ã— â‚¹${effectivePerKm.toFixed(0)}</span>
              </span>
              <span>â‚¹${distanceCharge.toFixed(0)}</span>
            </div>

            <div class="flex justify-between">
              <span>Waiting</span>
              <span>â‚¹${wait.toFixed(0)}</span>
            </div>

            <div class="flex justify-between">
              <span>
                Tolls ${tollFromApi != null ? '(Aprox)' : '(Manual / fallback)'}
              </span>
              <span>â‚¹${effectiveToll.toFixed(0)}</span>
            </div>

            <hr class="my-2"/>
          </div>
        `;
      }



      const totalRes = document.getElementById('total-result');
      if (totalRes) {
        totalRes.innerHTML =
          `<span>TOTAL COST</span><span class="app-color-text">â‚¹${totalPrice}</span>`;
      }

      if (_directionsRenderer) {
        _directionsRenderer.setDirections(result);
      }

       // âœ… Save result for confirmMapPrice() to use
      tempTransportPrice = {
        price: totalPrice,
        source: 'map',
        description: `${origin} to ${dest} - ${kmText} km â€¢ ${timeText}`
      };

      document.getElementById('map-confirm-row')?.classList.remove('hidden');
    } catch (innerErr) {
      console.error('Error processing directions result', innerErr);
      if (routeTextEl) {
        routeTextEl.textContent = 'Route processing failed.';
      }
      if (costBreakdownEl) {
        costBreakdownEl.innerHTML =
          '<p class="text-sm text-red-500">Failed to compute price.</p>';
      }
    }
  });
}


// wire Places autocomplete & map init automatically when maps screen is shown
// Note: navigate('maps') already calls applyDefaultMapValues(); ensure this init runs once
let __mapsInitialized = false;
function ensureMapsInitOnFirstShow(){
  if (__mapsInitialized) return;
  try {
    setupPlacesAutocomplete();
    ensureGoogleMapsLoaded();
  } catch(e){
  console.warn('maps init:', e);
    // silent: SDK might not be loaded yet â€” that's OK
  }
  __mapsInitialized = true;
}

/* -------------------------
   Initialization wiring
   ------------------------- */
function showUpdateToast(msg='Update successful'){ let t=document.getElementById('updateToast'); if(!t){ t=document.createElement('div'); t.id='updateToast'; t.className='update-toast'; document.body.appendChild(t); } t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1600); }

document.addEventListener('DOMContentLoaded', ()=>{
  createLucide();
  migrateEventIds(); persistMissingEventIds();
  applySettings();
  loadMasterData();

  document.getElementById('generateQuotationButton')?.addEventListener('click', saveQuotationMultiEvent);
  document.getElementById('quotationDiscount')?.addEventListener('input', updateSummaryUI);
  document.getElementById('invoiceDiscount')?.addEventListener('input', updateInvoiceSummaryUI);

  document.getElementById('addEventBtn')?.addEventListener('click', () => {
  const addBtn = document.getElementById('addEventBtn');
  if (addBtn && addBtn.disabled) return;   // ðŸ”’ ignore click when greyed out

  const container = document.getElementById('eventsContainer');

  // 1) Collapse all existing event bodies
  if (container) {
    container
      .querySelectorAll('.event-panel .body')
      .forEach(body => body.classList.add('hidden'));
  }

  // 2) Create new event panel
  const id = createEventPanel();
  const newPanel = document.getElementById(id);

  if (newPanel) {
    const body = newPanel.querySelector('.body');
    if (body) body.classList.remove('hidden');

    // 3) Scroll INSIDE the QUOTATION screen (the correct scroll container)
    const scrollContainer = document.getElementById('quotation');
    if (scrollContainer) {
      const offsetTop = newPanel.offsetTop - 16;   // small top margin
      scrollContainer.scrollTo({
        top: offsetTop < 0 ? 0 : offsetTop,
        behavior: 'smooth'
      });
    }
  }

});

if (document.getElementById('eventsContainer')?.children.length === 0)
  createEventPanel();


 // settings image handlers (simple)
const logoInput = document.getElementById('appLogoInput');
logoInput?.addEventListener('change', async (ev) => {
  const file = ev.target.files && ev.target.files[0];
  if (!file) return;

  try {
    // 1) Always create local preview + store in APP_LOGO_KEY
    const fr = new FileReader();
    fr.onload = () => {
      const dataUrl = fr.result;

      try {
        localStorage.setItem(APP_LOGO_KEY, dataUrl);
      } catch (e) {
        console.warn('Failed to store APP_LOGO_KEY', e);
      }

      // Update Settings preview
      const logoPreview   = document.getElementById('appLogoPreview');
      const removeLogoBtn = document.getElementById('removeLogoBtn');

      if (logoPreview && typeof dataUrl === 'string') {
        logoPreview.src = dataUrl;
        logoPreview.classList.remove('hidden');
      }
      if (removeLogoBtn) {
        removeLogoBtn.classList.remove('hidden');
      }

      // Also refresh header avatar based on new logo
      try { updateProfileIcon(); } catch (e) { console.warn(e); }
    };
    fr.readAsDataURL(file);

    // 2) Upload or update logo file in Drive (same logic as before)
    const name = 'app_logo_' + (USE_APPDATA ? 'appdata' : 'file') + '.png';
    const existing = localStorage.getItem('APP_LOGO_FILE_ID');

    if (existing && accessToken) {
      // try update existing file
      try {
        await updateDriveFileContent(existing, file);
      } catch (e) {
        console.warn('Update failed, will try re-upload', e);
        const newId = await uploadDriveFile(name, file);
        localStorage.setItem('APP_LOGO_FILE_ID', newId);
      }
    } else if (accessToken) {
      // either find by name, or upload new
      const found = await findDriveFileIdByName(name);
      if (found && found.id) {
        await updateDriveFileContent(found.id, file);
        localStorage.setItem('APP_LOGO_FILE_ID', found.id);
      } else {
        const id = await uploadDriveFile(name, file);
        localStorage.setItem('APP_LOGO_FILE_ID', id);
      }
    }

    // 3) If signed in, try to refresh any header <img id="appLogo">
    if (accessToken) {
      try {
        const fileId = localStorage.getItem('APP_LOGO_FILE_ID');
        if (fileId) {
          const blob = await downloadDriveFileBlob(fileId);
          const url  = URL.createObjectURL(blob);
          document.getElementById('appLogo')?.setAttribute('src', url);
        }
      } catch (e) {
        console.warn('Could not refresh appLogo from Drive', e);
      }
    } else {
      // not signed in â†’ let applySettings propagate the new logo everywhere
      if (typeof applySettings === 'function') applySettings();
    }

  } catch (err) {
    console.error(err);
    showMessage('Logo upload failed: ' + (err.message || err));
  }
});

  document.getElementById('removeLogoBtn')?.addEventListener('click', ()=>{ localStorage.removeItem(APP_LOGO_KEY); applySettings(); });

  // === Catalogue PDF handlers ===
const catalogueInput = document.getElementById("cataloguePdfInput");
const cataloguePreview = document.getElementById("cataloguePdfPreview");
const removeCatalogueBtn = document.getElementById("removeCataloguePdfBtn");

catalogueInput?.addEventListener("change", (e) => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  if (file.type !== "application/pdf") {
    alert("Please select a PDF file.");
    return;
  }

  const reader = new FileReader();
  reader.onload = () => {
    try {
      localStorage.setItem("catalogue_pdf_dataurl", reader.result);
      localStorage.setItem("catalogue_pdf_name", file.name);

      cataloguePreview.textContent = file.name;
      cataloguePreview.classList.remove("hidden");
      removeCatalogueBtn.classList.remove("hidden");

      if (typeof showUpdateToast === "function") {
        showUpdateToast("Catalogue saved");
      }
    } catch (err) {
      console.warn("Error saving catalogue PDF", err);
      alert("PDF too large. Try a smaller file.");
    }
  };
  reader.readAsDataURL(file);
});

removeCatalogueBtn?.addEventListener("click", () => {
  localStorage.removeItem("catalogue_pdf_dataurl");
  localStorage.removeItem("catalogue_pdf_name");

  cataloguePreview.textContent = "";
  cataloguePreview.classList.add("hidden");
  removeCatalogueBtn.classList.add("hidden");

  if (typeof showUpdateToast === "function") {
    showUpdateToast("Catalogue removed");
  }
});

  const quotationLayoutInput = document.getElementById('quotationLetterheadInput');

quotationLayoutInput?.addEventListener('change', async (ev) => {
  const file = ev.target.files?.[0]; 
  if (!file) return;

  try {
    const img = new Image();
    const fr = new FileReader();

    fr.onload = (e) => (img.src = e.target.result);

    img.onload = () => {
      const scale = Math.min(1200 / img.width, 1);
      const canvas = document.createElement('canvas');
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
      localStorage.setItem(QUOTATION_LAYOUT_KEY, dataUrl);
      applySettings();

      // ðŸ” NEW: save this new layout to Drive, if signed in
      if (typeof autoSaveDrive === 'function') {
        autoSaveDrive('quotation layout updated');
      }
    };

    fr.readAsDataURL(file);
  } catch (e) {
    console.error(e);
    showMessage("Failed to process quotation layout image.");
  }
});

document.getElementById("removeQuotationLayoutBtn")?.addEventListener("click", () => {
  localStorage.removeItem(QUOTATION_LAYOUT_KEY);
  applySettings();

  // ðŸ” NEW: reflect removal in Drive too
  if (typeof autoSaveDrive === 'function') {
    autoSaveDrive('quotation layout removed');
  }
});



const invoiceLayoutInput = document.getElementById('invoiceLetterheadInput');

invoiceLayoutInput?.addEventListener('change', async (ev) => {
  const file = ev.target.files?.[0];
  if (!file) return;

  try {
    const img = new Image();
    const fr = new FileReader();

    fr.onload = (e) => (img.src = e.target.result);

    img.onload = () => {
      const scale = Math.min(1200 / img.width, 1);
      const canvas = document.createElement('canvas');
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
      localStorage.setItem(INVOICE_LAYOUT_KEY, dataUrl);
      applySettings();

      // ðŸ” NEW: save this new layout to Drive, if signed in
      if (typeof autoSaveDrive === 'function') {
        autoSaveDrive('invoice layout updated');
      }
    };

    fr.readAsDataURL(file);
  } catch (e) {
    console.error(e);
    showMessage("Failed to process invoice layout image.");
  }
});

document.getElementById("removeInvoiceLayoutBtn")?.addEventListener("click", () => {
  localStorage.removeItem(INVOICE_LAYOUT_KEY);
  applySettings();

  // ðŸ” NEW: reflect removal in Drive too
  if (typeof autoSaveDrive === 'function') {
    autoSaveDrive('invoice layout removed');
  }
});

 
  document.getElementById('resetSettingsBtn')?.addEventListener('click', () => {
  // ðŸ”” Warning popup before resetting settings
  appConfirm(
    "Are you sure you want to reset all settings?<br><br>" +
    "- App Name<br>" +
    "- App Color<br>" +
    "- App Logo<br>" +
    "- Quotation Layout<br>" +
    "- Invoice Layout<br>" +
    "- Font Size<br><br>" +
    "<b>This action cannot be undone.</b>"
  ).then(go => {

    if (!go) return;  // âŒ Cancel clicked â†’ do nothing

    // âœ… YES clicked â†’ proceed with reset
    localStorage.removeItem(APP_NAME_KEY);
    localStorage.removeItem(APP_COLOR_KEY);
    localStorage.removeItem(APP_LOGO_KEY);
    localStorage.removeItem(QUOTATION_LAYOUT_KEY);
    localStorage.removeItem(INVOICE_LAYOUT_KEY);
    localStorage.removeItem(APP_FONT_KEY);

    applySettings();

    // ðŸ” Sync reset to Drive as well
    if (typeof autoSaveDrive === 'function') {
      autoSaveDrive('settings reset (including layouts)');
    }

    showMessage("All settings have been reset.", "Saved");
  });
});



  // Files search
  document.getElementById('filesSearch')?.addEventListener('input', renderFilesList);
  document.getElementById('filesDate')?.addEventListener('input', renderFilesList);
  document.getElementById('filesMonth')?.addEventListener('change', renderFilesList);
  document.getElementById('paymentStatusFilter')?.addEventListener('change', renderFilesList);

  // ===== FILES â†’ Quotations bulk actions =====
  const quoteSelectAll = document.getElementById('quoteSelectAll');
  if (quoteSelectAll) {
    quoteSelectAll.addEventListener('change', (e) => {
      const checked = e.target.checked;
      document
        .querySelectorAll('#filesList .quote-select')
        .forEach(cb => cb.checked = checked);
    });
  }

  const quoteBulkOk = document.getElementById('quoteBulkOk');
  if (quoteBulkOk) {
    quoteBulkOk.addEventListener('click', () => {
      const action = document.getElementById('quoteBulkAction')?.value || '';
      const ids = getCheckedQuoteIds();

      if (!action) {
        showMessage('Please choose an action for quotations.');
        return;
      }
      if (!ids.length) {
        showMessage('Please select at least one quotation.');
        return;
      }

      ids.forEach(id => {
        // reuse existing single-file handler
        handleFileAction(id, action);
      });
    });
  }

    const quoteBulkDelete = document.getElementById('quoteBulkDelete');
if (quoteBulkDelete) {
  quoteBulkDelete.addEventListener('click', async () => {
    const ids = getCheckedQuoteIds();
    if (!ids.length) {
      showMessage('Please select at least one quotation to delete.');
      return;
    }
    // Use the appConfirm modal instead of window.confirm
    const sure = await appConfirm(
      'Delete selected quotations? This cannot be undone.'
    );
    if (!sure) return;

    const list        = loadFromLS(SAVED_QUOTATIONS_KEY, []) || [];
    const recycleUser = loadFromLS(RECYCLE_USER_KEY, []) || [];
    const nowIso      = new Date().toISOString();

    // Move to Recycle â†’ User Removed
    list.forEach(q => {
      if (ids.includes(String(q.id))) {
        recycleUser.push({
          recycleId: 'recycle_' + Date.now() + '_' + Math.random().toString(36).slice(2),
          type: 'quotation',
          kind: 'quotation',
          label: q.clientName || 'Quotation',
          clientName: q.clientName,
          clientContact: q.clientContact,
          quotationId: q.id,
          quotationNo: q.quotationNo,
          removedAt: nowIso,
          reason: 'Deleted from Files â†’ Quotations (user)',
          original: q
        });
      }
    });

    saveToLS(RECYCLE_USER_KEY, recycleUser);

    const remaining = list.filter(q => !ids.includes(String(q.id)));
    saveToLS(SAVED_QUOTATIONS_KEY, remaining);
    renderFilesList();

    // ðŸ” auto-save to Drive after delete
    try {
      if (typeof saveToDrive === 'function' && accessToken) {
        saveToDrive();
      }
    } catch (e) {
      console.warn('Auto-save to Drive after quotation delete failed:', e);
    }
  });
}



  // ===== FILES â†’ Invoices bulk actions =====
  const invoiceSelectAll = document.getElementById('invoiceSelectAll');
  if (invoiceSelectAll) {
    invoiceSelectAll.addEventListener('change', (e) => {
      const checked = e.target.checked;
      document
        .querySelectorAll('#invoicesList .invoice-select')
        .forEach(cb => cb.checked = checked);
    });
  }

  const invoiceBulkOk = document.getElementById('invoiceBulkOk');
  if (invoiceBulkOk) {
    invoiceBulkOk.addEventListener('click', () => {
      const action = document.getElementById('invoiceBulkAction')?.value || '';
      const ids = getCheckedInvoiceIds();

      if (!action) {
        showMessage('Please choose an action for invoices.');
        return;
      }
      if (!ids.length) {
        showMessage('Please select at least one invoice.');
        return;
      }

      ids.forEach(id => {
        // reuse existing single-invoice handler
        handleInvoiceAction(id, action);
      });
    });
  }

    const invoiceBulkDelete = document.getElementById('invoiceBulkDelete');
if (invoiceBulkDelete) {
  invoiceBulkDelete.addEventListener('click', async () => {
    const ids = getCheckedInvoiceIds();
    if (!ids.length) {
      showMessage('Please select at least one invoice to delete.');
      return;
    }
    // Use the appConfirm modal instead of window.confirm
    const sure = await appConfirm(
      'Delete selected invoices? This cannot be undone.'
    );
    if (!sure) return;

    const list        = loadFromLS(SAVED_INVOICES_KEY, []) || [];
    const recycleUser = loadFromLS(RECYCLE_USER_KEY, []) || [];
    const nowIso      = new Date().toISOString();

    // Move to Recycle â†’ User Removed
    list.forEach(inv => {
      const idForInvoice = inv.invoiceId || inv.id;
      if (ids.includes(String(idForInvoice))) {
        recycleUser.push({
          recycleId: 'recycle_' + Date.now() + '_' + Math.random().toString(36).slice(2),
          type: 'invoice',
          kind: 'invoice',
          label: inv.clientName || 'Invoice',
          clientName: inv.clientName,
          clientContact: inv.clientContact,
          invoiceId: idForInvoice,
          invoiceNo: inv.invoiceNo,
          removedAt: nowIso,
          reason: 'Deleted from Files â†’ Invoices (user)',
          original: inv
        });
      }
    });

    saveToLS(RECYCLE_USER_KEY, recycleUser);

    const remaining = list.filter(inv => {
      const idForInvoice = inv.invoiceId || inv.id;
      return !ids.includes(String(idForInvoice));
    });
    saveToLS(SAVED_INVOICES_KEY, remaining);
    renderFilesList();

    // ðŸ” auto-save to Drive after delete
    try {
      if (typeof saveToDrive === 'function' && accessToken) {
        saveToDrive();
      }
    } catch (e) {
      console.warn('Auto-save to Drive after invoice delete failed:', e);
    }
  });
}




    // Invoice add event behavior (reuse event panel and move, with dirty + scroll)
document.getElementById('invoiceAddEventBtn')?.addEventListener('click', () => {
  const addBtn = document.getElementById('invoiceAddEventBtn');
  if (addBtn && addBtn.disabled) return;   // ðŸ”’ ignore when greyed out

  const invContainer = document.getElementById('invoiceEventsContainer');

  // 1) Collapse all existing event bodies in INVOICE
  if (invContainer) {
    invContainer
      .querySelectorAll('.event-panel .body')
      .forEach(body => body.classList.add('hidden'));
  }

  // 2) Create new event panel (created in quotation container)
  const panelId = createEventPanel();
  const newPanel = document.getElementById(panelId);

  if (newPanel) {
    // move panel to invoice container
    if (invContainer) {
      invContainer.appendChild(newPanel);
    }

    const body = newPanel.querySelector('.body');
    if (body) body.classList.remove('hidden');

    // 3) Scroll INSIDE the INVOICE screen
    const scrollContainer = document.getElementById('invoice');
    if (scrollContainer) {
      const offsetTop = newPanel.offsetTop - 16; // small top margin
      scrollContainer.scrollTo({
        top: offsetTop < 0 ? 0 : offsetTop,
        behavior: 'smooth'
      });
    }
  }

  if (typeof updateInvoiceSummaryUI === 'function') {
    updateInvoiceSummaryUI();
  }

  // ðŸ” recompute add-event states for both screens
  recomputeAddEventState();
});

// Invoice save button
// Invoice save button (REPLACEMENT - paste entire handler to replace old one)
document.getElementById('generateInvoiceButton')?.addEventListener('click', async () => {
  const nameEl    = document.getElementById('invoiceClientNameInput');
  const contactEl = document.getElementById('invoiceClientContactInput');

  const clientNameRaw    = nameEl?.value || '';
  const clientContactRaw = contactEl?.value || '';

  const clientName = clientNameRaw.trim();
  let clientContact = clientContactRaw.trim();

  // Basic validation
  if (!clientName || !clientContact) {
    showMessage('Client name and contact are required.');
    return;
  }

  // ðŸ“ž Same rule as quotation: contact must be exactly 10 digits
  const digitsOnly = clientContact.replace(/\D/g, '');
  if (digitsOnly.length !== 10) {
    showMessage('Client contact number must be exactly 10 digits.');
    if (contactEl) contactEl.focus();
    return;
  }
  clientContact = digitsOnly;
  if (contactEl) {
    contactEl.value = digitsOnly; // normalise value in the field
  }

  const panels = Array.from(
    document.querySelectorAll('#invoiceEventsContainer > .event-panel')
  );
  if (panels.length === 0) {
    showMessage('Add at least one event.');
    return;
  }

  // Apply same event restrictions used by the Update button
  for (const panel of panels) {
    const res = validateEventPanel(panel);
    if (!res.valid) {
      showMessage(res.message);
      try {
        panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (e) {}
      return;
    }
  }

  // Build events from panels â€” use the same logic as quotation (detect by element presence)
  // Build events from panels â€” include time, location and eventId (same as quotation)
const events = panels.map(panel => {
  const name = (
    panel.querySelector('.event-eventNameMaster')?.value ||
    panel.querySelector('.event-eventNameManual')?.value ||
    ''
  ).trim();
  const date = (panel.querySelector('.event-eventDate')?.value || '').trim();

  // time parts (hour, minute, period)
  const hour = panel.querySelector('.event-eventHour')?.value ?? '';
  const minute = panel.querySelector('.event-eventMinute')?.value ?? '';
  const period = panel.querySelector('.event-eventPeriod')?.value ?? '';

  // package (detect by element presence)
  let packageName = '';
  let packagePrice = 0;
  const pkgMasterSel = panel.querySelector('.event-packageMaster');
  if (pkgMasterSel) {
    const opt = pkgMasterSel.options[pkgMasterSel.selectedIndex];
    packageName = opt ? (opt.textContent || '').split('â€”')[0].trim() : '';
    packagePrice = opt && opt.dataset && opt.dataset.price
      ? parseFloat(opt.dataset.price)
      : 0;
  } else {
    packageName = (panel.querySelector('.event-packageSelectedManual')?.value || '').trim();
    packagePrice = parseFloat(panel.querySelector('.event-packageManualPrice')?.value || 0) || 0;
  }

  // --- Add-on details (same as quotation) ---
  let addonDetails = '';
  const addonDisplay = panel.querySelector('.event-addon-display');
  const addonManual  = panel.querySelector('.event-addon-manual');

  if (
    addonDisplay &&
    addonDisplay.textContent &&
    addonDisplay.textContent.trim() &&
    !/Enter \(Text\)/i.test(addonDisplay.textContent) &&
    !/No items selected/i.test(addonDisplay.textContent)
  ) {
    addonDetails = addonDisplay.textContent.trim();
  } else if (addonManual && addonManual.value.trim()) {
    addonDetails = addonManual.value.trim();
  }

  const addOnPrice = parseFloat(panel.querySelector('.event-addOnPrice')?.value || 0) || 0;
  const transportRaw = panel.querySelector('.event-transportPrice')?.value;
  const transportPrice = transportRaw === undefined || transportRaw === null || transportRaw === ''
    ? NaN
    : parseFloat(transportRaw);

  const notes = (panel.querySelector('.event-notes')?.value || '').trim();

  // ---- location ----
  const locationVal = panel.querySelector('.event-eventLocationManual')?.value?.trim() || '';

  // ---- eventId (preserve existing if panel was loaded with one) ----
  const existingId = panel.dataset.eventId;
  const eventId = existingId || (typeof uid === 'function' ? uid('ev') : ('ev_' + Date.now()));

  // compose time string exactly like quotation code uses
  const time = `${hour || ''}:${minute || ''} ${period || ''}`.trim();

  return {
    eventId,
    name: name.trim(),
    date,
    time,
    packageName,
    packagePrice,
    addonDetails,
    addOnPrice,
    transportPrice: isNaN(transportPrice) ? undefined : transportPrice,
    location: locationVal,
    notes
  };
});


  // totals
  const actual = events.reduce(
    (s, e) =>
      s +
      (Number(e.packagePrice || 0) +
       Number(e.addOnPrice || 0) +
       Number(e.transportPrice || 0)),
    0
  );

  let discount = parseFloat(
    document.getElementById('invoiceDiscount')?.value || 0
  );
  if (isNaN(discount) || discount < 0) discount = 0;

  const final = Math.max(0, actual - discount);

  // update summary UI
  if (typeof updateInvoiceSummaryUI === 'function') {
    updateInvoiceSummaryUI();
  }

  const base = { clientName, clientContact, events, actual, final };
  if (discount > 0) base.discount = Number(discount);

  // Save / dedupe logic (keeps parity with quotation flow)
  const invoices = loadFromLS(SAVED_INVOICES_KEY, []) || [];

  // Duplicate check similar to quotation
  const nameKey = clientName.toLowerCase();
  const contactKey = clientContact.toLowerCase();
  const duplicateInvoice = invoices.find(inv => {
    const n = (inv.clientName || '').trim().toLowerCase();
    const c = (inv.clientContact || '').trim().toLowerCase();
    if (CURRENT_EDIT_INVOICE_ID && (inv.invoiceId || inv.id) === CURRENT_EDIT_INVOICE_ID) {
      return false;
    }
    return n === nameKey && c === contactKey;
  });

  if (duplicateInvoice) {
    const go = await appConfirm(
      'Duplicate Invoice found for this Client name and Contact.\n\nDo you want to open & edit that Invoice?'
    );
    if (go) {
      localStorage.setItem('CURRENT_EDIT_INVOICE', JSON.stringify(duplicateInvoice));
      navigate('files', { skipInit: false });
      return;
    }
  }

  // Build target invoice object (new or update)
  let targetInvoice;
  const nowIso = new Date().toISOString();
  if (CURRENT_EDIT_INVOICE_ID) {
    // update existing
    const idx = invoices.findIndex(inv => (inv.invoiceId || inv.id) === String(CURRENT_EDIT_INVOICE_ID));
    if (idx >= 0) {
      targetInvoice = Object.assign({}, invoices[idx], base);
      targetInvoice.updatedAt = nowIso;
      invoices[idx] = targetInvoice;
    } else {
      targetInvoice = Object.assign({ invoiceId: 'inv_' + Date.now(), createdAt: nowIso }, base);
      invoices.push(targetInvoice);
    }
  } else {
    // new invoice
    targetInvoice = Object.assign({ invoiceId: 'inv_' + Date.now(), createdAt: nowIso }, base);
    invoices.push(targetInvoice);
  }

  saveToLS(SAVED_INVOICES_KEY, invoices);

  // Set current viewed context
  window.CURRENT_VIEWED_INVOICE = {
    id: targetInvoice.invoiceId || targetInvoice.id,
    actual,
    discount,
    final,
    invoice: targetInvoice
  };

  renderFilesList();
  if (typeof autoSaveDrive === 'function') autoSaveDrive('invoice saved from invoice screen');

  showMessage('Invoice saved.', 'Invoice');

  // optional: navigate to files list or open the saved invoice view
    navigate('files'); // uncomment if you want to jump to Files
});


  // ðŸ”¹ Auto-clean client requests older than 30 days from System removed
cleanupOldClientRequestSystemRemoved();

  // init
  renderFilesList();
  renderCalendar();
   // init
  renderFilesList();
  renderCalendar();

  // ðŸ”’ Force sign-in before using full app
  let firstScreen = 'dashboard';
  try {
    const isSigned = localStorage.getItem('gdrive_signed_in') === '1';

    if (isSigned) {
      firstScreen = 'dashboard';
    } else {
      // send user straight to Settings so they see the Google sign-in area
      firstScreen = 'settings';

      const msg =
        'Please sign in with Google Drive to use the app.\n' +
        'Go to Settings and tap "Sign in with Google".';
      if (typeof showMessage === 'function') {
        showMessage(msg, 'Sign in required');
      } else {
        alert(msg);
      }
    }
  } catch (e) {
    console.warn('Sign-in check failed, falling back to dashboard', e);
  }

  navigate(firstScreen, { pushHistory: false });
});

// Single canonical Save Settings handler â€” safe and defensive
(function attachCanonicalSaveSettings(){
  const btn = document.getElementById('saveSettingsBtn');
  if (!btn) { console.warn('saveSettingsBtn not found â€” handler not attached'); return; }
  // remove any previous handler to avoid duplicates
  btn.onclick = null;
  // remove potential previously attached listeners (best-effort)
  try { btn.replaceWith(btn.cloneNode(true)); } catch(e) { /* ignore */ }

  // re-query the button after clone (to attach listener to the real element)
  const realBtn = document.getElementById('saveSettingsBtn');
  if (!realBtn) return;

  realBtn.addEventListener('click', function(){
    try {
     // prefer typed value; if empty, use stored name (parsed if JSON), else final fallback
const name = (() => {
  const typed = (document.getElementById('appNameInput')?.value || '').trim();
  if (typed) return typed;
  // read stored value (may be JSON string)
  try {
    const raw = localStorage.getItem(APP_NAME_KEY);
    const parsed = raw ? JSON.parse(raw) : null;
    if (parsed && typeof parsed === 'string') return parsed;
  } catch(e) { /* ignore parse error and fallthrough */ }
  return 'My Business App';
})();

      let color = (document.getElementById('appColorInput')?.value || '#3b82f6').trim();
      const fontSize = (document.getElementById('appFontSize')?.value || '16').toString();

      // Validate color (must be #rrggbb); fallback if invalid
      if (!/^#([0-9a-fA-F]{6})$/.test(color)) {
        console.warn('SaveSettings: invalid color chosen, falling back to #3b82f6', color);
        color = '#3b82f6';
      }

      // Use saveToLS helper if present (it should handle serialization once)
      if (typeof saveToLS === 'function') {
        saveToLS(APP_NAME_KEY, name);
        saveToLS(APP_COLOR_KEY, color);
        saveToLS(APP_FONT_KEY, fontSize);
      } else {
        // Fallback: write plain JSON once
        localStorage.setItem(APP_NAME_KEY, JSON.stringify(name));
        localStorage.setItem(APP_COLOR_KEY, JSON.stringify(color));
        localStorage.setItem(APP_FONT_KEY, JSON.stringify(fontSize));
      }

      // Re-apply immediately
      if (typeof applySettings === 'function') applySettings();

      // feedback
      const msg = document.getElementById('settings-message');
      if (msg) { msg.style.visibility = 'visible'; setTimeout(()=>{ msg.style.visibility='hidden'; }, 1400); }
      
    } catch(err) {
      console.error('Save settings error', err);
      showMessage('Unable to save settings. See console for details.', 'Save Error');
    }
  });
})();

</script>

<!-- Google Identity + Drive helpers Hari -->
<script>
const USE_APPDATA = true; // use appDataFolder (hidden) for app data
const APP_FILENAME = 'myapp-data.json';

let tokenClient = null;
let accessToken = null;
let userProfile = null;

function initGoogleTokenClient(){
  if (!window.google || !google.accounts || !google.accounts.oauth2) {
    setTimeout(initGoogleTokenClient, 500);
    return;
  }
  if (tokenClient) return;
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: (USE_APPDATA ? 'https://www.googleapis.com/auth/drive.appdata' : 'https://www.googleapis.com/auth/drive.file') + ' openid email profile',
    callback: (resp) => {
      if (resp.error) {
        console.error('Token error', resp);
        document.getElementById('gdrive-status').innerText = 'Sign-in required';
        // ðŸ”´ Treat silent failure as signed out
        accessToken = null;
        userProfile = null;
        try {
          localStorage.removeItem('gdrive_signed_in');
        } catch (e) {}

        // Reset UI similar to signOutFromGoogle
        document.getElementById('gdrive-user').innerText = 'Not signed in';
        document.getElementById('btnSignIn').style.display  = 'inline-block';
        document.getElementById('btnSignOut').style.display = 'none';
        document.getElementById('btnSaveDrive').style.display = 'none';
        document.getElementById('btnLoadDrive').style.display = 'none';

        // Hide client requests FAB when not signed in
        try {
          const fab   = document.getElementById('clientRequestsFab');
          const panel = document.getElementById('clientRequestsPanel');
          if (fab)   fab.classList.add('hidden');
          if (panel) panel.classList.add('hidden');
        } catch (e) {}

        // Update dashboard + avatar
        try { updateDashboardForSignIn(); } catch (e) {}
        updateProfileIcon();

        return;
      }
      accessToken = resp.access_token;
      window.accessToken = accessToken;
      onSignedIn();
    }
  });
}

function signInWithGoogle(){
  if (!tokenClient) initGoogleTokenClient();
  tokenClient.requestAccessToken({ prompt: 'consent' });
}

function updateProfileIcon() {
  const avatarEl  = document.getElementById("profileAvatar");
  const defaultEl = document.getElementById("profileIconDefault");

  if (!avatarEl || !defaultEl) return;

  const logoData = localStorage.getItem(APP_LOGO_KEY) || "";
  const isSigned = localStorage.getItem('gdrive_signed_in') === '1';

  if (isSigned && logoData) {
    // show app logo as avatar
    avatarEl.src = logoData;
    avatarEl.classList.remove("hidden");
    defaultEl.classList.add("hidden");
  } else {
    // show default Lucide icon
    defaultEl.classList.remove("hidden");
    avatarEl.classList.add("hidden");
  }
}


async function onSignedIn() {
  if (!accessToken) return;
  document.getElementById('gdrive-status').innerText = 'Signed in â€” fetching profile.';
  try {
    const r = await fetch('https://www.googleapis.com/oauth2/v1/userinfo?alt=json', {
      headers: { Authorization: 'Bearer ' + accessToken }
    });
    if (r.ok) {
      userProfile = await r.json();

      document.getElementById('gdrive-user').innerText =
        userProfile.email || 'Signed in';
      document.getElementById('btnSignIn').style.display  = 'none';
      document.getElementById('btnSignOut').style.display = 'inline-block';
      document.getElementById('btnSaveDrive').style.display = 'inline-block';
      document.getElementById('btnLoadDrive').style.display = 'inline-block';
      document.getElementById('gdrive-status').innerText =
        'Signed in as ' + (userProfile.email || '');

      const userSettingsBtn = document.getElementById('btnUserProfileSettings');
      if (userSettingsBtn) userSettingsBtn.style.display = 'block';

      // remember we are signed in
      try { localStorage.setItem('gdrive_signed_in', '1'); } catch (e) {}

      // ðŸ’¾ Also remember email as ownerId for client requests
      try {
        if (userProfile.email) {
          localStorage.setItem(
            'client_req_owner_email',
            String(userProfile.email).trim().toLowerCase()
          );
        }
      } catch (e) {
        console.warn('Could not store client_req_owner_email', e);
      }

      // âœ… Show floating Client Requests FAB after sign-in
      try {
        const fab   = document.getElementById('clientRequestsFab');
        const panel = document.getElementById('clientRequestsPanel');
        if (fab)   fab.classList.remove('hidden');
        if (panel) panel.classList.add('hidden');
      } catch (e) {
        console.warn('Failed to update client-req FAB on sign-in', e);
      }

      try { updateDashboardForSignIn(); } catch (e) {}

      // ðŸ” update header avatar based on sign-in + app logo
      updateProfileIcon();

      // === AUTO-LOAD FROM DRIVE ON SIGN-IN ===
      document.getElementById('gdrive-status').innerText =
        'Signed in â€” loading saved data...';

      try {
        await loadFromDrive();   // merges data into localStorage

        // Re-apply UI immediately so images/letterheads show
        if (typeof applySettings === 'function') applySettings();
        if (typeof renderFilesList === 'function') renderFilesList();
        if (typeof renderCalendar === 'function') renderCalendar();
        if (typeof updateSummaryUI === 'function') updateSummaryUI();
        if (typeof updateInvoiceSummaryUI === 'function') updateInvoiceSummaryUI();
        try { updateDashboardUpcomingEvents(); } catch (e) {}

        document.getElementById('gdrive-status').innerText = 'Loaded saved data';
      } catch (e) {
        console.warn('Auto-load failed', e);
        document.getElementById('gdrive-status').innerText =
          'Signed in (no saved data)';
      }
      // === END AUTO-LOAD SECTION ===
    } else {
      document.getElementById('gdrive-status').innerText =
        'Failed to fetch profile';
    }
  } catch (e) {
    console.error(e);
    document.getElementById('gdrive-status').innerText =
      'Failed to fetch profile';
  }
}

function signOutFromGoogle(){
  const resetUi = () => {
    accessToken = null;
    userProfile = null;
    tokenClient = null;

    document.getElementById('gdrive-user').innerText = 'Not signed in';
    document.getElementById('btnSignIn').style.display  = 'inline-block';
    document.getElementById('btnSignOut').style.display = 'none';
    document.getElementById('btnSaveDrive').style.display = 'none';
    document.getElementById('btnLoadDrive').style.display = 'none';
    document.getElementById('gdrive-status').innerText = '';
    localStorage.removeItem('gdrive_signed_in');
        // ðŸ”’ Hide floating Client Requests FAB when signed out
    try {
      const fab   = document.getElementById('clientRequestsFab');
      const panel = document.getElementById('clientRequestsPanel');
      if (fab)   fab.classList.add('hidden');
      if (panel) panel.classList.add('hidden');
    } catch (e) {
      console.warn('Failed to hide client-req FAB on sign-out', e);
    }

    try { updateDashboardForSignIn(); } catch (e) {}
    const userSettingsBtn = document.getElementById('btnUserProfileSettings');
    if (userSettingsBtn) userSettingsBtn.style.display = 'none';

    // ðŸ” when logged out, go back to default icon
    updateProfileIcon();
  };

  if (accessToken) {
    fetch('https://oauth2.googleapis.com/revoke?token=' + accessToken, {
      method: 'POST'
    })
      .catch(e => console.warn('Revoke failed', e))
      .finally(resetUi);
  } else {
    resetUi();
  }
}


async function findFileId(name){
  const q = `name='${name.replace(/'/g,"\\\\'")}' and trashed=false`;
  const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&spaces=${USE_APPDATA ? 'appDataFolder' : 'drive'}&fields=files(id,name)`;
  const r = await fetch(url, { headers: { Authorization: 'Bearer ' + accessToken }});
  const j = await r.json();
  return (j.files && j.files[0] && j.files[0].id) || null;
}

// ---------- Drive file helpers (images / pdf) Hari----------

// find file in appDataFolder or drive by name
async function findDriveFileIdByName(name){
  const q = `name='${name.replace(/'/g,"\\'")}' and trashed=false`;
  const space = USE_APPDATA ? 'appDataFolder' : 'drive';
  const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&spaces=${space}&fields=files(id,name,mimeType)`;
  const r = await fetch(url, { headers: { Authorization: 'Bearer ' + accessToken }});
  const j = await r.json();
  return (j.files && j.files[0]) ? j.files[0] : null;
}

// upload a new file (multipart using FormData) -> returns fileId
async function uploadDriveFile(name, fileBlob){
  const metadata = { name, mimeType: fileBlob.type || 'application/octet-stream' };
  if (USE_APPDATA) metadata.parents = ['appDataFolder'];

  const form = new FormData();
  form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
  form.append('file', fileBlob);

  const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id', {
    method: 'POST',
    headers: { Authorization: 'Bearer ' + accessToken },
    body: form
  });
  if (!res.ok) throw new Error('Upload failed: ' + await res.text());
  return (await res.json()).id;
}

// update existing file content (PATCH with uploadType=media)
async function updateDriveFileContent(fileId, fileBlob){
  const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;
  const res = await fetch(url, {
    method: 'PATCH',
    headers: {
      Authorization: 'Bearer ' + accessToken,
      'Content-Type': fileBlob.type || 'application/octet-stream'
    },
    body: fileBlob
  });
  if (!res.ok) throw new Error('Update failed: ' + await res.text());
  return (await res.json()).id;
}

// fetch file blob by id
async function downloadDriveFileBlob(fileId){
  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers: { Authorization: 'Bearer ' + accessToken }
  });
  if (!res.ok) throw new Error('Download failed: ' + await res.text());
  return await res.blob();
}

// ---------- end Drive file helpers Hari----------


async function uploadJsonFile(name, jsonObj){
  // metadata for file
  const metadata = { name, mimeType: 'application/json' };
  if (USE_APPDATA) metadata.parents = ['appDataFolder'];

  // create JSON body
  const jsonStr = JSON.stringify(jsonObj);

  // Use a random boundary (browser will handle content-length)
  const boundary = '-------314159265358979323846'; // stable string is fine
  const delimiter = "\r\n--" + boundary + "\r\n";
  const close_delim = "\r\n--" + boundary + "--";

  // Build parts as Blobs to avoid encoding issues
  const metaPart = new Blob(
    [ 'Content-Type: application/json; charset=UTF-8\r\n\r\n', JSON.stringify(metadata) ],
    { type: 'application/json' }
  );

  const jsonPart = new Blob(
    [ 'Content-Type: application/json\r\n\r\n', jsonStr ],
    { type: 'application/json' }
  );

  // Build full multipart/related body as array of parts
  const bodyParts = [
    // starting boundary must be at the very start
    new Blob([ '--' + boundary + '\r\n' ]),
    // metadata headers (no extra 'Content-Type' outside metaPart)
    new Blob([ 'Content-Type: application/json; charset=UTF-8\r\n\r\n' ]),
    new Blob([ JSON.stringify(metadata) ]),
    new Blob([ '\r\n--' + boundary + '\r\n' ]),
    new Blob([ 'Content-Type: application/json\r\n\r\n' ]),
    new Blob([ jsonStr ]),
    new Blob([ '\r\n--' + boundary + '--\r\n' ])
  ];

  const multipartBlob = new Blob(bodyParts, { type: 'multipart/related; boundary=' + boundary });

  const uploadUrl = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id';
  const res = await fetch(uploadUrl, {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + accessToken,
      // Note: do NOT set Content-Type manually to include boundary; browser will set it from the Blob
      // 'Content-Type': 'multipart/related; boundary="' + boundary + '"' 
    },
    body: multipartBlob
  });

  // if fetch returned non-OK, throw the response text for error handling
  if (!res.ok) {
    const text = await res.text().catch(()=>'<no response body>');
    throw new Error('Upload failed: HTTP ' + res.status + ' â€” ' + text);
  }
  return (await res.json()).id;
}

async function updateJsonFile(fileId, jsonObj){
  const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;
  const res = await fetch(url, {
    method: 'PATCH',
    headers: {
      'Authorization': 'Bearer ' + accessToken,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(jsonObj)
  });
  if (!res.ok) throw new Error(await res.text());
  return (await res.json()).id;
}

async function saveToDrive(){
  if (!accessToken) { alert('Please sign in first'); return; }
  document.getElementById('gdrive-status').innerText = 'Preparing data...';
  const data = {};
  for (let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    try { data[k] = JSON.parse(localStorage.getItem(k)); } catch(e) { data[k] = localStorage.getItem(k); }
  }
  const payload = { savedAt: new Date().toISOString(), data };
  try {
    const existingId = await findFileId(APP_FILENAME);
    if (existingId) {
      await updateJsonFile(existingId, payload);
      document.getElementById('gdrive-status').innerText = 'Updated Drive';
    } else {
      await uploadJsonFile(APP_FILENAME, payload);
      document.getElementById('gdrive-status').innerText = 'Saved to Drive';
      alert('Data saved to Drive.');
    }
  } catch (e) {
  console.error("Drive upload failed:", e);

  showMessage("Upload failed! Please try again.", "error");

  // Show the Contact Admin error bar
  const bar = document.getElementById("contactDevBar");
  if (bar) bar.style.display = "block";
 }
}

let autoSaveTimer = null;
function autoSaveDrive(reason) {
  if (!accessToken) {
    // Not signed in â†’ just keep local changes, nothing to sync.
    return;
  }

  try {
    // Debounce a little so multiple quick actions don't spam Drive
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(() => {
      autoSaveTimer = null;
      console.log('Auto-saving to Drive:', reason || '(no reason)');
      saveToDrive();
    }, 1500);
  } catch (e) {
    console.warn('autoSaveDrive failed', e);
  }
}


async function loadFromDrive(){
  if (!accessToken) { alert('Please sign in first'); return; }
  document.getElementById('gdrive-status').innerText = 'Downloading...';
  const fileId = await findFileId(APP_FILENAME);
  if (!fileId) { alert('No saved file found on Drive'); document.getElementById('gdrive-status').innerText = 'No file found'; return; }
  const r = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers: { Authorization: 'Bearer ' + accessToken }
  });
  if (!r.ok) { alert('Download failed: ' + await r.text()); document.getElementById('gdrive-status').innerText = 'Download failed'; return; }
  const payload = await r.json();
if (!payload || !payload.data) {
  alert('Drive file has no data.');
  return;
}

async function autoSyncFromDrive() {
  if (!accessToken) return;

  try {
    const fileId = await findFileId(APP_FILENAME);
    if (!fileId) {
      // nothing saved yet -> nothing to sync
      return;
    }

    const r = await fetch(
      `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
      { headers: { Authorization: 'Bearer ' + accessToken } }
    );

    if (!r.ok) {
      console.warn('Auto-sync download failed:', await r.text());
      return;
    }

    const payload = await r.json();
    if (!payload || !payload.data) return;

    // Same merge logic as loadFromDrive, but no alerts
    Object.keys(payload.data).forEach(k => {
      const v = payload.data[k];
      if (typeof v === 'string') {
        try { localStorage.setItem(k, v); } catch (e) {}
      } else {
        try { localStorage.setItem(k, JSON.stringify(v)); }
        catch (e) { localStorage.setItem(k, String(v)); }
      }
    });

    try {
      if (typeof applySettings === 'function') applySettings();
      if (typeof renderFilesList === 'function') renderFilesList();
      if (typeof renderCalendar === 'function') renderCalendar();
      if (typeof updateSummaryUI === 'function') updateSummaryUI();
      if (typeof updateInvoiceSummaryUI === 'function') updateInvoiceSummaryUI();
    } catch (e) {
      console.warn('Auto-sync UI refresh failed', e);
    }

    console.log('Auto-synced from Drive at', new Date().toISOString());
  } catch (e) {
    console.warn('Auto-sync from Drive failed:', e);
  }
}


// ===== FIX: store strings as plain strings, stringify objects only =====
Object.keys(payload.data).forEach(k => {
  const v = payload.data[k];
  if (typeof v === 'string') {
    // store raw string (this preserves data:image/... without extra quotes)
    try { localStorage.setItem(k, v); } catch (e) { /* ignore storage errors */ }
  } else {
    // objects/arrays/numbers -> stringify safely
    try { localStorage.setItem(k, JSON.stringify(v)); } catch (e) { localStorage.setItem(k, String(v)); }
  }
});

// ===== Immediately re-apply UI so images/letterheads show without manual refresh =====
try {
  if (typeof applySettings === 'function') applySettings();
  if (typeof renderFilesList === 'function') renderFilesList();
  if (typeof renderCalendar === 'function') renderCalendar();
  if (typeof updateSummaryUI === 'function') updateSummaryUI();
  if (typeof updateInvoiceSummaryUI === 'function') updateInvoiceSummaryUI();
} catch (e) {
  console.warn('Re-apply UI after load failed', e);
}

document.getElementById('gdrive-status').innerText = 'Loaded into localStorage and UI updated';
try { refreshClientRequestsUI(); } catch (e) {
  console.warn('Floating request refresh failed', e);
}
alert('Data loaded and UI updated.');
}

/* Wire up buttons */
document.addEventListener('DOMContentLoaded', () => {
  // Drive buttons
  document.getElementById('btnSignIn')?.addEventListener('click', signInWithGoogle);
  document.getElementById('btnSignOut')?.addEventListener('click', signOutFromGoogle);
  document.getElementById('btnSaveDrive')?.addEventListener('click', saveToDrive);
  document.getElementById('btnLoadDrive')?.addEventListener('click', loadFromDrive);
  initGoogleTokenClient();

  // profile dropdown open/close
  const profileBtn  = document.getElementById('profileMenuButton');
  const profileMenu = document.getElementById('profileMenu');

  profileBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!profileMenu) return;
    profileMenu.classList.toggle('hidden');
  });

   // close profile menu when any option inside it is clicked
  profileMenu?.addEventListener('click', () => {
    profileMenu.classList.add('hidden');
  });

  // click outside closes menu
  document.addEventListener('click', (e) => {
    if (!profileMenu || profileMenu.classList.contains('hidden')) return;
    const wrapper = profileMenu.parentElement;
    if (wrapper && !wrapper.contains(e.target)) {
      profileMenu.classList.add('hidden');
    }
  });

  // --- silent token re-acquire if user was signed-in previously ---
  try {
    const wasSigned = localStorage.getItem('gdrive_signed_in') === '1';
    if (wasSigned) {
      if (!tokenClient) initGoogleTokenClient();
      try {
        tokenClient.requestAccessToken({ prompt: '' });
        console.log('Attempting silent token refresh.');
      } catch (err) {
        console.warn('Silent token request threw:', err);
      }
    }
  } catch (e) {
    console.warn('Silent refresh check failed:', e);
  }
  // ... rest of init ...
   updateProfileIcon();  // keep avatar in sync on first load
});
</script>
<!-- Google Identity + Drive helpers end Hari -->

<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCqRTP3fzHbjfJ0ZkDABWm6nPlLaHmhNsY&libraries=places" async defer></script>

<div id="contactDevBar"
     style="
       width:100%;
       text-align:center;
       padding:10px;
       font-weight:bold;
       color:#b91c1c;
       background:#ffe5e5;
       border-top:2px solid #b91c1c;
       position:fixed;
       bottom:0;
       left:0;
       display:none;
       z-index:9999;
     ">
  Contact Developer
</div>
<style>
  /* Remove top gap under the maroon header */
  #screen-wrapper {
    padding-top: 0 !important;
  }

  /* Add default gap under header for all screens except main dashboard */
#screen-wrapper .screen-container:not(#dashboard) {
  padding-top: 3.25rem; /* adjust if needed */
}
  /* Upcoming Events outer wrapper: no extra padding, full width */
  #dashboardUpcoming {
    margin-top: 0 !important;
    padding: 0 !important;          /* removes px-4 py-3 */
    width: 100% !important;
  }

  /* Yellow notepad sizing / centering */
  #dashboardUpcoming > .border-yellow-400 {
    width: 100% !important;
    max-width: 1150px !important;   /* adjust if you want even wider */
    margin: 0 auto !important;
  }

  /* Remove any extra gap between heading and cards */
  #dashboardUpcomingList {
    margin-top: 0 !important;
    padding-top: 0 !important;
  }
</style>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./service-worker.js')
        .catch(err => console.log('SW registration failed', err));
    });
  }
</script>
</body>
</html>